{
  "xtasker": [
    {
        "key": "advanced-troubleshooting.md",
        "value": "---\ntrigger: model_decision\n---\n\n# 6. Advanced Features & Troubleshooting\n\nThis document covers advanced Wasp capabilities like Jobs, API Routes, and Middleware, along with performance optimization tips and common troubleshooting steps.\n\n## Advanced Features ( [main.wasp](mdc:main.wasp) )\n\nThese features are configured in [main.wasp](mdc:main.wasp).\n\n### Jobs and Workers\n\n- Wasp supports background jobs, useful for tasks like sending emails, processing data, or scheduled operations.\n- Jobs require a job executor like PgBoss (which requires PostgreSQL, see [database-operations.mdc](mdc:template/app/.cursor/rules/database-operations.mdc)).\n- Example Job definition in [main.wasp](mdc:main.wasp):\n  ```wasp\n  job emailSender {\n    executor: PgBoss, // Requires PostgreSQL\n    // Define the function that performs the job\n    perform: {\n      fn: import { sendEmail } from \"@src/server/jobs/emailSender.js\"\n    },\n    // Grant access to necessary entities\n    entities: [User, EmailQueue]\n  }\n  ```\n- Jobs can be scheduled or triggered programmatically from Wasp actions or other jobs.\n- See the Wasp Recurring Jobs Docs for more info [wasp-overview.mdc](mdc:template/app/.cursor/rules/wasp-overview.mdc)\n\n### Custom HTTP API Endpoints\n\n- Define custom server API endpoints, often used for external integrations (webhooks, third-party services) where Wasp Operations are not suitable.\n- Example API route definition in [main.wasp](mdc:main.wasp):\n  ```wasp\n  api stripeWebhook {\n    // Implementation function in server code\n    fn: import { handleStripeWebhook } from \"@src/server/apis/stripe.js\",\n    // Define the HTTP method and path\n    httpRoute: (POST, \"/webhooks/stripe\"),\n    // Optional: Grant entity access\n    entities: [User, Payment],\n    // Optional: Apply middleware config function \n    // middlewareConfigFn: import { apiMiddleware } from \"@src/apis\"\n    // Optional: If auth is enabled, this will default to true and provide a context.user\n    // object. If you do not wish to attempt to parse the JWT in the Authorization Header\n    // you should set this to false.\n    // auth: false\n  }\n  ```\n- See the Wasp Custom HTTP API Endpoints docs for more info [wasp-overview.mdc](mdc:template/app/.cursor/rules/wasp-overview.mdc)\n\n### Middleware\n\n- Wasp supports custom middleware functions that can run before API route handlers or Page components.\n- Useful for logging, custom checks, request transformation, etc.\n- Example Middleware definition in [main.wasp](mdc:main.wasp):\n  ```wasp\n  // Customize global middleware\n  app todoApp {\n  // ...\n    server: {\n      middlewareConfigFn: import { serverMiddlewareFn } from \"@src/serverSetup\"\n    },\n  }\n  ```\n- See the Wasp Middleware Docs for more info [wasp-overview.mdc](mdc:template/app/.cursor/rules/wasp-overview.mdc)\n\n## Performance Optimization\n\n- **Operation Dependencies:** Use specific entity dependencies (`entities: [Task]`) in your Wasp operations ([main.wasp](mdc:main.wasp)) to ensure queries are automatically refetched only when relevant data changes.\n- **Pagination:** For queries returning large lists of data, implement pagination logic in your server operation and corresponding UI controls on the client.\n- **React Optimization:**\n  - Use `React.memo` for components that re-render often with the same props.\n  - Use `useMemo` to memoize expensive calculations within components.\n  - Use `useCallback` to memoize functions passed down as props to child components (especially event handlers).\n- **Optimistic UI Updates (Actions):**\n  - For actions where perceived speed is critical (e.g., deleting an item, marking as complete), consider using Wasp's `useAction` hook (from `wasp/client/operations`) with `optimisticUpdates`.\n  - This updates the client-side cache (affecting relevant `useQuery` results) *before* the action completes on the server, providing instant feedback.\n  - **Use Sparingly:** Only implement optimistic updates where the action is highly likely to succeed and the instant feedback significantly improves UX. Remember to handle potential server-side failures gracefully (Wasp helps revert optimistic updates on error).\n  - See the Wasp Actions docs for more info [wasp-overview.mdc](mdc:template/app/.cursor/rules/wasp-overview.mdc)\n\n## Troubleshooting\n\n- **Wasp Type/Import Errors:** If you encounter TypeScript errors related to missing Wasp imports (e.g., from `wasp/client/operations`, `wasp/entities`, `wasp/server`) or unexpected type mismatches after modifying [main.wasp](mdc:main.wasp) or [schema.prisma](mdc:schema.prisma) , **prompt the user to restart the Wasp development server** (`wasp start`) before further debugging. Wasp needs to regenerate code based on these changes.\n- **Operations Not Working:**\n  - Check that all required `entities` are listed in the operation's definition in [main.wasp](mdc:main.wasp).\n  - Verify the import path (`fn: import { ... } from \"@src/...\"`) in [main.wasp](mdc:main.wasp) is correct.\n  - Check for runtime errors in the Wasp server console where `wasp start` is running.\n  - Ensure client-side calls match the expected arguments and types.\n- **Auth Not Working:**\n  - Verify the `auth` configuration in [main.wasp](mdc:main.wasp) (correct `userEntity`, `methods`, `onAuthFailedRedirectTo`).\n  - Ensure `userEntity` in [main.wasp](mdc:main.wasp) matches the actual `User` model name in [schema.prisma](mdc:schema.prisma).\n  - Check Wasp server logs for auth-related errors.\n  - If using social auth, confirm environment variables (e.g., `GOOGLE_CLIENT_ID`) are correctly set (e.g., in a `.env.server` file) and loaded by Wasp.\n- **Database Issues:**\n  - Ensure your [schema.prisma](mdc:schema.prisma) syntax is correct.\n  - Run `wasp db migrate-dev \"Migration description\"` after schema changes to apply them.\n  - If using PostgreSQL, ensure the database server is running.\n  - Check the `.env.server` file for the correct `DATABASE_URL`.\n- **Build/Runtime Errors:**\n  - Check import paths carefully (Wasp vs. relative vs. `@src/` rules, see [project-conventions.mdc](mdc:template/app/.cursor/rules/project-conventions.mdc)).\n  - Ensure all dependencies are installed (`npm install`).\n  - Check the Wasp server console and the browser's developer console for specific error messages.\n\n  ### Referencing Wasp Documentation\n  - Search for and reference applicable LLM-optimized docs, available in [wasp-overview.mdc](mdc:template/app/.cursor/rules/wasp-overview.mdc)",
        "namespace": "xtasker"
    },
    {
        "key": "authentication.md",
        "value": "---\ntrigger: model_decision\n---\n\n# 4. Authentication\n\nThis document gives a quick rundown on how authentication is configured and used within the Wasp application.\n\nSee the Wasp Auth docs for available methods and complete guides [wasp-overview.mdc](mdc:template/app/.cursor/rules/wasp-overview.mdc)\n\n## Wasp Auth Setup\n\n- Wasp provides built-in authentication with minimal configuration via the Wasp config file. \n- Wasp generates all necessary auth routes, middleware, and UI components based on the configuration.\n- Example auth configuration in [main.wasp](mdc:main.wasp):\n  ```wasp\n  app myApp {\n    // ... other config\n    auth: {\n      // Links Wasp auth to your User model in @schema.prisma\n      userEntity: User,\n      methods: {\n        // Enable username/password login\n        usernameAndPassword: {},\n        // Enable Google OAuth login\n        // Requires setting GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET env vars\n        google: {},\n        // Enable email/password login with verification\n        email: {\n          // Set up an email sender (Dummy prints to console)\n          // See https://wasp-lang.com/docs/auth/email-auth#email-sending\n          fromField: {\n            name: \"Budgeting Vibe\",\n            email: \"noreply@budgetingvibe.com\"\n          },\n          emailVerification: {\n            clientRoute: EmailVerificationRoute\n          },\n          passwordReset: {\n            clientRoute: PasswordResetRoute\n          }\n        }\n      },\n      // Route to redirect to if auth fails\n      onAuthFailedRedirectTo: \"/login\",\n      // Optional: Route after successful signup/login\n      // onAuthSucceededRedirectTo: \"/dashboard\"\n    }\n    emailSender: {\n      provider: Dummy // Use Dummy for local dev (prints emails to console)\n      // provider: SMTP // For production, configure SMTP\n    }\n  }\n\n  // Define the routes needed by email auth methods\n  route EmailVerificationRoute { path: \"/auth/verify-email\", to: EmailVerificationPage }\n  page EmailVerificationPage { component: import { EmailVerification } from \"@src/features/auth/EmailVerificationPage.tsx\" }\n\n  route PasswordResetRoute { path: \"/auth/reset-password\", to: PasswordResetPage }\n  page PasswordResetPage { component: import { PasswordReset } from \"@src/features/auth/PasswordResetPage.tsx\" }\n  ```\n\n- **Dummy Email Provider Note:** When `emailSender: { provider: Dummy }` is configured in [main.wasp](mdc:main.wasp), Wasp does not send actual emails. Instead, the content of verification/password reset emails, including the clickable link, will be printed directly to the server console where `wasp start` is running.\n\n## Wasp Auth Rules\n\n- **User Model ( [schema.prisma](mdc:schema.prisma) ):**\n  - Wasp Auth methods handle essential identity fields (like `email`, `password hash`, `provider IDs`, `isVerified`) internally. These are stored in separate Prisma models managed by Wasp (`AuthProvider`, `AuthProviderData`).\n  - Your Prisma `User` model (specified in [main.wasp](mdc:main.wasp) as `auth.userEntity`) typically **only needs the `id` field** for Wasp to link the auth identity.\n    ```prisma\n    // Minimal User model in @schema.prisma\n    model User {\n      id Int @id @default(autoincrement())\n      // Add other *non-auth* related fields as needed\n      // e.g., profile info, preferences, relations to other models\n      // profileImageUrl String?\n      // timeZone        String? @default(\"UTC\")\n    }\n    ```\n  - **Avoid adding** `email`, `emailVerified`, `password`, `username`, or provider-specific ID fields directly to *your* `User` model in [schema.prisma](mdc:schema.prisma) unless you have very specific customization needs that require overriding Wasp's default behavior and managing these fields manually.\n  - If you need frequent access to an identity field like `email` or `username` for *any* user (not just the logged-in one), see the **Recommendation** in the \"Wasp Auth User Fields\" section below.\n\n- **Auth Pages:**\n  - When initially creating Auth pages (Login, Signup), use the pre-built components provided by Wasp for simplicity:\n    - `import { LoginForm, SignupForm } from 'wasp/client/auth';`\n    - These components work with the configured auth methods in [main.wasp](mdc:main.wasp).\n    - You can customize their appearance or build completely custom forms if needed.\n\n- **Protected Routes/Pages:**\n  - Use the `useAuth` hook from `wasp/client/auth` to access the current user's data and check authentication status.\n  - Redirect or show alternative content if the user is not authenticated.\n  ```typescript\n  import { useAuth } from 'wasp/client/auth';\n  import { Redirect } from 'wasp/client/router'; // Or use Link\n\n  const MyProtectedPage = () => {\n    const { data: user, isLoading, error } = useAuth(); // Returns AuthUser | null\n\n    if (isLoading) return <div>Loading...</div>;\n    // If error, it likely means the auth session is invalid/expired\n    if (error || !user) {\n      // Redirect to login page defined in main.wasp (auth.onAuthFailedRedirectTo)\n      // Or return <Redirect to=\"/login\" />;\n      return <div>Please log in to access this page.</div>;\n    }\n\n    // User is authenticated, render the page content\n    // Use helpers like getEmail(user) or getUsername(user) if needed\n    return <div>Welcome back!</div>; // Access user.id if needed\n  };\n  ```\n\n## Wasp Auth User Fields (`AuthUser`)\n\n- The `user` object returned by `useAuth()` hook on the client, or accessed via `context.user` in server operations/APIs, is an `AuthUser` object (type imported from `wasp/auth`).\n- **Auth-specific fields** (email, username, verification status, provider IDs) live under the nested `identities` property based on the auth method used.\n  - e.g., `user.identities.email?.email`\n  - e.g., `user.identities.username?.username`\n  - e.g., `user.identities.google?.providerUserId`\n  - **Always check for `null` or `undefined`** before accessing these nested properties, as a user might not have used all configured auth methods.\n- **Helpers:** Wasp provides helper functions from `wasp/auth` for easier access to common identity fields on the `AuthUser` object:\n  - `import { getEmail, getUsername } from 'wasp/auth';`\n  - `const email = getEmail(user); // Returns string | null`\n  - `const username = getUsername(user); // Returns string | null`\n- **Standard User Entities:** Remember that standard `User` entities fetched via `context.entities.User.findMany()` or similar in server code **DO NOT** automatically include these auth identity fields (`email`, `username`, etc.) by default. They only contain the fields defined directly in your [schema.prisma](mdc:schema.prisma) `User` model.\n- **Recommendation:**\n  - If you need *frequent* access to an identity field like `email` or `username` for *any* user (not just the currently logged-in one accessed via `context.user` or `useAuth`) and want to query it easily via `context.entities.User`, consider this approach:\n    1.  **Add the field directly** to your `User` model in [schema.prisma](mdc:schema.prisma).\n        ```prisma\n        model User {\n          id    Int     @id @default(autoincrement())\n          email String? @unique // Add if needed frequently\n          // other fields...\n        }\n        ```\n    2.  **Ensure this field is populated correctly** when the user signs up or updates their profile. You can do this through the `userSignupFields` property in the wasp config file for each auth method.\n        ```wasp\n        //main.wasp\n        auth: {\n          userEntity: User,\n          methods: {\n            email: { \n              //...\n              userSignupFields: import { getEmailUserFields } from \"@src/auth/userSignupFields\"\n            },\n          }\n        }\n        ```\n        ```ts\n        //userSignupFields.ts\n        import { defineUserSignupFields } from 'wasp/auth/providers/types';\n\n        const userDataSchema = z.object({\n          email: z.string(),\n        });\n\n        export const getEmailUserFields = defineUserSignupFields({\n          email: (data) => {\n            const userData = userDataSchema.parse(data);\n            return userData.email;\n          }\n        })\n        ```\n    3.  This makes the field (`email` in this example) a standard, queryable field on your `User` entity, accessible via `context.entities.User`, separate from the `AuthUser`'s identity structure.\n\n- **Common Issue:** If auth isn't working, first verify the `auth` configuration in [main.wasp](mdc:main.wasp) is correct and matches your intent (correct `userEntity`, enabled `methods`, `onAuthFailedRedirectTo`). Ensure environment variables for social providers are set if applicable. Check the Wasp server logs for errors.",
        "namespace": "xtasker"
    },
    {
        "key": "database-operations.md",
        "value": "---\ntrigger: model_decision\n---\n\n# 3. Database, Entities, and Operations\n\nThis document gives a quick rundown on how Wasp interacts with the database using Prisma, defines Wasp Entities, and explains the rules for creating and using Wasp Operations (Queries and Actions).\n\nSee the Wasp Data Model docs for more info [wasp-overview.mdc](mdc:template/app/.cursor/rules/wasp-overview.mdc)\n\n## Wasp Database and Entities\n\n- Wasp uses Prisma for database access, with models defined in [schema.prisma](mdc:schema.prisma).\n- Prisma models defined in [schema.prisma](mdc:schema.prisma) automatically become Wasp Entities that can be used in operations.\n- Wasp reads the [schema.prisma](mdc:schema.prisma) file to understand your data model and generate appropriate code (e.g., types in `wasp/entities`).\n- Example Prisma model in [schema.prisma](mdc:schema.prisma) :\n  ```prisma\n  model Task {\n    id          Int      @id @default(autoincrement())\n    description String\n    isDone      Boolean  @default(false)\n    user        User     @relation(fields: [userId], references: [id])\n    userId      Int\n  }\n  ```\n\n## Wasp DB Schema Rules (@schema.prisma)\n\n- Add database models directly to the [schema.prisma](mdc:schema.prisma) file, NOT to [main.wasp](mdc:main.wasp) as entities.\n- Generally avoid adding `db.system` or `db.prisma` properties to the [main.wasp](mdc:main.wasp) config file; configure the database provider within [schema.prisma](mdc:schema.prisma) instead.\n  ```prisma\n  // Example in schema.prisma\n  datasource db {\n    provider = \"postgresql\" // or \"sqlite\"\n    url      = env(\"DATABASE_URL\")\n  }\n  ```\n- Keep the [schema.prisma](mdc:schema.prisma) file in the root of the project.\n- **Applying Changes:** After updating [schema.prisma](mdc:schema.prisma), run `wasp db migrate-dev` in the terminal to generate and apply SQL migrations.\n- **Database Choice:** While 'sqlite' is the default, it lacks support for features like Prisma enums or PgBoss scheduled jobs. Use 'postgresql' for such cases. If using PostgreSQL locally, ensure it's running (e.g., via `wasp db start` if using Wasp's built-in Docker setup, or ensure your own instance is running).\n- Define all model relationships (`@relation`) within [schema.prisma](mdc:schema.prisma).\n\n## Wasp Operations (Queries & Actions)\n\n- Operations are how Wasp handles client-server communication, defined in [main.wasp](mdc:main.wasp).\n- **Queries:** Read operations (fetch data).\n- **Actions:** Write operations (create, update, delete data).\n- Operations automatically handle data fetching, caching (for queries), and updates.\n- Operations reference Entities (defined in [schema.prisma](mdc:schema.prisma) ) to establish proper data access patterns and dependencies.\n- Example definitions in [main.wasp](mdc:main.wasp):\n  ```wasp\n  query getTasks {\n    // Points to the implementation function\n    fn: import { getTasks } from \"@src/features/tasks/operations.ts\", // Convention: operations.ts\n    // Grants access to the Task entity within the operation's context\n    entities: [Task]\n  }\n\n  action createTask {\n    fn: import { createTask } from \"@src/features/tasks/operations.ts\",\n    entities: [Task] // Needs access to Task to create one\n  }\n  ```\n\n## Wasp Operations Rules & Implementation\n\n- **Operation File:** Implement query and action functions together in a single `operations.ts` file within the relevant feature directory (e.g., `src/features/tasks/operations.ts`).\n- **Generated Types:** Wasp auto-generates TypeScript types for your operations based on their definitions in [main.wasp](mdc:main.wasp) and the functions' signatures.\n  - Import operation types using `import type { MyQuery, MyAction } from 'wasp/server/operations';`\n  - If types aren't updated after changing [main.wasp](mdc:main.wasp) or the function signature, restart the Wasp dev server (`wasp start`).\n- **Entity Types:** Wasp generates types for your Prisma models from [schema.prisma](mdc:schema.prisma).\n  - Import entity types using `import type { MyModel } from 'wasp/entities';`\n- **Entity Access:** Ensure all Entities needed within an operation's logic are listed in its `entities: [...]` definition in [main.wasp](mdc:main.wasp). This makes `context.entities.YourModel` available.\n- **Internal Communication:** Prioritize Wasp operations for client-server communication within the app. Use Custom HTTP API Endpoints (see [advanced-troubleshooting.mdc](mdc:template/app/.cursor/rules/advanced-troubleshooting.mdc)) primarily for external integrations (webhooks, etc.).\n- **Client-Side Query Usage:** Use Wasp's `useQuery` hook from `wasp/client/operations` to fetch data.\n  - `import { useQuery } from 'wasp/client/operations';`\n  - `const { data, isLoading, error } = useQuery(getQueryName, { queryArgs });`\n- **Client-Side Action Usage:** Call actions *directly* using `async`/`await`. **DO NOT USE** the `useAction` hook unless you specifically need optimistic UI updates (see [advanced-troubleshooting.mdc](mdc:template/app/.cursor/rules/advanced-troubleshooting.mdc)).\n  - `import { myAction } from 'wasp/client/operations';`\n  - `const result = await myAction({ actionArgs });`\n- **Example Operation Implementation (`src/features/tasks/operations.ts`):\n  ```typescript\n  import { HttpError } from 'wasp/server'\n  import type { GetTasks, CreateTask } from 'wasp/server/operations'\n  import type { Task } from 'wasp/entities'\n\n  // Type annotations come from Wasp based on main.wasp definitions\n  export const getTasks: GetTasks<void, Task[]> = async (_args, context) => {\n    if (!context.user) {\n      throw new HttpError(401, 'Not authorized');\n    }\n    // Access entities via context\n    return context.entities.Task.findMany({\n      where: { userId: context.user.id }\n    });\n  }\n\n  type CreateTaskInput = Pick<Task, 'description'>\n  export const createTask: CreateTask<CreateTaskInput, Task> = async (args, context) => {\n    if (!context.user) {\n      throw new HttpError(401, 'Not authorized');\n    }\n\n    return context.entities.Task.create({\n      data: {\n        description: args.description,\n        userId: context.user.id,\n      }\n    });\n  }\n  ```\n\n## Prisma Enum Value Imports\n\n- **Rule:** When you need to use Prisma enum members as *values* (e.g., `MyEnum.VALUE` in logic or comparisons) in your server or client code, import the enum directly from `@prisma/client`, not from `wasp/entities`.\n  - ✅ `import { TransactionType } from '@prisma/client';` (Use as `TransactionType.EXPENSE`)\n  - ❌ `import { TransactionType } from 'wasp/entities';` (This only imports the *type* for annotations, not the runtime *value*)\n\n## Server-Side Error Handling\n\n- Throw `HttpError` from `wasp/server` for expected errors (e.g., unauthorized, not found, bad input) to send structured responses to the client.\n- Log unexpected errors for debugging.\n- Example:\n  ```typescript\n  import { HttpError } from 'wasp/server'\n  import type { UpdateTask } from 'wasp/server/operations'\n  import type { Task } from 'wasp/entities'\n\n  export const updateTask: UpdateTask<{ id: number; data: Partial<Task> }, Task> = async (args, context) => {\n    if (!context.user) {\n      throw new HttpError(401, 'Not authorized');\n    }\n\n    try {\n      const task = await context.entities.Task.findFirst({\n        where: { id: args.id, userId: context.user.id },\n      });\n\n      if (!task) {\n        throw new HttpError(404, 'Task not found');\n      }\n\n      return context.entities.Task.update({\n        where: { id: args.id },\n        data: args.data,\n      });\n    } catch (error) {\n      if (error instanceof HttpError) {\n        throw error; // Re-throw known HttpErrors\n      }\n      // Log unexpected errors\n      console.error('Failed to update task:', error);\n      // Throw a generic server error for unexpected issues\n      throw new HttpError(500, 'Failed to update task due to an internal error.');\n    }\n  }\n  ```",
        "namespace": "xtasker"
    },
    {
        "key": "deployment.md",
        "value": "---\ntrigger: model_decision\ndescription: Deploying full-stack wasp apps via the CLI\n---\n\n# 7. Deployment (Fly.io via Wasp CLI)\n\nThis document outlines the steps to deploy the Wasp application using the Wasp CLI, targeting the Fly.io hosting provider.\n\nFor more info on deployments, see the Wasp deployment docs as mentioned in [wasp-overview.mdc](mdc:template/app/.cursor/rules/wasp-overview.mdc) \n\n## 1. Prerequisites\n\nBefore deploying, ensure the following prerequisites are met:\n\n*   **Fly.io Account:** You need an account with Fly.io (https://fly.io/docs/).\n*   **Billing Information:** Fly.io requires credit card information to be added to your account before you can deploy apps, even if you plan to stay within the free tier limits. Add this via your Fly.io account's billing page.\n*   **Install `flyctl` CLI:** The Fly.io command-line interface (`flyctl`) must be installed on your local machine. Follow the installation instructions here: https://fly.io/docs/flyctl/install/\n*   **Login to `flyctl`:** Authenticate the CLI with your Fly.io account by running:\n    ```bash\n    fly auth login\n    ```\n\n## 2. Deployment Steps\n\nThe Wasp CLI simplifies deployment to a single command.\n\n1.  **Choose App Name and Region:**\n    *   Decide on a **unique base name** for your application (e.g., `my-budget-app`). This name must be unique across all Fly.io applications.\n    *   Select a Fly.io **region** for deployment (e.g., `mia` for Miami, `ams` for Amsterdam). See Fly.io's regions for a list of available regions.\n\n2.  **Run the Deployment Command:**\n    *   Open your terminal in the root directory of your Wasp project.\n    *   Execute the `wasp deploy fly launch` command, replacing `<your-app-name>` and `<chosen-region>` with your choices:\n        ```bash\n        wasp deploy fly launch <your-app-name> <chosen-region>\n        ```\n        *Example:*\n        ```bash\n        wasp deploy fly launch my-budget-app mia\n        ```\n    *   **Important:** Do **NOT** interrupt (e.g., Ctrl+C) the process while the command is running. It performs multiple steps: setting up the Fly app configuration, creating the database, building the project, and deploying the client and server components.\n\n3.  **Specify Fly.io Organization (If Necessary):**\n    *   If your Fly.io account belongs to multiple organizations, you must specify which one to use by adding the `--org <org-slug>` flag to the command.\n    *   Find your organization slugs by running: `fly orgs list`\n    *   *Example with organization:*\n        ```bash\n        wasp deploy fly launch my-budget-app mia --org my-fly-org-slug\n        ```\n\n## 3. Post-Deployment\n\n*   **Generated Files:** The deployment command creates two configuration files in your project root:\n    *   `fly-server.toml`\n    *   `fly-client.toml`\n    *   **Commit these files** to your version control system (e.g., Git). They contain the deployment configuration and are needed for future updates.\n*   **Accessing Your App:** Once deployment is complete, the CLI will output the URLs for your deployed client and server. The client URL is your main application entry point.\n*   **Updating Your App:** To redeploy changes after committing the `.toml` files, you can simply run:\n    ```bash\n    wasp deploy fly deploy\n    ```\n\n*   **Setting Environment Variables (Secrets):**\n    *   If your application requires environment variables beyond the ones Wasp/Fly set automatically (like `DATABASE_URL`), such as API keys or third-party service credentials (e.g., `SENDGRID_API_KEY`, OAuth client secrets), you need to set them as secrets on Fly.io.\n    *   Use the `wasp deploy fly cmd` command to interact with the `flyctl` CLI in the context of your deployed server app.\n    *   **Command:**\n        ```bash\n        wasp deploy fly cmd --context server secrets set VARIABLE_NAME=\"VALUE\"\n        ```\n        *Replace `VARIABLE_NAME` with the name of your environment variable and `VALUE` with its value. Use quotes around the value if it contains special characters.*\n    *   **Example:**\n        ```bash\n        wasp deploy fly cmd --context server secrets set SENDGRID_API_KEY=\"SG.your_actual_api_key\"\n        ```\n    *   You can list currently set secrets (values will be masked) using:\n        ```bash\n        wasp deploy fly cmd --context server secrets list\n        ```\n    *   **Important:** Set these secrets *after* the initial `launch` command completes but *before* your application fully relies on them. If you add new variables later, you might need to redeploy the server for it to pick them up (`wasp deploy fly deploy`).\n\n## 4. Troubleshooting\n\n*   **Unique Name Error:** If deployment fails due to a non-unique name, choose a different `<your-app-name>` and run the `launch` command again.\n*   **Billing Error:** Ensure you have added valid billing information to your Fly.io account.\n*   **Build Failures:** Check the output logs from the `wasp deploy` command for any build errors in your Wasp project code. Fix the errors and attempt deployment again.\n*   **Check Fly.io Dashboard:** Monitor the status and logs of your applications (`<your-app-name>-client`, `<your-app-name>-server`, `<your-app-name>-db`) directly in the Fly.io dashboard.",
        "namespace": "xtasker"
    },
    {
        "key": "dev_workflow.md",
        "value": "---\ndescription: Guide for using Taskmaster to manage task-driven development workflows\nglobs: **/*\nalwaysApply: true\n---\n\n# Taskmaster Development Workflow\n\nThis guide outlines the standard process for using Taskmaster to manage software development projects. It is written as a set of instructions for you, the AI agent.\n\n- **Your Default Stance**: For most projects, the user can work directly within the `master` task context. Your initial actions should operate on this default context unless a clear pattern for multi-context work emerges.\n- **Your Goal**: Your role is to elevate the user's workflow by intelligently introducing advanced features like **Tagged Task Lists** when you detect the appropriate context. Do not force tags on the user; suggest them as a helpful solution to a specific need.\n\n## The Basic Loop\nThe fundamental development cycle you will facilitate is:\n1.  **`list`**: Show the user what needs to be done.\n2.  **`next`**: Help the user decide what to work on.\n3.  **`show <id>`**: Provide details for a specific task.\n4.  **`expand <id>`**: Break down a complex task into smaller, manageable subtasks.\n5.  **Implement**: The user writes the code and tests.\n6.  **`update-subtask`**: Log progress and findings on behalf of the user.\n7.  **`set-status`**: Mark tasks and subtasks as `done` as work is completed.\n8.  **Repeat**.\n\nAll your standard command executions should operate on the user's current task context, which defaults to `master`.\n\n---\n\n## Standard Development Workflow Process\n\n### Simple Workflow (Default Starting Point)\n\nFor new projects or when users are getting started, operate within the `master` tag context:\n\n-   Start new projects by running `initialize_project` tool / `task-master init` or `parse_prd` / `task-master parse-prd --input='<prd-file.txt>'` (see @`taskmaster.md`) to generate initial tasks.json with tagged structure\n-   Configure rule sets during initialization with `--rules` flag (e.g., `task-master init --rules windsurf,windsurf`) or manage them later with `task-master rules add/remove` commands  \n-   Begin coding sessions with `get_tasks` / `task-master list` (see @`taskmaster.md`) to see current tasks, status, and IDs\n-   Determine the next task to work on using `next_task` / `task-master next` (see @`taskmaster.md`)\n-   Analyze task complexity with `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) before breaking down tasks\n-   Review complexity report using `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`)\n-   Select tasks based on dependencies (all marked 'done'), priority level, and ID order\n-   View specific task details using `get_task` / `task-master show <id>` (see @`taskmaster.md`) to understand implementation requirements\n-   Break down complex tasks using `expand_task` / `task-master expand --id=<id> --force --research` (see @`taskmaster.md`) with appropriate flags like `--force` (to replace existing subtasks) and `--research`\n-   Implement code following task details, dependencies, and project standards\n-   Mark completed tasks with `set_task_status` / `task-master set-status --id=<id> --status=done` (see @`taskmaster.md`)\n-   Update dependent tasks when implementation differs from original plan using `update` / `task-master update --from=<id> --prompt=\"...\"` or `update_task` / `task-master update-task --id=<id> --prompt=\"...\"` (see @`taskmaster.md`)\n\n---\n\n## Leveling Up: Agent-Led Multi-Context Workflows\n\nWhile the basic workflow is powerful, your primary opportunity to add value is by identifying when to introduce **Tagged Task Lists**. These patterns are your tools for creating a more organized and efficient development environment for the user, especially if you detect agentic or parallel development happening across the same session.\n\n**Critical Principle**: Most users should never see a difference in their experience. Only introduce advanced workflows when you detect clear indicators that the project has evolved beyond simple task management.\n\n### When to Introduce Tags: Your Decision Patterns\n\nHere are the patterns to look for. When you detect one, you should propose the corresponding workflow to the user.\n\n#### Pattern 1: Simple Git Feature Branching\nThis is the most common and direct use case for tags.\n\n- **Trigger**: The user creates a new git branch (e.g., `git checkout -b feature/user-auth`).\n- **Your Action**: Propose creating a new tag that mirrors the branch name to isolate the feature's tasks from `master`.\n- **Your Suggested Prompt**: *\"I see you've created a new branch named 'feature/user-auth'. To keep all related tasks neatly organized and separate from your main list, I can create a corresponding task tag for you. This helps prevent merge conflicts in your `tasks.json` file later. Shall I create the 'feature-user-auth' tag?\"*\n- **Tool to Use**: `task-master add-tag --from-branch`\n\n#### Pattern 2: Team Collaboration\n- **Trigger**: The user mentions working with teammates (e.g., \"My teammate Alice is handling the database schema,\" or \"I need to review Bob's work on the API.\").\n- **Your Action**: Suggest creating a separate tag for the user's work to prevent conflicts with shared master context.\n- **Your Suggested Prompt**: *\"Since you're working with Alice, I can create a separate task context for your work to avoid conflicts. This way, Alice can continue working with the master list while you have your own isolated context. When you're ready to merge your work, we can coordinate the tasks back to master. Shall I create a tag for your current work?\"*\n- **Tool to Use**: `task-master add-tag my-work --copy-from-current --description=\"My tasks while collaborating with Alice\"`\n\n#### Pattern 3: Experiments or Risky Refactors\n- **Trigger**: The user wants to try something that might not be kept (e.g., \"I want to experiment with switching our state management library,\" or \"Let's refactor the old API module, but I want to keep the current tasks as a reference.\").\n- **Your Action**: Propose creating a sandboxed tag for the experimental work.\n- **Your Suggested Prompt**: *\"This sounds like a great experiment. To keep these new tasks separate from our main plan, I can create a temporary 'experiment-zustand' tag for this work. If we decide not to proceed, we can simply delete the tag without affecting the main task list. Sound good?\"*\n- **Tool to Use**: `task-master add-tag experiment-zustand --description=\"Exploring Zustand migration\"`\n\n#### Pattern 4: Large Feature Initiatives (PRD-Driven)\nThis is a more structured approach for significant new features or epics.\n\n- **Trigger**: The user describes a large, multi-step feature that would benefit from a formal plan.\n- **Your Action**: Propose a comprehensive, PRD-driven workflow.\n- **Your Suggested Prompt**: *\"This sounds like a significant new feature. To manage this effectively, I suggest we create a dedicated task context for it. Here's the plan: I'll create a new tag called 'feature-xyz', then we can draft a Product Requirements Document (PRD) together to scope the work. Once the PRD is ready, I'll automatically generate all the necessary tasks within that new tag. How does that sound?\"*\n- **Your Implementation Flow**:\n    1.  **Create an empty tag**: `task-master add-tag feature-xyz --description \"Tasks for the new XYZ feature\"`. You can also start by creating a git branch if applicable, and then create the tag from that branch.\n    2.  **Collaborate & Create PRD**: Work with the user to create a detailed PRD file (e.g., `.taskmaster/docs/feature-xyz-prd.txt`).\n    3.  **Parse PRD into the new tag**: `task-master parse-prd .taskmaster/docs/feature-xyz-prd.txt --tag feature-xyz`\n    4.  **Prepare the new task list**: Follow up by suggesting `analyze-complexity` and `expand-all` for the newly created tasks within the `feature-xyz` tag.\n\n#### Pattern 5: Version-Based Development\nTailor your approach based on the project maturity indicated by tag names.\n\n- **Prototype/MVP Tags** (`prototype`, `mvp`, `poc`, `v0.x`):\n  - **Your Approach**: Focus on speed and functionality over perfection\n  - **Task Generation**: Create tasks that emphasize \"get it working\" over \"get it perfect\"\n  - **Complexity Level**: Lower complexity, fewer subtasks, more direct implementation paths\n  - **Research Prompts**: Include context like \"This is a prototype - prioritize speed and basic functionality over optimization\"\n  - **Example Prompt Addition**: *\"Since this is for the MVP, I'll focus on tasks that get core functionality working quickly rather than over-engineering.\"*\n\n- **Production/Mature Tags** (`v1.0+`, `production`, `stable`):\n  - **Your Approach**: Emphasize robustness, testing, and maintainability\n  - **Task Generation**: Include comprehensive error handling, testing, documentation, and optimization\n  - **Complexity Level**: Higher complexity, more detailed subtasks, thorough implementation paths\n  - **Research Prompts**: Include context like \"This is for production - prioritize reliability, performance, and maintainability\"\n  - **Example Prompt Addition**: *\"Since this is for production, I'll ensure tasks include proper error handling, testing, and documentation.\"*\n\n### Advanced Workflow (Tag-Based & PRD-Driven)\n\n**When to Transition**: Recognize when the project has evolved (or has initiated a project which existing code) beyond simple task management. Look for these indicators:\n- User mentions teammates or collaboration needs\n- Project has grown to 15+ tasks with mixed priorities\n- User creates feature branches or mentions major initiatives\n- User initializes Taskmaster on an existing, complex codebase\n- User describes large features that would benefit from dedicated planning\n\n**Your Role in Transition**: Guide the user to a more sophisticated workflow that leverages tags for organization and PRDs for comprehensive planning.\n\n#### Master List Strategy (High-Value Focus)\nOnce you transition to tag-based workflows, the `master` tag should ideally contain only:\n- **High-level deliverables** that provide significant business value\n- **Major milestones** and epic-level features\n- **Critical infrastructure** work that affects the entire project\n- **Release-blocking** items\n\n**What NOT to put in master**:\n- Detailed implementation subtasks (these go in feature-specific tags' parent tasks)\n- Refactoring work (create dedicated tags like `refactor-auth`)\n- Experimental features (use `experiment-*` tags)\n- Team member-specific tasks (use person-specific tags)\n\n#### PRD-Driven Feature Development\n\n**For New Major Features**:\n1. **Identify the Initiative**: When user describes a significant feature\n2. **Create Dedicated Tag**: `add_tag feature-[name] --description=\"[Feature description]\"`\n3. **Collaborative PRD Creation**: Work with user to create comprehensive PRD in `.taskmaster/docs/feature-[name]-prd.txt`\n4. **Parse & Prepare**: \n   - `parse_prd .taskmaster/docs/feature-[name]-prd.txt --tag=feature-[name]`\n   - `analyze_project_complexity --tag=feature-[name] --research`\n   - `expand_all --tag=feature-[name] --research`\n5. **Add Master Reference**: Create a high-level task in `master` that references the feature tag\n\n**For Existing Codebase Analysis**:\nWhen users initialize Taskmaster on existing projects:\n1. **Codebase Discovery**: Use your native tools for producing deep context about the code base. You may use `research` tool with `--tree` and `--files` to collect up to date information using the existing architecture as context.\n2. **Collaborative Assessment**: Work with user to identify improvement areas, technical debt, or new features\n3. **Strategic PRD Creation**: Co-author PRDs that include:\n   - Current state analysis (based on your codebase research)\n   - Proposed improvements or new features\n   - Implementation strategy considering existing code\n4. **Tag-Based Organization**: Parse PRDs into appropriate tags (`refactor-api`, `feature-dashboard`, `tech-debt`, etc.)\n5. **Master List Curation**: Keep only the most valuable initiatives in master\n\nThe parse-prd's `--append` flag enables the user to parse multiple PRDs within tags or across tags. PRDs should be focused and the number of tasks they are parsed into should be strategically chosen relative to the PRD's complexity and level of detail.\n\n### Workflow Transition Examples\n\n**Example 1: Simple → Team-Based**\n```\nUser: \"Alice is going to help with the API work\"\nYour Response: \"Great! To avoid conflicts, I'll create a separate task context for your work. Alice can continue with the master list while you work in your own context. When you're ready to merge, we can coordinate the tasks back together.\"\nAction: add_tag my-api-work --copy-from-current --description=\"My API tasks while collaborating with Alice\"\n```\n\n**Example 2: Simple → PRD-Driven**\n```\nUser: \"I want to add a complete user dashboard with analytics, user management, and reporting\"\nYour Response: \"This sounds like a major feature that would benefit from detailed planning. Let me create a dedicated context for this work and we can draft a PRD together to ensure we capture all requirements.\"\nActions: \n1. add_tag feature-dashboard --description=\"User dashboard with analytics and management\"\n2. Collaborate on PRD creation\n3. parse_prd dashboard-prd.txt --tag=feature-dashboard\n4. Add high-level \"User Dashboard\" task to master\n```\n\n**Example 3: Existing Project → Strategic Planning**\n```\nUser: \"I just initialized Taskmaster on my existing React app. It's getting messy and I want to improve it.\"\nYour Response: \"Let me research your codebase to understand the current architecture, then we can create a strategic plan for improvements.\"\nActions:\n1. research \"Current React app architecture and improvement opportunities\" --tree --files=src/\n2. Collaborate on improvement PRD based on findings\n3. Create tags for different improvement areas (refactor-components, improve-state-management, etc.)\n4. Keep only major improvement initiatives in master\n```\n\n---\n\n## Primary Interaction: MCP Server vs. CLI\n\nTaskmaster offers two primary ways to interact:\n\n1.  **MCP Server (Recommended for Integrated Tools)**:\n    - For AI agents and integrated development environments (like Windsurf), interacting via the **MCP server is the preferred method**.\n    - The MCP server exposes Taskmaster functionality through a set of tools (e.g., `get_tasks`, `add_subtask`).\n    - This method offers better performance, structured data exchange, and richer error handling compared to CLI parsing.\n    - Refer to @`mcp.md` for details on the MCP architecture and available tools.\n    - A comprehensive list and description of MCP tools and their corresponding CLI commands can be found in @`taskmaster.md`.\n    - **Restart the MCP server** if core logic in `scripts/modules` or MCP tool/direct function definitions change.\n    - **Note**: MCP tools fully support tagged task lists with complete tag management capabilities.\n\n2.  **`task-master` CLI (For Users & Fallback)**:\n    - The global `task-master` command provides a user-friendly interface for direct terminal interaction.\n    - It can also serve as a fallback if the MCP server is inaccessible or a specific function isn't exposed via MCP.\n    - Install globally with `npm install -g task-master-ai` or use locally via `npx task-master-ai ...`.\n    - The CLI commands often mirror the MCP tools (e.g., `task-master list` corresponds to `get_tasks`).\n    - Refer to @`taskmaster.md` for a detailed command reference.\n    - **Tagged Task Lists**: CLI fully supports the new tagged system with seamless migration.\n\n## How the Tag System Works (For Your Reference)\n\n- **Data Structure**: Tasks are organized into separate contexts (tags) like \"master\", \"feature-branch\", or \"v2.0\".\n- **Silent Migration**: Existing projects automatically migrate to use a \"master\" tag with zero disruption.\n- **Context Isolation**: Tasks in different tags are completely separate. Changes in one tag do not affect any other tag.\n- **Manual Control**: The user is always in control. There is no automatic switching. You facilitate switching by using `use-tag <name>`.\n- **Full CLI & MCP Support**: All tag management commands are available through both the CLI and MCP tools for you to use. Refer to @`taskmaster.md` for a full command list.\n\n---\n\n## Task Complexity Analysis\n\n-   Run `analyze_project_complexity` / `task-master analyze-complexity --research` (see @`taskmaster.md`) for comprehensive analysis\n-   Review complexity report via `complexity_report` / `task-master complexity-report` (see @`taskmaster.md`) for a formatted, readable version.\n-   Focus on tasks with highest complexity scores (8-10) for detailed breakdown\n-   Use analysis results to determine appropriate subtask allocation\n-   Note that reports are automatically used by the `expand_task` tool/command\n\n## Task Breakdown Process\n\n-   Use `expand_task` / `task-master expand --id=<id>`. It automatically uses the complexity report if found, otherwise generates default number of subtasks.\n-   Use `--num=<number>` to specify an explicit number of subtasks, overriding defaults or complexity report recommendations.\n-   Add `--research` flag to leverage Perplexity AI for research-backed expansion.\n-   Add `--force` flag to clear existing subtasks before generating new ones (default is to append).\n-   Use `--prompt=\"<context>\"` to provide additional context when needed.\n-   Review and adjust generated subtasks as necessary.\n-   Use `expand_all` tool or `task-master expand --all` to expand multiple pending tasks at once, respecting flags like `--force` and `--research`.\n-   If subtasks need complete replacement (regardless of the `--force` flag on `expand`), clear them first with `clear_subtasks` / `task-master clear-subtasks --id=<id>`.\n\n## Implementation Drift Handling\n\n-   When implementation differs significantly from planned approach\n-   When future tasks need modification due to current implementation choices\n-   When new dependencies or requirements emerge\n-   Use `update` / `task-master update --from=<futureTaskId> --prompt='<explanation>\\nUpdate context...' --research` to update multiple future tasks.\n-   Use `update_task` / `task-master update-task --id=<taskId> --prompt='<explanation>\\nUpdate context...' --research` to update a single specific task.\n\n## Task Status Management\n\n-   Use 'pending' for tasks ready to be worked on\n-   Use 'done' for completed and verified tasks\n-   Use 'deferred' for postponed tasks\n-   Add custom status values as needed for project-specific workflows\n\n## Task Structure Fields\n\n- **id**: Unique identifier for the task (Example: `1`, `1.1`)\n- **title**: Brief, descriptive title (Example: `\"Initialize Repo\"`)\n- **description**: Concise summary of what the task involves (Example: `\"Create a new repository, set up initial structure.\"`)\n- **status**: Current state of the task (Example: `\"pending\"`, `\"done\"`, `\"deferred\"`)\n- **dependencies**: IDs of prerequisite tasks (Example: `[1, 2.1]`)\n    - Dependencies are displayed with status indicators (✅ for completed, ⏱️ for pending)\n    - This helps quickly identify which prerequisite tasks are blocking work\n- **priority**: Importance level (Example: `\"high\"`, `\"medium\"`, `\"low\"`)\n- **details**: In-depth implementation instructions (Example: `\"Use GitHub client ID/secret, handle callback, set session token.\"`) \n- **testStrategy**: Verification approach (Example: `\"Deploy and call endpoint to confirm 'Hello World' response.\"`) \n- **subtasks**: List of smaller, more specific tasks (Example: `[{\"id\": 1, \"title\": \"Configure OAuth\", ...}]`) \n- Refer to task structure details (previously linked to `tasks.md`).\n\n## Configuration Management (Updated)\n\nTaskmaster configuration is managed through two main mechanisms:\n\n1.  **`.taskmaster/config.json` File (Primary):**\n    *   Located in the project root directory.\n    *   Stores most configuration settings: AI model selections (main, research, fallback), parameters (max tokens, temperature), logging level, default subtasks/priority, project name, etc.\n    *   **Tagged System Settings**: Includes `global.defaultTag` (defaults to \"master\") and `tags` section for tag management configuration.\n    *   **Managed via `task-master models --setup` command.** Do not edit manually unless you know what you are doing.\n    *   **View/Set specific models via `task-master models` command or `models` MCP tool.**\n    *   Created automatically when you run `task-master models --setup` for the first time or during tagged system migration.\n\n2.  **Environment Variables (`.env` / `mcp.json`):**\n    *   Used **only** for sensitive API keys and specific endpoint URLs.\n    *   Place API keys (one per provider) in a `.env` file in the project root for CLI usage.\n    *   For MCP/Windsurf integration, configure these keys in the `env` section of `.windsurf/mcp.json`.\n    *   Available keys/variables: See `assets/env.example` or the Configuration section in the command reference (previously linked to `taskmaster.md`).\n\n3.  **`.taskmaster/state.json` File (Tagged System State):**\n    *   Tracks current tag context and migration status.\n    *   Automatically created during tagged system migration.\n    *   Contains: `currentTag`, `lastSwitched`, `migrationNoticeShown`.\n\n**Important:** Non-API key settings (like model selections, `MAX_TOKENS`, `TASKMASTER_LOG_LEVEL`) are **no longer configured via environment variables**. Use the `task-master models` command (or `--setup` for interactive configuration) or the `models` MCP tool.\n**If AI commands FAIL in MCP** verify that the API key for the selected provider is present in the `env` section of `.windsurf/mcp.json`.\n**If AI commands FAIL in CLI** verify that the API key for the selected provider is present in the `.env` file in the root of the project.\n\n## Rules Management\n\nTaskmaster supports multiple AI coding assistant rule sets that can be configured during project initialization or managed afterward:\n\n- **Available Profiles**: Claude Code, Cline, Codex, Windsurf, Roo Code, Trae, Windsurf (claude, cline, codex, windsurf, roo, trae, windsurf)\n- **During Initialization**: Use `task-master init --rules windsurf,windsurf` to specify which rule sets to include\n- **After Initialization**: Use `task-master rules add <profiles>` or `task-master rules remove <profiles>` to manage rule sets\n- **Interactive Setup**: Use `task-master rules setup` to launch an interactive prompt for selecting rule profiles\n- **Default Behavior**: If no `--rules` flag is specified during initialization, all available rule profiles are included\n- **Rule Structure**: Each profile creates its own directory (e.g., `.windsurf/rules`, `.roo/rules`) with appropriate configuration files\n\n## Determining the Next Task\n\n- Run `next_task` / `task-master next` to show the next task to work on.\n- The command identifies tasks with all dependencies satisfied\n- Tasks are prioritized by priority level, dependency count, and ID\n- The command shows comprehensive task information including:\n    - Basic task details and description\n    - Implementation details\n    - Subtasks (if they exist)\n    - Contextual suggested actions\n- Recommended before starting any new development work\n- Respects your project's dependency structure\n- Ensures tasks are completed in the appropriate sequence\n- Provides ready-to-use commands for common task actions\n\n## Viewing Specific Task Details\n\n- Run `get_task` / `task-master show <id>` to view a specific task.\n- Use dot notation for subtasks: `task-master show 1.2` (shows subtask 2 of task 1)\n- Displays comprehensive information similar to the next command, but for a specific task\n- For parent tasks, shows all subtasks and their current status\n- For subtasks, shows parent task information and relationship\n- Provides contextual suggested actions appropriate for the specific task\n- Useful for examining task details before implementation or checking status\n\n## Managing Task Dependencies\n\n- Use `add_dependency` / `task-master add-dependency --id=<id> --depends-on=<id>` to add a dependency.\n- Use `remove_dependency` / `task-master remove-dependency --id=<id> --depends-on=<id>` to remove a dependency.\n- The system prevents circular dependencies and duplicate dependency entries\n- Dependencies are checked for existence before being added or removed\n- Task files are automatically regenerated after dependency changes\n- Dependencies are visualized with status indicators in task listings and files\n\n## Task Reorganization\n\n- Use `move_task` / `task-master move --from=<id> --to=<id>` to move tasks or subtasks within the hierarchy\n- This command supports several use cases:\n  - Moving a standalone task to become a subtask (e.g., `--from=5 --to=7`)\n  - Moving a subtask to become a standalone task (e.g., `--from=5.2 --to=7`) \n  - Moving a subtask to a different parent (e.g., `--from=5.2 --to=7.3`)\n  - Reordering subtasks within the same parent (e.g., `--from=5.2 --to=5.4`)\n  - Moving a task to a new, non-existent ID position (e.g., `--from=5 --to=25`)\n  - Moving multiple tasks at once using comma-separated IDs (e.g., `--from=10,11,12 --to=16,17,18`)\n- The system includes validation to prevent data loss:\n  - Allows moving to non-existent IDs by creating placeholder tasks\n  - Prevents moving to existing task IDs that have content (to avoid overwriting)\n  - Validates source tasks exist before attempting to move them\n- The system maintains proper parent-child relationships and dependency integrity\n- Task files are automatically regenerated after the move operation\n- This provides greater flexibility in organizing and refining your task structure as project understanding evolves\n- This is especially useful when dealing with potential merge conflicts arising from teams creating tasks on separate branches. Solve these conflicts very easily by moving your tasks and keeping theirs.\n\n## Iterative Subtask Implementation\n\nOnce a task has been broken down into subtasks using `expand_task` or similar methods, follow this iterative process for implementation:\n\n1.  **Understand the Goal (Preparation):**\n    *   Use `get_task` / `task-master show <subtaskId>` (see @`taskmaster.md`) to thoroughly understand the specific goals and requirements of the subtask.\n\n2.  **Initial Exploration & Planning (Iteration 1):**\n    *   This is the first attempt at creating a concrete implementation plan.\n    *   Explore the codebase to identify the precise files, functions, and even specific lines of code that will need modification.\n    *   Determine the intended code changes (diffs) and their locations.\n    *   Gather *all* relevant details from this exploration phase.\n\n3.  **Log the Plan:**\n    *   Run `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<detailed plan>'`.\n    *   Provide the *complete and detailed* findings from the exploration phase in the prompt. Include file paths, line numbers, proposed diffs, reasoning, and any potential challenges identified. Do not omit details. The goal is to create a rich, timestamped log within the subtask's `details`.\n\n4.  **Verify the Plan:**\n    *   Run `get_task` / `task-master show <subtaskId>` again to confirm that the detailed implementation plan has been successfully appended to the subtask's details.\n\n5.  **Begin Implementation:**\n    *   Set the subtask status using `set_task_status` / `task-master set-status --id=<subtaskId> --status=in-progress`.\n    *   Start coding based on the logged plan.\n\n6.  **Refine and Log Progress (Iteration 2+):**\n    *   As implementation progresses, you will encounter challenges, discover nuances, or confirm successful approaches.\n    *   **Before appending new information**: Briefly review the *existing* details logged in the subtask (using `get_task` or recalling from context) to ensure the update adds fresh insights and avoids redundancy.\n    *   **Regularly** use `update_subtask` / `task-master update-subtask --id=<subtaskId> --prompt='<update details>\\n- What worked...\\n- What didn't work...'` to append new findings.\n    *   **Crucially, log:**\n        *   What worked (\"fundamental truths\" discovered).\n        *   What didn't work and why (to avoid repeating mistakes).\n        *   Specific code snippets or configurations that were successful.\n        *   Decisions made, especially if confirmed with user input.\n        *   Any deviations from the initial plan and the reasoning.\n    *   The objective is to continuously enrich the subtask's details, creating a log of the implementation journey that helps the AI (and human developers) learn, adapt, and avoid repeating errors.\n\n7.  **Review & Update Rules (Post-Implementation):**\n    *   Once the implementation for the subtask is functionally complete, review all code changes and the relevant chat history.\n    *   Identify any new or modified code patterns, conventions, or best practices established during the implementation.\n    *   Create new or update existing rules following internal guidelines (previously linked to `cursor_rules.md` and `self_improve.md`).\n\n8.  **Mark Task Complete:**\n    *   After verifying the implementation and updating any necessary rules, mark the subtask as completed: `set_task_status` / `task-master set-status --id=<subtaskId> --status=done`.\n\n9.  **Commit Changes (If using Git):**\n    *   Stage the relevant code changes and any updated/new rule files (`git add .`).\n    *   Craft a comprehensive Git commit message summarizing the work done for the subtask, including both code implementation and any rule adjustments.\n    *   Execute the commit command directly in the terminal (e.g., `git commit -m 'feat(module): Implement feature X for subtask <subtaskId>\\n\\n- Details about changes...\\n- Updated rule Y for pattern Z'`).\n    *   Consider if a Changeset is needed according to internal versioning guidelines (previously linked to `changeset.md`). If so, run `npm run changeset`, stage the generated file, and amend the commit or create a new one.\n\n10. **Proceed to Next Subtask:**\n    *   Identify the next subtask (e.g., using `next_task` / `task-master next`).\n\n## Code Analysis & Refactoring Techniques\n\n- **Top-Level Function Search**:\n    - Useful for understanding module structure or planning refactors.\n    - Use grep/ripgrep to find exported functions/constants:\n      `rg \"export (async function|function|const) \\w+\"` or similar patterns.\n    - Can help compare functions between files during migrations or identify potential naming conflicts.\n\n---\n*This workflow provides a general guideline. Adapt it based on your specific project needs and team practices.*",
        "namespace": "xtasker"
    },
    {
        "key": "possible-solutions-thinking.md",
        "value": "---\ntrigger: always_on\n---\n\nThink about a few possible scenarios or solutions to this problem. Present the one you think is best suited to solve this issue and provide rationale for why you think it's the best one.",
        "namespace": "xtasker"
    },
    {
        "key": "project-conventions.md",
        "value": "---\ntrigger: always_on\n---\n\n# 2. Project Conventions and Rules\n\nThis document outlines the specific conventions, file structures, and general rules for this Wasp project.\n\n## Quick Reference\n\n### Common Patterns\n\n- Define app structure in the Wasp config file: [main.wasp](mdc:main.wasp) or `main.wasp.ts`.\n- Define data models (\"entities\") in [schema.prisma](mdc:schema.prisma).\n- Group feature code in `src/{featureName}` directories.\n- Group feature config definitions (e.g. routes, pages, operations, etc.) into sections within the Wasp config file ([main.wasp](mdc:main.wasp)) using the `//#region` directive:\n  ```wasp\n  // Example in @main.wasp\n  // #region {FeatureName}\n  // ... feature-specific declarations ...\n  // #endregion\n  ```\n- Use Wasp operations (queries/actions) for client-server communication (See [database-operations.mdc](mdc:template/app/.cursor/rules/database-operations.mdc)).\n- **Wasp Imports:** Import from `wasp/...` not `@wasp/...` in `.ts`/`.tsx` files.\n\n### Common Issues & Import Rules\n\n- **Wasp Imports in `.ts`/`.tsx`:** Always use the `wasp/...` prefix.\n  - ✅ `import { Task } from 'wasp/entities'`\n  - ✅ `import type { GetTasks } from 'wasp/server/operations'`\n  - ✅ `import { getTasks, useQuery } from 'wasp/client/operations'`\n  - ❌ `import { ... } from '@wasp/...'`\n  - ❌ `import { ... } from '@src/featureName/...'` (Use relative paths for non-Wasp imports within `src`)\n  - If you see \"Cannot find module 'wasp/...'\": Double-check the import path prefix.\n- **Wasp Config Imports in [main.wasp](mdc:main.wasp) :** Imports of your code *must* start with `@src/`.\n  - ✅ `component: import { LoginPage } from \"@src/auth/LoginPage.tsx\"`\n  - ❌ `component: import { LoginPage } from \"../src/auth/LoginPage.tsx\"`\n  - ❌ `component: import { LoginPage } from \"client/pages/auth/LoginPage.tsx\"`\n- **General Imports in `.ts`/`.tsx`:** Use relative paths for imports within the `src/` directory. Avoid using the `@src/` alias directly in `.ts`/`.tsx` files.\n  - If you see \"Cannot find module '@src/...'\": Use a relative path instead.\n- **Prisma Enum *Value* Imports:** Import directly from `@prisma/client`. See [database-operations.mdc](mdc:template/app/.cursor/rules/database-operations.mdc).\n- **Wasp Actions Client-Side:** Call actions directly using `async/await`. DO NOT USE the `useAction` hook unless optimistic updates are needed. See [database-operations.mdc](mdc:template/app/.cursor/rules/database-operations.mdc).\n  - ✅ `import { deleteTask } from 'wasp/client/operations'; await deleteTask({ taskId });`\n- Root Component (`src/App.tsx` or similar):\n  - Ensure the root component defined in @main.wasp (usually via `app.client.rootComponent`) renders the `<Outlet />` component from `react-router-dom` to display nested page content.\n    ```tsx\n    // Example Root Component\n    import React from 'react';\n    import { Outlet } from 'react-router-dom';\n    import Header from './Header'; // Example shared component\n\n    function App() {\n      return (\n        <div className=\"min-h-screen bg-gray-100\">\n          <Header />\n          <main className=\"container mx-auto p-4\">\n            {/* Outlet renders the content of the matched route/page */}\n            <Outlet />\n          </main>\n        </div>\n      );\n    }\n    export default App;\n    ```\n\n## Rules\n\n### General Rules\n\n- Always reference the Wasp config file ([main.wasp](mdc:main.wasp) or `main.wasp.ts`) as your source of truth for the app's configuration and structure.\n- Group feature config definitions in the Wasp config file using `//#region` (as noted above).\n- Group feature code into feature directories (e.g. `src/transactions`).\n- Use the latest Wasp version, as defined in the Wasp configl file.\n- Combine Wasp operations (queries and actions) into an `operations.ts` file within the feature directory (e.g., `src/transactions/operations.ts`).\n- Always use TypeScript for Wasp code (`.ts`/`.tsx`).\n\n### Wasp Dependencies\n\n- Avoid adding dependencies directly to the [main.wasp](mdc:main.wasp) config file.\n- Install dependencies via `npm install` instead. This updates [package.json](mdc:package.json) and [package-lock.json](mdc:package-lock.json)\n\n### Referencing Documentation\n- Make sure the user has added the applicable LLM-optimized docs, available in  [wasp-overview.mdc](mdc:template/app/.cursor/rules/wasp-overview.mdc), in the chat context or settings when using AI-assisted coding tools.",
        "namespace": "xtasker"
    },
    {
        "key": "self_improve.md",
        "value": "---\ndescription: Guidelines for continuously improving Windsurf rules based on emerging code patterns and best practices.\nglobs: **/*\nalwaysApply: true\n---\n\n- **Rule Improvement Triggers:**\n  - New code patterns not covered by existing rules\n  - Repeated similar implementations across files\n  - Common error patterns that could be prevented\n  - New libraries or tools being used consistently\n  - Emerging best practices in the codebase\n\n- **Analysis Process:**\n  - Compare new code with existing rules\n  - Identify patterns that should be standardized\n  - Look for references to external documentation\n  - Check for consistent error handling patterns\n  - Monitor test patterns and coverage\n\n- **Rule Updates:**\n  - **Add New Rules When:**\n    - A new technology/pattern is used in 3+ files\n    - Common bugs could be prevented by a rule\n    - Code reviews repeatedly mention the same feedback\n    - New security or performance patterns emerge\n\n  - **Modify Existing Rules When:**\n    - Better examples exist in the codebase\n    - Additional edge cases are discovered\n    - Related rules have been updated\n    - Implementation details have changed\n\n- **Example Pattern Recognition:**\n  ```typescript\n  // If you see repeated patterns like:\n  const data = await prisma.user.findMany({\n    select: { id: true, email: true },\n    where: { status: 'ACTIVE' }\n  });\n  \n  // Consider adding to [prisma.md](.windsurf/rules/prisma.md):\n  // - Standard select fields\n  // - Common where conditions\n  // - Performance optimization patterns\n  ```\n\n- **Rule Quality Checks:**\n  - Rules should be actionable and specific\n  - Examples should come from actual code\n  - References should be up to date\n  - Patterns should be consistently enforced\n\n- **Continuous Improvement:**\n  - Monitor code review comments\n  - Track common development questions\n  - Update rules after major refactors\n  - Add links to relevant documentation\n  - Cross-reference related rules\n\n- **Rule Deprecation:**\n  - Mark outdated patterns as deprecated\n  - Remove rules that no longer apply\n  - Update references to deprecated rules\n  - Document migration paths for old patterns\n\n- **Documentation Updates:**\n  - Keep examples synchronized with code\n  - Update references to external docs\n  - Maintain links between related rules\n  - Document breaking changes\nFollow [windsurf_rules.md](.windsurf/rules/windsurf_rules.md) for proper rule formatting and structure.\n",
        "namespace": "xtasker"
    },
    {
        "key": "taskmaster.md",
        "value": "---\ndescription: Comprehensive reference for Taskmaster MCP tools and CLI commands.\nglobs: **/*\nalwaysApply: true\n---\n\n# Taskmaster Tool & Command Reference\n\nThis document provides a detailed reference for interacting with Taskmaster, covering both the recommended MCP tools, suitable for integrations like Windsurf, and the corresponding `task-master` CLI commands, designed for direct user interaction or fallback.\n\n**Note:** For interacting with Taskmaster programmatically or via integrated tools, using the **MCP tools is strongly recommended** due to better performance, structured data, and error handling. The CLI commands serve as a user-friendly alternative and fallback. \n\n**Important:** Several MCP tools involve AI processing... The AI-powered tools include `parse_prd`, `analyze_project_complexity`, `update_subtask`, `update_task`, `update`, `expand_all`, `expand_task`, and `add_task`.\n\n**🏷️ Tagged Task Lists System:** Task Master now supports **tagged task lists** for multi-context task management. This allows you to maintain separate, isolated lists of tasks for different features, branches, or experiments. Existing projects are seamlessly migrated to use a default \"master\" tag. Most commands now support a `--tag <name>` flag to specify which context to operate on. If omitted, commands use the currently active tag.\n\n---\n\n## Initialization & Setup\n\n### 1. Initialize Project (`init`)\n\n*   **MCP Tool:** `initialize_project`\n*   **CLI Command:** `task-master init [options]`\n*   **Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project.`\n*   **Key CLI Options:**\n    *   `--name <name>`: `Set the name for your project in Taskmaster's configuration.`\n    *   `--description <text>`: `Provide a brief description for your project.`\n    *   `--version <version>`: `Set the initial version for your project, e.g., '0.1.0'.`\n    *   `-y, --yes`: `Initialize Taskmaster quickly using default settings without interactive prompts.`\n*   **Usage:** Run this once at the beginning of a new project.\n*   **MCP Variant Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project by running the 'task-master init' command.`\n*   **Key MCP Parameters/Options:**\n    *   `projectName`: `Set the name for your project.` (CLI: `--name <name>`)\n    *   `projectDescription`: `Provide a brief description for your project.` (CLI: `--description <text>`)\n    *   `projectVersion`: `Set the initial version for your project, e.g., '0.1.0'.` (CLI: `--version <version>`)\n    *   `authorName`: `Author name.` (CLI: `--author <author>`)\n    *   `skipInstall`: `Skip installing dependencies. Default is false.` (CLI: `--skip-install`)\n    *   `addAliases`: `Add shell aliases tm and taskmaster. Default is false.` (CLI: `--aliases`)\n    *   `yes`: `Skip prompts and use defaults/provided arguments. Default is false.` (CLI: `-y, --yes`)\n*   **Usage:** Run this once at the beginning of a new project, typically via an integrated tool like Windsurf. Operates on the current working directory of the MCP server. \n*   **Important:** Once complete, you *MUST* parse a prd in order to generate tasks. There will be no tasks files until then. The next step after initializing should be to create a PRD using the example PRD in .taskmaster/templates/example_prd.txt. \n*   **Tagging:** Use the `--tag` option to parse the PRD into a specific, non-default tag context. If the tag doesn't exist, it will be created automatically. Example: `task-master parse-prd spec.txt --tag=new-feature`.\n\n### 2. Parse PRD (`parse_prd`)\n\n*   **MCP Tool:** `parse_prd`\n*   **CLI Command:** `task-master parse-prd [file] [options]`\n*   **Description:** `Parse a Product Requirements Document, PRD, or text file with Taskmaster to automatically generate an initial set of tasks in tasks.json.`\n*   **Key Parameters/Options:**\n    *   `input`: `Path to your PRD or requirements text file that Taskmaster should parse for tasks.` (CLI: `[file]` positional or `-i, --input <file>`)\n    *   `output`: `Specify where Taskmaster should save the generated 'tasks.json' file. Defaults to '.taskmaster/tasks/tasks.json'.` (CLI: `-o, --output <file>`)\n    *   `numTasks`: `Approximate number of top-level tasks Taskmaster should aim to generate from the document.` (CLI: `-n, --num-tasks <number>`)\n    *   `force`: `Use this to allow Taskmaster to overwrite an existing 'tasks.json' without asking for confirmation.` (CLI: `-f, --force`)\n*   **Usage:** Useful for bootstrapping a project from an existing requirements document.\n*   **Notes:** Task Master will strictly adhere to any specific requirements mentioned in the PRD, such as libraries, database schemas, frameworks, tech stacks, etc., while filling in any gaps where the PRD isn't fully specified. Tasks are designed to provide the most direct implementation path while avoiding over-engineering.\n*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress. If the user does not have a PRD, suggest discussing their idea and then use the example PRD in `.taskmaster/templates/example_prd.txt` as a template for creating the PRD based on their idea, for use with `parse-prd`.\n\n---\n\n## AI Model Configuration\n\n### 2. Manage Models (`models`)\n*   **MCP Tool:** `models`\n*   **CLI Command:** `task-master models [options]`\n*   **Description:** `View the current AI model configuration or set specific models for different roles (main, research, fallback). Allows setting custom model IDs for Ollama and OpenRouter.`\n*   **Key MCP Parameters/Options:**\n    *   `setMain <model_id>`: `Set the primary model ID for task generation/updates.` (CLI: `--set-main <model_id>`)\n    *   `setResearch <model_id>`: `Set the model ID for research-backed operations.` (CLI: `--set-research <model_id>`)\n    *   `setFallback <model_id>`: `Set the model ID to use if the primary fails.` (CLI: `--set-fallback <model_id>`)\n    *   `ollama <boolean>`: `Indicates the set model ID is a custom Ollama model.` (CLI: `--ollama`)\n    *   `openrouter <boolean>`: `Indicates the set model ID is a custom OpenRouter model.` (CLI: `--openrouter`)\n    *   `listAvailableModels <boolean>`: `If true, lists available models not currently assigned to a role.` (CLI: No direct equivalent; CLI lists available automatically)\n    *   `projectRoot <string>`: `Optional. Absolute path to the project root directory.` (CLI: Determined automatically)\n*   **Key CLI Options:**\n    *   `--set-main <model_id>`: `Set the primary model.`\n    *   `--set-research <model_id>`: `Set the research model.`\n    *   `--set-fallback <model_id>`: `Set the fallback model.`\n    *   `--ollama`: `Specify that the provided model ID is for Ollama (use with --set-*).`\n    *   `--openrouter`: `Specify that the provided model ID is for OpenRouter (use with --set-*). Validates against OpenRouter API.`\n    *   `--bedrock`: `Specify that the provided model ID is for AWS Bedrock (use with --set-*).`\n    *   `--setup`: `Run interactive setup to configure models, including custom Ollama/OpenRouter IDs.`\n*   **Usage (MCP):** Call without set flags to get current config. Use `setMain`, `setResearch`, or `setFallback` with a valid model ID to update the configuration. Use `listAvailableModels: true` to get a list of unassigned models. To set a custom model, provide the model ID and set `ollama: true` or `openrouter: true`.\n*   **Usage (CLI):** Run without flags to view current configuration and available models. Use set flags to update specific roles. Use `--setup` for guided configuration, including custom models. To set a custom model via flags, use `--set-<role>=<model_id>` along with either `--ollama` or `--openrouter`.\n*   **Notes:** Configuration is stored in `.taskmaster/config.json` in the project root. This command/tool modifies that file. Use `listAvailableModels` or `task-master models` to see internally supported models. OpenRouter custom models are validated against their live API. Ollama custom models are not validated live.\n*   **API note:** API keys for selected AI providers (based on their model) need to exist in the mcp.json file to be accessible in MCP context. The API keys must be present in the local .env file for the CLI to be able to read them.\n*   **Model costs:** The costs in supported models are expressed in dollars. An input/output value of 3 is $3.00. A value of 0.8 is $0.80. \n*   **Warning:** DO NOT MANUALLY EDIT THE .taskmaster/config.json FILE. Use the included commands either in the MCP or CLI format as needed. Always prioritize MCP tools when available and use the CLI as a fallback.\n\n---\n\n## Task Listing & Viewing\n\n### 3. Get Tasks (`get_tasks`)\n\n*   **MCP Tool:** `get_tasks`\n*   **CLI Command:** `task-master list [options]`\n*   **Description:** `List your Taskmaster tasks, optionally filtering by status and showing subtasks.`\n*   **Key Parameters/Options:**\n    *   `status`: `Show only Taskmaster tasks matching this status (or multiple statuses, comma-separated), e.g., 'pending' or 'done,in-progress'.` (CLI: `-s, --status <status>`)\n    *   `withSubtasks`: `Include subtasks indented under their parent tasks in the list.` (CLI: `--with-subtasks`)\n    *   `tag`: `Specify which tag context to list tasks from. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Get an overview of the project status, often used at the start of a work session.\n\n### 4. Get Next Task (`next_task`)\n\n*   **MCP Tool:** `next_task`\n*   **CLI Command:** `task-master next [options]`\n*   **Description:** `Ask Taskmaster to show the next available task you can work on, based on status and completed dependencies.`\n*   **Key Parameters/Options:**\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n    *   `tag`: `Specify which tag context to use. Defaults to the current active tag.` (CLI: `--tag <name>`)\n*   **Usage:** Identify what to work on next according to the plan.\n\n### 5. Get Task Details (`get_task`)\n\n*   **MCP Tool:** `get_task`\n*   **CLI Command:** `task-master show [id] [options]`\n*   **Description:** `Display detailed information for one or more specific Taskmaster tasks or subtasks by ID.`\n*   **Key Parameters/Options:**\n    *   `id`: `Required. The ID of the Taskmaster task (e.g., '15'), subtask (e.g., '15.2'), or a comma-separated list of IDs ('1,5,10.2') you want to view.` (CLI: `[id]` positional or `-i, --id <id>`)\n    *   `tag`: `Specify which tag context to get the task(s) from. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Understand the full details for a specific task. When multiple IDs are provided, a summary table is shown.\n*   **CRITICAL INFORMATION** If you need to collect information from multiple tasks, use comma-separated IDs (i.e. 1,2,3) to receive an array of tasks. Do not needlessly get tasks one at a time if you need to get many as that is wasteful.\n\n---\n\n## Task Creation & Modification\n\n### 6. Add Task (`add_task`)\n\n*   **MCP Tool:** `add_task`\n*   **CLI Command:** `task-master add-task [options]`\n*   **Description:** `Add a new task to Taskmaster by describing it; AI will structure it.`\n*   **Key Parameters/Options:**\n    *   `prompt`: `Required. Describe the new task you want Taskmaster to create, e.g., \"Implement user authentication using JWT\".` (CLI: `-p, --prompt <text>`)\n    *   `dependencies`: `Specify the IDs of any Taskmaster tasks that must be completed before this new one can start, e.g., '12,14'.` (CLI: `-d, --dependencies <ids>`)\n    *   `priority`: `Set the priority for the new task: 'high', 'medium', or 'low'. Default is 'medium'.` (CLI: `--priority <priority>`)\n    *   `research`: `Enable Taskmaster to use the research role for potentially more informed task creation.` (CLI: `-r, --research`)\n    *   `tag`: `Specify which tag context to add the task to. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Quickly add newly identified tasks during development.\n*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.\n\n### 7. Add Subtask (`add_subtask`)\n\n*   **MCP Tool:** `add_subtask`\n*   **CLI Command:** `task-master add-subtask [options]`\n*   **Description:** `Add a new subtask to a Taskmaster parent task, or convert an existing task into a subtask.`\n*   **Key Parameters/Options:**\n    *   `id` / `parent`: `Required. The ID of the Taskmaster task that will be the parent.` (MCP: `id`, CLI: `-p, --parent <id>`)\n    *   `taskId`: `Use this if you want to convert an existing top-level Taskmaster task into a subtask of the specified parent.` (CLI: `-i, --task-id <id>`)\n    *   `title`: `Required if not using taskId. The title for the new subtask Taskmaster should create.` (CLI: `-t, --title <title>`)\n    *   `description`: `A brief description for the new subtask.` (CLI: `-d, --description <text>`)\n    *   `details`: `Provide implementation notes or details for the new subtask.` (CLI: `--details <text>`)\n    *   `dependencies`: `Specify IDs of other tasks or subtasks, e.g., '15' or '16.1', that must be done before this new subtask.` (CLI: `--dependencies <ids>`)\n    *   `status`: `Set the initial status for the new subtask. Default is 'pending'.` (CLI: `-s, --status <status>`)\n    *   `generate`: `Enable Taskmaster to regenerate markdown task files after adding the subtask.` (CLI: `--generate`)\n    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Break down tasks manually or reorganize existing tasks.\n\n### 8. Update Tasks (`update`)\n\n*   **MCP Tool:** `update`\n*   **CLI Command:** `task-master update [options]`\n*   **Description:** `Update multiple upcoming tasks in Taskmaster based on new context or changes, starting from a specific task ID.`\n*   **Key Parameters/Options:**\n    *   `from`: `Required. The ID of the first task Taskmaster should update. All tasks with this ID or higher that are not 'done' will be considered.` (CLI: `--from <id>`)\n    *   `prompt`: `Required. Explain the change or new context for Taskmaster to apply to the tasks, e.g., \"We are now using React Query instead of Redux Toolkit for data fetching\".` (CLI: `-p, --prompt <text>`)\n    *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)\n    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Handle significant implementation changes or pivots that affect multiple future tasks. Example CLI: `task-master update --from='18' --prompt='Switching to React Query.\\nNeed to refactor data fetching...'`\n*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.\n\n### 9. Update Task (`update_task`)\n\n*   **MCP Tool:** `update_task`\n*   **CLI Command:** `task-master update-task [options]`\n*   **Description:** `Modify a specific Taskmaster task by ID, incorporating new information or changes. By default, this replaces the existing task details.`\n*   **Key Parameters/Options:**\n    *   `id`: `Required. The specific ID of the Taskmaster task, e.g., '15', you want to update.` (CLI: `-i, --id <id>`)\n    *   `prompt`: `Required. Explain the specific changes or provide the new information Taskmaster should incorporate into this task.` (CLI: `-p, --prompt <text>`)\n    *   `append`: `If true, appends the prompt content to the task's details with a timestamp, rather than replacing them. Behaves like update-subtask.` (CLI: `--append`)\n    *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)\n    *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Refine a specific task based on new understanding. Use `--append` to log progress without creating subtasks.\n*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.\n\n### 10. Update Subtask (`update_subtask`)\n\n*   **MCP Tool:** `update_subtask`\n*   **CLI Command:** `task-master update-subtask [options]`\n*   **Description:** `Append timestamped notes or details to a specific Taskmaster subtask without overwriting existing content. Intended for iterative implementation logging.`\n*   **Key Parameters/Options:**\n    *   `id`: `Required. The ID of the Taskmaster subtask, e.g., '5.2', to update with new information.` (CLI: `-i, --id <id>`)\n    *   `prompt`: `Required. The information, findings, or progress notes to append to the subtask's details with a timestamp.` (CLI: `-p, --prompt <text>`)\n    *   `research`: `Enable Taskmaster to use the research role for more informed updates. Requires appropriate API key.` (CLI: `-r, --research`)\n    *   `tag`: `Specify which tag context the subtask belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Log implementation progress, findings, and discoveries during subtask development. Each update is timestamped and appended to preserve the implementation journey.\n*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.\n\n### 11. Set Task Status (`set_task_status`)\n\n*   **MCP Tool:** `set_task_status`\n*   **CLI Command:** `task-master set-status [options]`\n*   **Description:** `Update the status of one or more Taskmaster tasks or subtasks, e.g., 'pending', 'in-progress', 'done'.`\n*   **Key Parameters/Options:**\n    *   `id`: `Required. The ID(s) of the Taskmaster task(s) or subtask(s), e.g., '15', '15.2', or '16,17.1', to update.` (CLI: `-i, --id <id>`)\n    *   `status`: `Required. The new status to set, e.g., 'done', 'pending', 'in-progress', 'review', 'cancelled'.` (CLI: `-s, --status <status>`)\n    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Mark progress as tasks move through the development cycle.\n\n### 12. Remove Task (`remove_task`)\n\n*   **MCP Tool:** `remove_task`\n*   **CLI Command:** `task-master remove-task [options]`\n*   **Description:** `Permanently remove a task or subtask from the Taskmaster tasks list.`\n*   **Key Parameters/Options:**\n    *   `id`: `Required. The ID of the Taskmaster task, e.g., '5', or subtask, e.g., '5.2', to permanently remove.` (CLI: `-i, --id <id>`)\n    *   `yes`: `Skip the confirmation prompt and immediately delete the task.` (CLI: `-y, --yes`)\n    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Permanently delete tasks or subtasks that are no longer needed in the project.\n*   **Notes:** Use with caution as this operation cannot be undone. Consider using 'blocked', 'cancelled', or 'deferred' status instead if you just want to exclude a task from active planning but keep it for reference. The command automatically cleans up dependency references in other tasks.\n\n---\n\n## Task Structure & Breakdown\n\n### 13. Expand Task (`expand_task`)\n\n*   **MCP Tool:** `expand_task`\n*   **CLI Command:** `task-master expand [options]`\n*   **Description:** `Use Taskmaster's AI to break down a complex task into smaller, manageable subtasks. Appends subtasks by default.`\n*   **Key Parameters/Options:**\n    *   `id`: `The ID of the specific Taskmaster task you want to break down into subtasks.` (CLI: `-i, --id <id>`)\n    *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create. Uses complexity analysis/defaults otherwise.` (CLI: `-n, --num <number>`)\n    *   `research`: `Enable Taskmaster to use the research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)\n    *   `prompt`: `Optional: Provide extra context or specific instructions to Taskmaster for generating the subtasks.` (CLI: `-p, --prompt <text>`)\n    *   `force`: `Optional: If true, clear existing subtasks before generating new ones. Default is false (append).` (CLI: `--force`)\n    *   `tag`: `Specify which tag context the task belongs to. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Generate a detailed implementation plan for a complex task before starting coding. Automatically uses complexity report recommendations if available and `num` is not specified.\n*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.\n\n### 14. Expand All Tasks (`expand_all`)\n\n*   **MCP Tool:** `expand_all`\n*   **CLI Command:** `task-master expand --all [options]` (Note: CLI uses the `expand` command with the `--all` flag)\n*   **Description:** `Tell Taskmaster to automatically expand all eligible pending/in-progress tasks based on complexity analysis or defaults. Appends subtasks by default.`\n*   **Key Parameters/Options:**\n    *   `num`: `Optional: Suggests how many subtasks Taskmaster should aim to create per task.` (CLI: `-n, --num <number>`)\n    *   `research`: `Enable research role for more informed subtask generation. Requires appropriate API key.` (CLI: `-r, --research`)\n    *   `prompt`: `Optional: Provide extra context for Taskmaster to apply generally during expansion.` (CLI: `-p, --prompt <text>`)\n    *   `force`: `Optional: If true, clear existing subtasks before generating new ones for each eligible task. Default is false (append).` (CLI: `--force`)\n    *   `tag`: `Specify which tag context to expand. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Useful after initial task generation or complexity analysis to break down multiple tasks at once.\n*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.\n\n### 15. Clear Subtasks (`clear_subtasks`)\n\n*   **MCP Tool:** `clear_subtasks`\n*   **CLI Command:** `task-master clear-subtasks [options]`\n*   **Description:** `Remove all subtasks from one or more specified Taskmaster parent tasks.`\n*   **Key Parameters/Options:**\n    *   `id`: `The ID(s) of the Taskmaster parent task(s) whose subtasks you want to remove, e.g., '15' or '16,18'. Required unless using 'all'.` (CLI: `-i, --id <ids>`)\n    *   `all`: `Tell Taskmaster to remove subtasks from all parent tasks.` (CLI: `--all`)\n    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Used before regenerating subtasks with `expand_task` if the previous breakdown needs replacement.\n\n### 16. Remove Subtask (`remove_subtask`)\n\n*   **MCP Tool:** `remove_subtask`\n*   **CLI Command:** `task-master remove-subtask [options]`\n*   **Description:** `Remove a subtask from its Taskmaster parent, optionally converting it into a standalone task.`\n*   **Key Parameters/Options:**\n    *   `id`: `Required. The ID(s) of the Taskmaster subtask(s) to remove, e.g., '15.2' or '16.1,16.3'.` (CLI: `-i, --id <id>`)\n    *   `convert`: `If used, Taskmaster will turn the subtask into a regular top-level task instead of deleting it.` (CLI: `-c, --convert`)\n    *   `generate`: `Enable Taskmaster to regenerate markdown task files after removing the subtask.` (CLI: `--generate`)\n    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Delete unnecessary subtasks or promote a subtask to a top-level task.\n\n### 17. Move Task (`move_task`)\n\n*   **MCP Tool:** `move_task`\n*   **CLI Command:** `task-master move [options]`\n*   **Description:** `Move a task or subtask to a new position within the task hierarchy.`\n*   **Key Parameters/Options:**\n    *   `from`: `Required. ID of the task/subtask to move (e.g., \"5\" or \"5.2\"). Can be comma-separated for multiple tasks.` (CLI: `--from <id>`)\n    *   `to`: `Required. ID of the destination (e.g., \"7\" or \"7.3\"). Must match the number of source IDs if comma-separated.` (CLI: `--to <id>`)\n    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Reorganize tasks by moving them within the hierarchy. Supports various scenarios like:\n    *   Moving a task to become a subtask\n    *   Moving a subtask to become a standalone task\n    *   Moving a subtask to a different parent\n    *   Reordering subtasks within the same parent\n    *   Moving a task to a new, non-existent ID (automatically creates placeholders)\n    *   Moving multiple tasks at once with comma-separated IDs\n*   **Validation Features:**\n    *   Allows moving tasks to non-existent destination IDs (creates placeholder tasks)\n    *   Prevents moving to existing task IDs that already have content (to avoid overwriting)\n    *   Validates that source tasks exist before attempting to move them\n    *   Maintains proper parent-child relationships\n*   **Example CLI:** `task-master move --from=5.2 --to=7.3` to move subtask 5.2 to become subtask 7.3.\n*   **Example Multi-Move:** `task-master move --from=10,11,12 --to=16,17,18` to move multiple tasks to new positions.\n*   **Common Use:** Resolving merge conflicts in tasks.json when multiple team members create tasks on different branches.\n\n---\n\n## Dependency Management\n\n### 18. Add Dependency (`add_dependency`)\n\n*   **MCP Tool:** `add_dependency`\n*   **CLI Command:** `task-master add-dependency [options]`\n*   **Description:** `Define a dependency in Taskmaster, making one task a prerequisite for another.`\n*   **Key Parameters/Options:**\n    *   `id`: `Required. The ID of the Taskmaster task that will depend on another.` (CLI: `-i, --id <id>`)\n    *   `dependsOn`: `Required. The ID of the Taskmaster task that must be completed first, the prerequisite.` (CLI: `-d, --depends-on <id>`)\n    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <path>`)\n*   **Usage:** Establish the correct order of execution between tasks.\n\n### 19. Remove Dependency (`remove_dependency`)\n\n*   **MCP Tool:** `remove_dependency`\n*   **CLI Command:** `task-master remove-dependency [options]`\n*   **Description:** `Remove a dependency relationship between two Taskmaster tasks.`\n*   **Key Parameters/Options:**\n    *   `id`: `Required. The ID of the Taskmaster task you want to remove a prerequisite from.` (CLI: `-i, --id <id>`)\n    *   `dependsOn`: `Required. The ID of the Taskmaster task that should no longer be a prerequisite.` (CLI: `-d, --depends-on <id>`)\n    *   `tag`: `Specify which tag context to operate on. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Update task relationships when the order of execution changes.\n\n### 20. Validate Dependencies (`validate_dependencies`)\n\n*   **MCP Tool:** `validate_dependencies`\n*   **CLI Command:** `task-master validate-dependencies [options]`\n*   **Description:** `Check your Taskmaster tasks for dependency issues (like circular references or links to non-existent tasks) without making changes.`\n*   **Key Parameters/Options:**\n    *   `tag`: `Specify which tag context to validate. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Audit the integrity of your task dependencies.\n\n### 21. Fix Dependencies (`fix_dependencies`)\n\n*   **MCP Tool:** `fix_dependencies`\n*   **CLI Command:** `task-master fix-dependencies [options]`\n*   **Description:** `Automatically fix dependency issues (like circular references or links to non-existent tasks) in your Taskmaster tasks.`\n*   **Key Parameters/Options:**\n    *   `tag`: `Specify which tag context to fix dependencies in. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Clean up dependency errors automatically.\n\n---\n\n## Analysis & Reporting\n\n### 22. Analyze Project Complexity (`analyze_project_complexity`)\n\n*   **MCP Tool:** `analyze_project_complexity`\n*   **CLI Command:** `task-master analyze-complexity [options]`\n*   **Description:** `Have Taskmaster analyze your tasks to determine their complexity and suggest which ones need to be broken down further.`\n*   **Key Parameters/Options:**\n    *   `output`: `Where to save the complexity analysis report. Default is '.taskmaster/reports/task-complexity-report.json' (or '..._tagname.json' if a tag is used).` (CLI: `-o, --output <file>`)\n    *   `threshold`: `The minimum complexity score (1-10) that should trigger a recommendation to expand a task.` (CLI: `-t, --threshold <number>`)\n    *   `research`: `Enable research role for more accurate complexity analysis. Requires appropriate API key.` (CLI: `-r, --research`)\n    *   `tag`: `Specify which tag context to analyze. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Used before breaking down tasks to identify which ones need the most attention.\n*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. Please inform users to hang tight while the operation is in progress.\n\n### 23. View Complexity Report (`complexity_report`)\n\n*   **MCP Tool:** `complexity_report`\n*   **CLI Command:** `task-master complexity-report [options]`\n*   **Description:** `Display the task complexity analysis report in a readable format.`\n*   **Key Parameters/Options:**\n    *   `tag`: `Specify which tag context to show the report for. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to the complexity report (default: '.taskmaster/reports/task-complexity-report.json').` (CLI: `-f, --file <file>`)\n*   **Usage:** Review and understand the complexity analysis results after running analyze-complexity.\n\n---\n\n## File Management\n\n### 24. Generate Task Files (`generate`)\n\n*   **MCP Tool:** `generate`\n*   **CLI Command:** `task-master generate [options]`\n*   **Description:** `Create or update individual Markdown files for each task based on your tasks.json.`\n*   **Key Parameters/Options:**\n    *   `output`: `The directory where Taskmaster should save the task files (default: in a 'tasks' directory).` (CLI: `-o, --output <directory>`)\n    *   `tag`: `Specify which tag context to generate files for. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n*   **Usage:** Run this after making changes to tasks.json to keep individual task files up to date. This command is now manual and no longer runs automatically.\n\n---\n\n## AI-Powered Research\n\n### 25. Research (`research`)\n\n*   **MCP Tool:** `research`\n*   **CLI Command:** `task-master research [options]`\n*   **Description:** `Perform AI-powered research queries with project context to get fresh, up-to-date information beyond the AI's knowledge cutoff.`\n*   **Key Parameters/Options:**\n    *   `query`: `Required. Research query/prompt (e.g., \"What are the latest best practices for React Query v5?\").` (CLI: `[query]` positional or `-q, --query <text>`)\n    *   `taskIds`: `Comma-separated list of task/subtask IDs from the current tag context (e.g., \"15,16.2,17\").` (CLI: `-i, --id <ids>`)\n    *   `filePaths`: `Comma-separated list of file paths for context (e.g., \"src/api.js,docs/readme.md\").` (CLI: `-f, --files <paths>`)\n    *   `customContext`: `Additional custom context text to include in the research.` (CLI: `-c, --context <text>`)\n    *   `includeProjectTree`: `Include project file tree structure in context (default: false).` (CLI: `--tree`)\n    *   `detailLevel`: `Detail level for the research response: 'low', 'medium', 'high' (default: medium).` (CLI: `--detail <level>`)\n    *   `saveTo`: `Task or subtask ID (e.g., \"15\", \"15.2\") to automatically save the research conversation to.` (CLI: `--save-to <id>`)\n    *   `saveFile`: `If true, saves the research conversation to a markdown file in '.taskmaster/docs/research/'.` (CLI: `--save-file`)\n    *   `noFollowup`: `Disables the interactive follow-up question menu in the CLI.` (CLI: `--no-followup`)\n    *   `tag`: `Specify which tag context to use for task-based context gathering. Defaults to the current active tag.` (CLI: `--tag <name>`)\n    *   `projectRoot`: `The directory of the project. Must be an absolute path.` (CLI: Determined automatically)\n*   **Usage:** **This is a POWERFUL tool that agents should use FREQUENTLY** to:\n    *   Get fresh information beyond knowledge cutoff dates\n    *   Research latest best practices, library updates, security patches\n    *   Find implementation examples for specific technologies\n    *   Validate approaches against current industry standards\n    *   Get contextual advice based on project files and tasks\n*   **When to Consider Using Research:**\n    *   **Before implementing any task** - Research current best practices\n    *   **When encountering new technologies** - Get up-to-date implementation guidance (libraries, apis, etc)\n    *   **For security-related tasks** - Find latest security recommendations\n    *   **When updating dependencies** - Research breaking changes and migration guides\n    *   **For performance optimization** - Get current performance best practices\n    *   **When debugging complex issues** - Research known solutions and workarounds\n*   **Research + Action Pattern:**\n    *   Use `research` to gather fresh information\n    *   Use `update_subtask` to commit findings with timestamps\n    *   Use `update_task` to incorporate research into task details\n    *   Use `add_task` with research flag for informed task creation\n*   **Important:** This MCP tool makes AI calls and can take up to a minute to complete. The research provides FRESH data beyond the AI's training cutoff, making it invaluable for current best practices and recent developments.\n\n---\n\n## Tag Management\n\nThis new suite of commands allows you to manage different task contexts (tags).\n\n### 26. List Tags (`tags`)\n\n*   **MCP Tool:** `list_tags`\n*   **CLI Command:** `task-master tags [options]`\n*   **Description:** `List all available tags with task counts, completion status, and other metadata.`\n*   **Key Parameters/Options:**\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n    *   `--show-metadata`: `Include detailed metadata in the output (e.g., creation date, description).` (CLI: `--show-metadata`)\n\n### 27. Add Tag (`add_tag`)\n\n*   **MCP Tool:** `add_tag`\n*   **CLI Command:** `task-master add-tag <tagName> [options]`\n*   **Description:** `Create a new, empty tag context, or copy tasks from another tag.`\n*   **Key Parameters/Options:**\n    *   `tagName`: `Name of the new tag to create (alphanumeric, hyphens, underscores).` (CLI: `<tagName>` positional)\n    *   `--from-branch`: `Creates a tag with a name derived from the current git branch, ignoring the <tagName> argument.` (CLI: `--from-branch`)\n    *   `--copy-from-current`: `Copy tasks from the currently active tag to the new tag.` (CLI: `--copy-from-current`)\n    *   `--copy-from <tag>`: `Copy tasks from a specific source tag to the new tag.` (CLI: `--copy-from <tag>`)\n    *   `--description <text>`: `Provide an optional description for the new tag.` (CLI: `-d, --description <text>`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n\n### 28. Delete Tag (`delete_tag`)\n\n*   **MCP Tool:** `delete_tag`\n*   **CLI Command:** `task-master delete-tag <tagName> [options]`\n*   **Description:** `Permanently delete a tag and all of its associated tasks.`\n*   **Key Parameters/Options:**\n    *   `tagName`: `Name of the tag to delete.` (CLI: `<tagName>` positional)\n    *   `--yes`: `Skip the confirmation prompt.` (CLI: `-y, --yes`)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n\n### 29. Use Tag (`use_tag`)\n\n*   **MCP Tool:** `use_tag`\n*   **CLI Command:** `task-master use-tag <tagName>`\n*   **Description:** `Switch your active task context to a different tag.`\n*   **Key Parameters/Options:**\n    *   `tagName`: `Name of the tag to switch to.` (CLI: `<tagName>` positional)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n\n### 30. Rename Tag (`rename_tag`)\n\n*   **MCP Tool:** `rename_tag`\n*   **CLI Command:** `task-master rename-tag <oldName> <newName>`\n*   **Description:** `Rename an existing tag.`\n*   **Key Parameters/Options:**\n    *   `oldName`: `The current name of the tag.` (CLI: `<oldName>` positional)\n    *   `newName`: `The new name for the tag.` (CLI: `<newName>` positional)\n    *   `file`: `Path to your Taskmaster 'tasks.json' file. Default relies on auto-detection.` (CLI: `-f, --file <file>`)\n\n### 31. Copy Tag (`copy_tag`)\n\n*   **MCP Tool:** `copy_tag`\n*   **CLI Command:** `task-master copy-tag <sourceName> <targetName> [options]`\n*   **Description:** `Copy an entire tag context, including all its tasks and metadata, to a new tag.`\n*   **Key Parameters/Options:**\n    *   `sourceName`: `Name of the tag to copy from.` (CLI: `<sourceName>` positional)\n    *   `targetName`: `Name of the new tag to create.` (CLI: `<targetName>` positional)\n    *   `--description <text>`: `Optional description for the new tag.` (CLI: `-d, --description <text>`)\n\n---\n\n## Miscellaneous\n\n### 32. Sync Readme (`sync-readme`) -- experimental\n\n*   **MCP Tool:** N/A\n*   **CLI Command:** `task-master sync-readme [options]`\n*   **Description:** `Exports your task list to your project's README.md file, useful for showcasing progress.`\n*   **Key Parameters/Options:**\n    *   `status`: `Filter tasks by status (e.g., 'pending', 'done').` (CLI: `-s, --status <status>`)\n    *   `withSubtasks`: `Include subtasks in the export.` (CLI: `--with-subtasks`)\n    *   `tag`: `Specify which tag context to export from. Defaults to the current active tag.` (CLI: `--tag <name>`)\n\n---\n\n## Environment Variables Configuration (Updated)\n\nTaskmaster primarily uses the **`.taskmaster/config.json`** file (in project root) for configuration (models, parameters, logging level, etc.), managed via `task-master models --setup`.\n\nEnvironment variables are used **only** for sensitive API keys related to AI providers and specific overrides like the Ollama base URL:\n\n*   **API Keys (Required for corresponding provider):**\n    *   `ANTHROPIC_API_KEY`\n    *   `PERPLEXITY_API_KEY`\n    *   `OPENAI_API_KEY`\n    *   `GOOGLE_API_KEY`\n    *   `MISTRAL_API_KEY`\n    *   `AZURE_OPENAI_API_KEY` (Requires `AZURE_OPENAI_ENDPOINT` too)\n    *   `OPENROUTER_API_KEY`\n    *   `XAI_API_KEY`\n    *   `OLLAMA_API_KEY` (Requires `OLLAMA_BASE_URL` too)\n*   **Endpoints (Optional/Provider Specific inside .taskmaster/config.json):**\n    *   `AZURE_OPENAI_ENDPOINT`\n    *   `OLLAMA_BASE_URL` (Default: `http://localhost:11434/api`)\n\n**Set API keys** in your **`.env`** file in the project root (for CLI use) or within the `env` section of your **`.windsurf/mcp.json`** file (for MCP/Windsurf integration). All other settings (model choice, max tokens, temperature, log level, custom endpoints) are managed in `.taskmaster/config.json` via `task-master models` command or `models` MCP tool.\n\n---\n\nFor details on how these commands fit into the development process, see the [dev_workflow.md](.windsurf/rules/dev_workflow.md).",
        "namespace": "xtasker"
    },
    {
        "key": "ui-components.md",
        "value": "---\ntrigger: model_decision\ndescription: Describes where the ui components built on top with Shadcn UI exist, how they are customized, and Wasp specific rules concerning how new ShadCN UI components should be installed\n---\n\nOnly ShadCN UI version 2.3.0 should be used with Wasp at the moment. Due to dependency conflicts Wasp cannot be used with Tailwindcss v4, which the newer version of Shadcn depends on. \n\nShadcn has already been setup with this project template, so there is no need to install it. All the ShadCN specific components exist in [src/components/ui](../../src/components/ui/)\n\n## Adding a new ShadCN component\n### 1. Add a new component\n\n```bash\nnpx shadcn@2.3.0 add button\n```\n\n### 2. Adjust the `utils` import in `button.tsx` (for each component you add)\n\nThere will be a brand new `button.tsx` file in `src/components/ui`. We need to fix some import issues:\n```diff\nimport * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\n-import { cn } from \"s/lib/utils\"\n+import { cn } from \"../../lib/utils\"\n```\n\n### 3. Use the `Button` component\nNow you are ready to use the `Button` component. That's it!\n```jsx\nimport './Main.css'\n\nimport { Button } from './components/ui/button'\n\nexport const MainPage = () => {\n  return (\n    <div className=\"container\">\n      <Button>This works</Button>\n    </div>\n  )\n}",
        "namespace": "xtasker"
    },
    {
        "key": "wasp-overview.md",
        "value": "---\ntrigger: always_on\n---\n\n# 1. Wasp Overview and Core Concepts\n\nThis document covers the fundamental concepts of the Wasp framework and the basic project structure.\n\n## Background Information\n\n### What is Wasp\n\n- Wasp (Web Application SPecification language) is a declarative, statically typed, domain-specific language (DSL) for building modern, full-stack web applications.\n- Unlike traditional frameworks that are sets of libraries, Wasp is a simple programming language that understands web app concepts and generates code for you.\n- Wasp integrates with React (frontend), Node.js (backend), and Prisma (database ORM) to create full-stack web applications with minimal boilerplate.\n- The Wasp compiler reads your declarative configuration in the config file ([main.wasp](mdc:main.wasp) or `main.wasp.ts`) and generates all the necessary code for a working web application.\n- For the most up-to-date and comprehensive information, always refer to the Wasp Documenation (linked below).\n\n### Wasp Project Structure\n\n- A Wasp project consists of a [main.wasp](mdc:main.wasp) (or `main.wasp.ts`) file in the root directory that defines the app's configuration.\n- The [schema.prisma](mdc:schema.prisma) file in the root directory defines your database models (\"entities\").\n- Your custom code lives in the `src/` directory (e.g. `src/{featureName}`), which contains client-side and server-side code.\n- Wasp generates additional code that connects everything together when you run your app.\n\n### The Wasp Config File\n\n- The main Wasp Config File ([main.wasp](mdc:main.wasp) or `main.wasp.ts`) is the central configuration file that defines your application structure.\n- It contains declarations for app settings, pages, routes, authentication, database entities, and operations (queries and actions).\n- Example structure:\n  ```main.wasp\n  app myApp {\n    wasp: {\n      version: \"^0.16.0\" // Check @main.wasp for the actual version\n    },\n    title: \"My App\",\n  }\n\n  route HomeRoute { path: \"/\", to: HomePage }\n  page HomePage {\n    component: import { HomePage } from \"@src/client/pages/HomePage.tsx\" // Example import path\n  }\n\n  // Operations are defined here, see 3-database-operations.mdc\n  query getTasks {\n    fn: import { getTasks } from \"@src/server/queries.js\",\n    entities: [Task]\n  }\n  ``` \n\n### Wasp Documentation \nMore info on all of Wasp's features can be found in the Wasp documentation (NOTE: You can follow these links, instruct the user to add these docs to Cursor's settings, or have the user manually include them in the chat context):\n- Links to Wasp documentation sections (LLM-optimized): https://wasp.sh/llms.txt\n- Complete Wasp documentation (LLM-optimized): https://wasp.sh/llms-full.txt\n- Wasp Docs homepage (human-readable): https://wasp.sh/docs",
        "namespace": "xtasker"
    },
    {
        "key": "windsurf_rules.md",
        "value": "---\ndescription: Guidelines for creating and maintaining Windsurf rules to ensure consistency and effectiveness.\nglobs: .windsurf/rules/*.md\nalwaysApply: true\n---\n\n- **Required Rule Structure:**\n  ```markdown\n  ---\n  description: Clear, one-line description of what the rule enforces\n  globs: path/to/files/*.ext, other/path/**/*\n  alwaysApply: boolean\n  ---\n\n  - **Main Points in Bold**\n    - Sub-points with details\n    - Examples and explanations\n  ```\n\n- **File References:**\n  - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files\n  - Example: [prisma.md](.windsurf/rules/prisma.md) for rule references\n  - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references\n\n- **Code Examples:**\n  - Use language-specific code blocks\n  ```typescript\n  // ✅ DO: Show good examples\n  const goodExample = true;\n  \n  // ❌ DON'T: Show anti-patterns\n  const badExample = false;\n  ```\n\n- **Rule Content Guidelines:**\n  - Start with high-level overview\n  - Include specific, actionable requirements\n  - Show examples of correct implementation\n  - Reference existing code when possible\n  - Keep rules DRY by referencing other rules\n\n- **Rule Maintenance:**\n  - Update rules when new patterns emerge\n  - Add examples from actual codebase\n  - Remove outdated patterns\n  - Cross-reference related rules\n\n- **Best Practices:**\n  - Use bullet points for clarity\n  - Keep descriptions concise\n  - Include both DO and DON'T examples\n  - Reference actual code over theoretical examples\n  - Use consistent formatting across rules ",
        "namespace": "xtasker"
    },
    {
        "key": "x.md",
        "value": "---\ntrigger: always_on\n---\n\nmake it a habit to crosschekc the documentation and rules beofre startin a task, you mst strungly type and no implicit 'any', always check the wasp documentation before u make an implementation vis the context7 mcp ",
        "namespace": "xtasker"
    }
]}