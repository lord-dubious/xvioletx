{
    "xtasker": [
      {
        "key": "opensass_full",
        "value": "# Introduction\n\n## Welcome to your new SaaS App!\n\nYou've decided to build a SaaS app with this template. Great choice! \n\nThis template is:\n\n1. fully open-source\n2. completely free to use and distribute\n3. comes with a ton of features out of the box\n4. community-driven and constantly improving!\n\nCheck it out in action here: [OpenSaaS.sh](https://opensaas.sh)  \nCheck out the Code: [Open SaaS GitHub Repo](https://github.com/wasp-lang/open-saas)\n\n:::tip[FREE & OPEN-SOURCE!? ]\nThat's right. Use this template however you like. No strings attached.\n\nIf you find this template useful, consider giving us [a star on GitHub](https://github.com/wasp-lang/wasp). It helps us to keep bringing you open-source software just like this!\n:::\n\n## What's inside?\n\nThe template itself is built on top of some very powerful tools and frameworks, including:\n  -  [Wasp](https://wasp.sh) - a full-stack React, NodeJS, Prisma framework with superpowers\n  -  [Astro](https://starlight.astro.build/) - Astro's lightweight \"Starlight\" template for documentation and blog\n  -  [Stripe](https://stripe.com) or [Lemon Squeezy](https://lemonsqueezy.com/) - for products and payments\n  -  [Plausible](https://plausible.io) or [Google](https://analytics.google.com/) Analytics\n  -  [OpenAI](https://openai.com) - OpenAI API integrated into the app or [Replicate](https://replicate.com/) (coming soon )\n  -  [AWS S3](https://aws.amazon.com/s3/) - for file uploads\n  -  [SendGrid](https://sendgrid.com), [MailGun](https://mailgun.com), or SMTP - for email sending\n  -  [TailwindCSS](https://tailwindcss.com) - for styling\n  -  [TailAdmin](https://tailadmin.com/) - admin dashboard & components for TailwindCSS\n\nBecause we're using Wasp as the full-stack framework, we can leverage a lot of its features to build our SaaS in record time, including:\n  -  [Full-stack Authentication](https://wasp.sh/docs/auth/overview) - Email verified + social Auth in a few lines of code.\n  -  [End-to-end Type Safety](https://wasp.sh/docs/data-model/operations/overview) - Type your backend functions and get inferred types on the front-end automatically, without the need to install or configure any third-party libraries. Oh, and type-safe Links, too!\n  -  [Jobs](https://wasp.sh/docs/advanced/jobs) - Run cron jobs in the background or set up queues simply by defining a function in the config file.\n  -  [One-command Deploy](https://wasp.sh/docs/advanced/deployment/overview) - Easily deploy via the CLI to [Fly.io](https://fly.io), or to other providers like [Railway](https://railway.app) and [Netlify](https://netlify.com).\n\nYou also get access to Wasp's diverse, helpful community if you get stuck or need help.\n  -  [Wasp Discord](https://discord.gg/rzdnErX)\n\n:::caution[\"Work In Progress\"]\nWe've tried to get as many of the core features of a SaaS app into this template as possible, but there still might be some missing features or functionality.\n\nWe could always use some help tying up loose ends, so consider [contributing](https://github.com/wasp-lang/open-saas/blob/main/CONTRIBUTING.md)!\n:::\n\nIn the next sections, we'll get our SaaS app started and tour its features. Let's get started!\n\n---\n\n# Getting Started\n\nThis guide will help you get your new SaaS app up and running.\n\nIf you prefer video tutorials, you can watch this walkthrough below which will guide you through most of the setup (installation, authentication, payments, etc.). If you get stuck at any point, you can refer back to these docs for more information.\n\n<VideoPlayer src=\"https://youtu.be/lFGtwbwt66k\" lgWidth=\"100%\" />\n\n## Install Wasp\n\n### Pre-requisites\n\nYou must have Node.js (and NPM) installed on your machine and available in `PATH` to use Wasp.\nYour version of Node.js must be >= 22.12.\n\nTo switch easily between Node.js versions, we recommend using [nvm](https://github.com/nvm-sh/nvm).\n\n:::note[Installing and using nvm]\n<details aria-label=\"Installing and using nvm\">\n  <summary aria-label=\"Need help with nvm?\">\n    Need help with nvm?\n  </summary>\n  <div>\n    Install nvm via your OS package manager (`apt`, `pacman`, `homebrew`, ...) or via the [nvm](https://github.com/nvm-sh/nvm#install--update-script) install script.\n\n    Then, install a version of Node.js that you need:\n\n    ```shell\n    nvm install 20\n    ```\n\n    Finally, whenever you need to ensure a specific version of Node.js is used, run:\n\n    ```shell\n    nvm use 20\n    ```\n\n    to set the Node.js version for the current shell session.\n\n    You can run\n\n    ```shell\n    node -v\n    ```\n\n    to check the version of Node.js currently being used in this shell session.\n\n    Check NVM repo for more details: [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm).\n  </div>\n</details>\n:::\n\n### Linux and macOS\n\nOpen your terminal and run:\n\n```shell\ncurl -sSL https://get.wasp.sh/installer.sh | sh\n```\n\n:::caution[Bad CPU type in executable]\n<details aria-label=\"Bad CPU type in executable\">\n  <summary aria-label=\"Are you getting this error on a Mac (Apple Silicon)?\">\n    Are you getting this error on a Mac (Apple Silicon)?\n  </summary>\nGiven that the wasp binary is built for x86 and not for arm64 (Apple Silicon), you'll need to install <a href='https://support.apple.com/en-us/HT211861' alt='Rosetta on your Mac'>Rosetta on your Mac</a> if you are using a Mac with Mx (M1, M2, ...). Rosetta is a translation process that enables users to run applications designed for x86 on arm64 (Apple Silicon). To install Rosetta, run the following command in your terminal\n\n```bash\nsoftwareupdate --install-rosetta\n```\nOnce Rosetta is installed, you should be able to run Wasp without any issues.\n\n</details>\n:::\n\n### Windows\n\nIn order to use Wasp on Windows, you need to install WSL2 (Windows Subsystem for Linux) and a Linux distribution of your choice. We recommend using Ubuntu.\n\n**You can refer to this [article](https://wasp.sh/blog/2023/11/21/guide-windows-development-wasp-wsl) for a step by step guide to using Wasp in the WSL environment.** If you need further help, reach out to us on [Discord](https://discord.gg/rzdnErX).\n\n:::caution[WSL2 Docker post installation steps]\n\n<details>\n  <summary>\n      Complete those steps to ensure that PostgreSQL and Docker work correctly with Wasp in WSL2.\n  </summary>\nIt is recommended to complete those post-install steps in WSL, based on the official <a href=\"https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user\">Docker</a> guide. These work if you are experiencing an error similar to <a href=\"https://github.com/wasp-lang/open-saas/issues/347\">this</a> one.\n\nFirst, run\n\n```bash\nsudo groupadd docker\n```\n\ncommand to create the `docker` group in case it doesn't exist. If it exists, don't worry, just continue with next steps. After that, add your current user to docker group by running\n\n```bash\nsudo usermod -aG docker $USER\n```\n\nwhere $USER is your username. After that, log out and log back in to apply the changes. Finally, run\n\n```bash\nsu -s $USER\n```\n\n</details>\n:::\n\nOnce in WSL2, run the following command in your **WSL2 environment**:\n```sh\ncurl -sSL https://get.wasp.sh/installer.sh | sh\n```\n\n:::caution[WSL2 and file system issues]\n<details aria-label=\"Are you getting file system issues using WSL2?\">\n  <summary aria-label=\"Are you getting file system issues using WSL2?\">\n    Are you getting file system issues using WSL2?\n  </summary>\nIf you are using WSL2, make sure that your Wasp project is not on the Windows file system, <b>but instead on the Linux file system</b>. Otherwise, Wasp won't be able to detect file changes, due to this <a href='https://github.com/microsoft/WSL/issues/4739'>issue in WSL2</a>.\n</details>\n:::\n\n### Finalize Installation\n\nRun the following command to verify that Wasp was installed correctly:\n\n```shell\nwasp version\n```\n\nAlso be sure to install the Wasp VSCode extension to get the best DX, e.g. syntax highlighting, code scaffolding, autocomplete, etc.\n\n:::tip[Installing the Wasp VSCode Extension]\nYou can install the Wasp VSCode extension by searching for \"Wasp\" in the Extensions tab in VSCode, or by visiting the [Wasp VSCode Extension](https://marketplace.visualstudio.com/items?itemName=wasp-lang.wasp) homepage\n:::\n\n## Setting up your SaaS app\n\n### Cloning the OpenSaaS template\n\nFrom the directory where you'd like to create your new project run:\n```sh\nwasp new\n```\n\nThen select option `[3] saas` from the list of templates after entering the name of your project.\n\nThis will clone a **clean copy of the Open SaaS template** into a new directory! \n\n### Start your DB\n\nBefore you start your app, you need to have a Postgres Database connected and running. With Wasp, that's super easy!\n\nFirst, make sure you have **Docker installed and running**. If not, download and install it [here](https://www.docker.com/products/docker-desktop/)\n\nWith Docker running, open a new terminal window/tab and position yourself in the `app` directory:\n\n```sh\ncd app\n```\n\nThen run:\n\n```sh\nwasp start db\n```\n\nThis will start and connect your app to a Postgres database for you. No need to do anything else!  Just make sure to leave this terminal window open in the background while developing. Once you terminate the process, your DB will no longer be available to your app.\n\nNow let's create our very first database migration, to ensure the database has a correct schema. Open a new terminal tab/window and run the following command:\n\n```sh\nwasp db migrate-dev\n```\n\nThis might take a bit since this is the first time you are running it and it needs to install all the\ndependencies for your Wasp project.\n\nIn the future, you will also want to run `wasp db migrate-dev` whenever you make changes to your Prisma schema (Entities),\nto apply those schema changes to the database.\n\nAdditionally, if you want to see or manage your DB via Prisma's DB Studio GUI, run:\n\n```sh\nwasp db studio\n```\n\n### Start your app\n\nAt this point, you should be positioned in the `app/` directory and have the database running in another terminal session.\n\nNext, copy the `.env.server.example` file to `.env.server`.\n\n```sh\ncp .env.server.example .env.server\n```\n\n`.env.server` is where API keys for services like payments, email sender, and similar go, and this is where you will want to put them in later.\nFor now, you can leave it as it is (dummy API keys), this will be enough to run the app.\n\nThen run:\n\n```sh\nwasp start\n```\n\nThis will install all the dependencies and start the app (client and server) for you :)!\n\nIf the app doesn't open automatically in your browser, you can open it manually by visiting `http://localhost:3000` in your browser.\n\nAt this point, you should have:\n - your database running in one terminal session, likely on port `5432`.\n - your app running in another terminal session, the client likely on port `3000`, and the server likely on port `3001`.\n\n#### Run Blog and Docs\n\nThis SaaS app comes with a docs and blog section built with the [Starlight template on top of the Astro](https://starlight.astro.build) framework. You can use this as a starting point for your own blog and documentation, if necessary.\n\nIf you do not need this, you can simply delete the `blog` folder from the root of the project.\n\nIf you want to run the Starlight docs and blog, first navigate to the `blog` folder:\n\n```sh\ncd ../blog\n```\n\nThen run:\n\n```sh\nnpm install\n```\n\nThen start the development server:\n\n```sh\nnpm run dev\n```\n\nCheck the instructions in the terminal for the link to open the blog, it will typically be `https://localhost:4321/`.\n\n## What's next?\n\nAwesome! We have our new app ready and we know how to run both it and the blog/docs! Now, in the next section, we'll give you a quick \"guided tour\" of the different parts of the app we created and understand how it works.\n\n:::tip[Star our Repo on GitHub! ]\nWe've packed in a ton of features and love into this SaaS starter, and offer it all to you for free!\n\nIf you're finding this template and its guides useful, consider giving us [a star on GitHub](https://github.com/wasp-lang/wasp)\n:::\n\n---\n\n# Guided Tour\n\nAwesome, you now have your very own SaaS app up and running! But, first, here are some important things you need to know about your app in its current state:\n\n1. When signing up with a new user, you will get a message to check your email for a verification link. But, in development, these emails are simply written to your terminal. **So, to continue with the registration process, check your server logs after sign up**! \n```sh title=\"server logs\"\n[ Server ] \n[ Server ]  Dummy email sender   \n[ Server ] \n[ Server ] From:    Open SaaS App <me@example.com>\n[ Server ] To:      vinny@wasp.sh\n[ Server ] Subject: Verify your email\n[ Server ]  Text \n[ Server ] Click the link below to verify your email: http://localhost:3000/email-verification?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InZpbm55QHdhc3Auc2giLCJleHAiOjE3MTg5NjUyNTB9.PkRGrmuDPuYFXkTprf7QpAye0e_O9a70xbER6LfxGJw\n[ Server ]  HTML \n[ Server ] <p>Click the link below to verify your email</p>\n[ Server ] <a href=\"http://localhost:3000/email-verification?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InZpbm55QHdhc3Auc2giLCJleHAiOjE3MTg5NjUyNTB9.PkRGrmuDPuYFXkTprf7QpAye0e_O9a70xbER6LfxGJw\">Verify email</a> \n[ Server ] \n```\n2. Your app is still missing some key configurations (e.g. API keys for Payment Processors, OpenAI, AWS S3, Auth, Analytics). These services won't work at the moment, but don't fear, because **we've provided detailed guides in these docs to help you set up all the services in this template**.\n3. If you want to get a feel for what your SaaS could look like when finished, **check out [OpenSaaS.sh](https://opensaas.sh) in your browser. It was built using this template!** So make sure to log in, play around with the demo app, make a test payment, and check out the admin dashboard.\n\nIn the sections below, we will take a short guide through the codebase and the app's main features. Then at the end of this tour, we also prepared a checklist of likely changes you will want to make to the app to make it your own. \n\nWe're looking forward to seeing what you build!\n\n## Getting acquainted with the codebase\nNow that you've gotten a first look at the app, let's dive into the codebase.\n\nAt the root of our project, you will see three folders:\n```sh\n.\n app\n blog\n e2e-tests\n```\n\n`app` contains the Wasp project files, which is your full-stack React + NodeJS + Prisma app along with a Wasp config file, `main.wasp`, which will be explained in more detail below.\n\n`blog` contains the [Astro Starlight template](https://starlight.astro.build/) for the blog and documentation section. \n\n`e2e-tests` contains the end-to-end tests using Playwright, which you can run to test your app's functionality.\n\n### App File Structure\n\nWe've structured this full-stack app template vertically (by feature). That means that most directories within `app/src` contain both the React client code and NodeJS server code necessary for implementing its logic. \n\nLet's check out what's in the `app` folder in more detail:\n\n:::caution[v0.13 and below]\nIf you are using an older version of the OpenSaaS template with Wasp `v0.13.x` or below, you may see a slightly different file structure. But don't worry, the vast majority of the code and features are the same! \n:::\n\n```sh\n.\n main.wasp              # Wasp Config file. You define your app structure here.\n .wasp/                 # Output dir for Wasp. DON'T MODIFY THESE FILES!\n public/                # Public assets dir, e.g. www.yourdomain.com/public-banner.webp\n src/                   # Your code goes here.\n    admin/             # Admin dashboard related pages and components.\n    analytics/         # Logic and background jobs for processing analytics.\n    auth/              # All auth-related pages/components and logic.\n    client/            # Shared components, hooks, landing page, and other client code (React).\n    demo-ai-app/       # Logic for the example AI-powered demo app.\n    file-upload/       # Logic for uploading files to S3.\n    landing-page       # Landing page related code\n    messages           # Logic for app user messages.\n    payment/           # Logic for handling payments and webhooks.\n    server/            # Scripts, shared server utils, and other server-specific code (NodeJS).\n    shared/            # Shared constants and util functions.\n    user/              # Logic related to users and their accounts.\n .env.server            # Dev environment variables for your server code.\n .env.client            # Dev environment variables for your client code.\n .prettierrc            # Prettier configuration.\n tailwind.config.js     # TailwindCSS configuration.\n package.json\n package-lock.json\n .wasproot\n```\n\n### The Wasp Config file\n\nThis template at its core is a Wasp project, where [Wasp](https://wasp.sh) is a full-stack web app framework that let's you write your app in React, NodeJS, and Prisma and will manage the \"boilerplatey\" work for you, allowing you to just take care of the fun stuff!\n\n[Wasp's secret sauce](https://wasp.sh/docs) is its use of a config file (`main.wasp`) and compiler which takes your code and outputs the client app, server app and deployment code for you. \n\nIn this template, we've already defined a number of things in the `main.wasp` config file, including:\n\n- [Auth](https://wasp.sh/docs/auth/overview)\n- [Routes and Pages](https://wasp.sh/docs/tutorial/pages)\n- [Prisma Database Models](https://wasp.sh/docs/data-model/entities)\n- [Operations (data read and write functions)](https://wasp.sh/docs/data-model/operations/overview)\n- [Background Jobs](https://wasp.sh/docs/advanced/jobs)\n- [Email Sending](https://wasp.sh/docs/advanced/email)\n\nBy defining these things in the config file, Wasp continuously handles the boilerplate necessary with putting all these features together. You just need to focus on the business logic of your app.\n\nWasp abstracts away some things that you would normally be used to doing during development, so don't be surprised if you don't see some of the things you're used to seeing.\n\n:::note\nIt's possible to learn Wasp's feature set simply through using this template, but if you find yourself unsure how to implement a Wasp-specific feature and/or just want to learn more, a great starting point is the intro tutorial in the [Wasp docs](https://wasp.sh/docs) which takes ~20 minutes.\n:::\n\n### Client\n\nThe `src/client` folder contains any additional client-side code that doesn't belong to a feature:\n\n```sh\n.\n client\n     components         # Your shared React components.\n     fonts              # Extra fonts\n     hooks              # Your shared React hooks.\n     icons              # Your shared SVG icons.\n     static             # Assets that you need access to in your code, e.g. import logo from 'static/logo.png'\n     App.tsx            # Main app component to wrap all child components. Useful for global state, navbars, etc.\n     cn.ts              # Helper function for dynamic and conditional Tailwind CSS classes.\n     Main.css\n\n```\n\n### Server\n\nThe `src/server` folder contains any additional server-side code that does not belong to a specific feature: \n\n```sh\n server\n     scripts            # Scripts to run via Wasp, e.g. database seeding.\n     utils.ts\n```\n\n## Main Features\n\n### Auth\n\nThis template comes with a fully functional auth flow out of the box. It takes advantages of Wasp's built-in [Auth features](https://wasp.sh/docs/auth/overview), which do the dirty work of rolling your own full-stack auth for you!\n\n```js title=\"main.wasp\"\n  auth: {\n    userEntity: User,\n    methods: {\n      email: { \n        //...\n      },\n      google: {},\n      github: {},\n      discord: {}\n    },\n    onAuthFailedRedirectTo: \"/\",\n  },\n```\n\nBy defining the auth structure in your `main.wasp` file, Wasp manages all the necessary code for you, including:\n- Email verified login with reset password\n- Social login with Google and/or GitHub\n- Auth-related database entities for user credentials, sessions, and social logins \n- Custom-generated AuthUI components for login, signup, and reset password\n- Auth hooks for fetching user data\n\nWe've set the template up with Wasp's `email`, `google`, and `gitHub` methods, which are all battle-tested and suitable for production. \n\nYou can get started developing your app with the `email` method right away! \n\n:::caution[Dummy Email Provider]\nNote that the `email` method relies on an `emailSender` (configured at `app.emailSender` in the `main.wasp` file), a service which sends emails to verify users and reset passwords. \n\nFor development purposes, Wasp provides a `Dummy` email sender which Open SaaS comes with as the default. This provider *does not* actually send any confirmation emails to the specified email address, but instead logs all email verification links/tokens to the console! You can then follow these links to verify the user and continue with the sign-up process.\n\n```tsx title=\"main.wasp\" \n  emailSender: {\n    provider: Dummy, // logs all email verification links/tokens to the server's console\n    defaultFrom: {\n      name: \"Open SaaS App\",\n      email: \"me@example.com\" \n    },\n  },\n```\n:::\n\nWe will explain more about these auth methods, and how to properly integrate them into your app, in the [Authentication Guide](/guides/authentication/).\n\n### Subscription Payments with Stripe or Lemon Squeezy\n\nNo SaaS is complete without payments, specifically subscription payments. That's why this template comes with a fully functional Stripe or Lemon Squeezy integration. \n\nLet's take a quick look at how payments are handled in this template.\n\n1. a user clicks the `BUY` button and a **Checkout session** is created on the server\n2. the user is redirected to the Checkout page where they enter their payment info\n3. the user is redirected back to the app and the Checkout session is completed\n4. Stripe / Lemon Squeezy sends a webhook event to the server with the payment info\n5. The app server's **webhook handler** handles the event and updates the user's subscription status\n\nThe payment processor you choose (Stripe or Lemon Squeezy) and its related functions can be found at `src/payment/paymentProcessor.ts`. The `Payment Processor` object holds the logic for creating checkout sessions, webhooks, etc.\n\nThe logic for creating the Checkout session is defined in the `src/payment/operation.ts` file. [Actions](https://wasp.sh/docs/data-model/operations/actions) are a type of Wasp Operation, specifically your server-side functions that are used to **write** or **update** data to the database. Once they're defined in the `main.wasp` file, you can easily call them on the client-side:\n\na) define the action in the `main.wasp` file\n```js title=\"main.wasp\"\naction generateCheckoutSession {\n  fn: import { generateCheckoutSession } from \"@src/payment/operations\",\n  entities: [User]\n}\n```\n\nb) implement the action in the `src/payment/operations` file\n```js title=\"src/server/actions.ts\"\nexport const generateCheckoutSession = async (paymentPlanId, context) => { \n  //...\n }\n```\n\nc) call the action on the client-side\n```js title=\"src/client/app/SubscriptionPage.tsx\"\n\nconst handleBuyClick = async (paymentPlanId) => {\n  const checkoutSession = await generateCheckoutSession(paymentPlanId);\n};\n```\n\nThe webhook handler is defined in the `src/payment/webhook.ts` file. Unlike Actions and Queries in Wasp which are only to be used internally, we define the webhook handler in the `main.wasp` file as an API endpoint in order to expose it externally to Stripe\n\n```js title=\"main.wasp\"\napi paymentsWebhook {\n  fn: import { paymentsWebhook } from \"@src/payment/webhook\",\n  httpRoute: (POST, \"/payments-webhook\") \n  entities: [User],\n}\n```\n\nWithin the webhook handler, we look for specific events that the Payment Processor sends us to let us know which payment was completed and for which user. Then we update the user's subscription status in the database.\n\nTo learn more about configuring the app to handle your products and payments, check out the [Payments Integration guide](/guides/payments-integration/).\n\n:::tip[Star our Repo on GitHub! ]\nWe've packed in a ton of features and love into this SaaS starter, and offer it all to you for free!\n\nIf you're finding this template and its guides useful, consider giving us [a star on GitHub](https://github.com/wasp-lang/wasp)\n:::\n\n### Analytics and Admin Dashboard\n\nKeeping an eye on your metrics is crucial for any SaaS. That's why we've built an administrator's dashboard where you can view your app's stats, user data, and revenue all in one place.\n\nTo do that, we've leveraged Wasp's [Jobs feature](https://wasp.sh/docs/advanced/jobs) to run a cron job that calculates your daily stats. The app stats, such as page views and sources, can be pulled from either Plausible or Google Analytics. All you have to do is create a project with the analytics provider of your choice and import the respective pre-built helper functions!\n\n```js title=\"main.wasp\"\njob dailyStatsJob {\n  executor: PgBoss,\n  perform: {\n    fn: import { calculateDailyStats } from \"@src/analytics/stats\"\n  },\n  schedule: {\n    cron: \"0 * * * *\" // runs every hour\n  },\n  entities: [User, DailyStats, Logs, PageViewSource]\n}\n```\n\nFor more info on integrating Plausible or Google Analytics, check out the [Analytics guide](/guides/analytics/).\n\n## App Customization Walkthrough\n\n### General Considerations\n\nWhen you first start your Open SaaS app straight from the template, it will run, but many of the services won't work because they lack your own API keys. Here are list of services that need your API keys to work properly:\n\n- Auth Methods (Google, GitHub)\n- Stripe or Lemon Squeezy\n- OpenAI (Chat GPT API)\n- Email Sending (Sendgrid) -- you must set this up if you're using the `email` Auth method \n- Analytics (Plausible or Google Analytics)\n- File Uploading (AWS S3)\n\nNow would be a good time to decide which features you do and do not need for your app, and remove the ones from the codebase that you don't need.\n\nFor the features you will use, the next section of the documentation, `Guides`, will walk you through how to set each one up!\n\n:::note[Open SaaS is built on Wasp]\nRemember, this template is built on the Wasp framework. If, at any time, these docs fail to provide enough information about a certain built-in feature, make sure to check out the [Wasp docs](https://wasp.sh/docs)!\n:::\n\nBut before you start setting up the main features, let's walk through the customizations you will likely want to make to the template to make it your own.\n\n### Customizations Checklist\n#### `main.wasp` Config File\n- [ ] Change the app name and title:\n  ```ts title=\"main.wasp\" {1, 6}\n    app YourAppName { \n      wasp: {\n        version: \"^0.13.2\"\n      },\n\n      title: \"Your App Name\",\n  ```\n  :::caution[Restart Your App]\n  Upon changing the app name, new, empty development database will be assigned to your app. This means you'll need to rerun `wasp db start`, `wasp db migrate-dev` and `wasp start`.\n  :::\n- [ ] Update meta tags in `app.head` (even if you don't have a custom domain yet, put one you would like to have, as this won't affect development).\n- [ ] Update `app.emailSender.defaultFrom.name` with the name of your app/company/whatever you want your users to see in their inbox, if you're using the `emailSender` feature and/or `email` Auth method.\n- [ ] Remove any features you might not use or need:\n  - [ ] Auth methods - `app.auth.methods`\n    - [ ] If you're not using `email` Auth method, remove the routes/pages `RequestPasswordReset`, `PasswordReset`, and `EmailVerification`\n  - [ ] Email Sending - `app.emailSender`, `job emailChecker`\n  - [ ] Plausible analytics - `app.head`\n  - [ ] File Uploading - `entity File`, `route FileUploadRoute`, `action createFile`, `query getAllFilesByUser`, `getDownloadFileSignedURL`\n- [ ] Rename Entites and their properties, Routes/Pages, & Operations, if you wish.\n\n#### Customizing the Look / Style of the App\n- [ ] Update your favicon at `public/favicon.ico`.\n- [ ] Update the banner image used when posting links to your site at `public/public-banner.webp`.\n  - [ ] Update the URL for this banner at `og:image` and `twitter:image` in `app.head` of the `main.wasp` file.\n- [ ] Make changes to your landing page, `landingPage.tsx`.\n  - [ ] Customize the `navBar`, `features`, `testimonials`, and `faqs` in the `contentSections.ts` file.\n  - [ ] Change/rename the `logo.webp` and main hero banner (`open-saas-banner.webp`) in the `static` folder.\n- [ ] If you want to make changes to the global styles of the app, you can do so in `tailwind.config.cjs`. **Be aware that the current custom global styles defined already are mostly used in the app's Admin Dashboard!**\n\n#### Customizing the Analytics & Admin Dashboard\n- [ ] If you're using Plausible, update the `app.head` with your Plausible domain.\n- [ ] Update the `calculateDailyStats` function in `src/server/workers/calculateDailyStats.ts` to pull the stats from the analytics provider you've chosen (Plausible or Google Analytics).\n- [ ] Change the cron schedule in the `dailyStatsJob` in the `main.wasp` file to match how often you want your stats to be calculated.\n- [ ] Update the `AdminDashboard` components to display the stats you do/don't want to see.\n\n#### `.env.server` and `.env.client` Files\n- [ ] After you've followed the `Guides` in the next section, you'll need to update the `.env.server` and `.env.client` files with your API keys and other environment variables for the services you've decided to use.\n- [ ] Delete any redundant environment variables that you're not using, from the `.env.*` files as well as the `.env.*.example` files.\n\n#### Other Customizations\n- [ ] Make a new GitHub Repo for your app.\n- [ ] Deploy your app to a hosting provider.\n- [ ] Buy a domain name for your app and get it set up with your hosting provider.\n- [ ] Read the `e2e-tests` README and get your end-to-end tests set up.\n  - [ ] Change the tests to suit the changes you've made to your app\n- [ ] Get the CI pipeline set up for your app (you can get started by using the Open SaaS development CI [example here](https://github.com/wasp-lang/open-saas/tree/main/.github/workflows))\n\n## What's next?\n\nIn the following `Guides` sections, we'll walk you through getting those API keys and setting up the finer points of features such as Payments & Webhooks, Auth, Email Sending, Analytics, and more.\n\n---\n\n# Analytics\n\nThis guide will show you how to integrate analytics for your app. You can choose between [Google Analytics](#google-analytics) and [Plausible](#plausible).\n\nGoogle Analytics is free, but uses cookies, so you'll probably want/need to implement the [Cookie Consent Modal](/guides/cookie-consent/) when using it.\n\nPlausible is an open-source, privacy-friendly alternative to Google Analytics. **You DO NOT have to use the cookie consent modal** with Plausible, as it does not use cookies. It's also easier to use than Google if you use their hosted service, but be aware it is a paid feature. It is completely free if you want to self-host it, although this comes with some additional setup steps.\n\nIf you're looking to add analytics to your blog, you can follow the [Adding Analytics to your Blog](#adding-analytics-to-your-blog) section at the end of this guide.\n\n## Plausible\n\n### Hosted Plausible\nSign up for a hosted Plausible account [here](https://plausible.io/).\n\nOnce you've signed up, you'll be taken to your dashboard. Create your site by adding your domain. Your domain is also your `PLAUSIBLE_SITE_ID` in your `.env.server` file. Make sure to add it.\n\n```sh\nPLAUSIBLE_SITE_ID=<your domain without www>\n```\n\nAfter adding your domain, you'll be taken to a page with your Plausible script tag. Copy and paste this script tag into the `main.wasp` file's head section. \n\n```js {7}\napp OpenSaaS {\n  wasp: {\n    version: \"^0.13.0\"\n  },\n  title: \"My SaaS App\",\n  head: [\n        \"<your plausible script tag here>\",\n  ],\n  //...\n```\n\nGo back to your Plausible dashboard, click on your username in the top right, and click on the `Settings` tab. Scroll down, find your API key and paste it into your `.env.server` file under the `PLAUSIBLE_API_KEY` variable.\n\n:::note[No Cookies]\nPlausible does not use cookies, so you don't need to add it to your [Cookie Consent Modal](/guides/cookie-consent/), hence the script can be added directly to `app.head` in your `main.wasp` file.\n:::\n\n### Self-hosted Plausible\n\nPlausible, being an open-source project, allows you to self-host your analytics. This is a great option if you want to keep your data private and not pay for the hosted service.\n\n*coming soon...*\n*until then, check out the [official documentation](https://plausible.io/docs)*\n\n:::tip[Contribute!] \nIf you'd like to help us write this guide, click the \"Edit page\" button at the bottom of this page \n\nAs a completely free, open-source project, we appreciate any help \n:::\n\n## Google Analytics\n\nFirst off, head over to `src/analytics/stats.ts` and switch out the Plausible Provider for Google Analytics so that your [background (cron) job](https://wasp.sh/docs/advanced/jobs) fetches the data from Google Analytics for your [Admin Dashboard](/general/admin-dashboard/):\n\n```ts ins={3} del={2} title=\"stats.ts\"\n//...\n\nexport const calculateDailyStats: DailyStatsJob<never, void> = async (_args, context) => { \n  //...\n}\n```\n\nNext, make sure you sign up for [Google analytics](https://analytics.google.com/), then go to your `Admin` panel in the bottom of the left sidebar and then create a \"Property\" for your app.\n\nOnce you've created a new Property, some Installation Instructions will pop up. Select `install manually` where you should see a string that looks like this:\n\n```sh title=\"<your-google-analytics-id>\"\n https://www.googletagmanager.com/gtag/js?id=<your-google-analytics-id>\n```\nand copy and paste the Google Analytics ID into your `.env.client` file to get it working with the [Cookie Consent Modal](/guides/cookie-consent/) provided with this template:\n\n```sh title=\".env.client\"\nREACT_APP_GOOGLE_ANALYTICS_ID=<your-google-analytics-id> # e.g. G-1234567890\n```\n\n:::tip[noscript]\nIn the Installation Instructions, Google Tag Manager might also instruct you to paste the `noscript` code snippet immediately after the opening `<body>` tag.\nYou should skip this step because this snippet is activated only if users try to browse your app without JavaScript enabled, which is very rare and Wasp needs JS anyway.\n:::\n\nThen, set up the Google Analytics API access by following these steps:\n\n1. **Set up a Google Cloud project:** If you haven't already, start by setting up a project in the [Google Cloud Console](https://console.cloud.google.com/).\n\n2. **Enable the Google Analytics API for your project:** Navigate to the \"Library\" in the Google Cloud Console and search for the \"Google Analytics Data API\" (for Google Analytics 4 properties) and enable it.\n\n3. **Create credentials:** Now go to the \"Credentials\" tab within your Google Cloud project, click on `+ credentials`, and create a new service account key. First, give it a name. Then, under \"Grant this service account access to project\", choose `viewer`.\n\n4. **Create Credentials:** When you go back to `Credentials` page, you should see a new service account listed under \"Service Accounts\". It will be a long email address to ends with `@your-project-id.iam.gserviceaccount.com`. Click on the service account name to go to the service account details page. \n\n    - Under \"Keys\" in the service account details page, click \"Add Key\" and choose `Create new key`.\n  \n    - Select \"JSON\", then click \"Create\" to download your new service account's JSON key file. Keep this file secure and don't add it to your git repo as it grants access to your Google Analytics data.  \n5. **Update your Google Anayltics Settings:** Go back to your Google Analytics dashboard, and click on the `Admin` section in the left sidebar. Under `Property Settings > Property > Property Access Management` Add the service account email address (the one that ends with `@your-project-id.iam.gserviceaccount.com`) and give it `Viewer` permissions.\n\n6. **Encode and add the Credentials:** Add the `client_email` and the `private_key` from your JSON Key file into your `.env.server` file. But be careful! Because Google uses a special PEM private key, you need to first convert the key to base64, otherwise you will run into errors parsing the key. To do this, in a terminal window, run the command below and paste the output into your `.env.server` file under the `GOOGLE_ANALYTICS_PRIVATE_KEY` variable:\n    ```sh \n    echo -n \"-----BEGIN PRIVATE KEY-----\\nMI...A++eK\\n-----END PRIVATE KEY-----\\n\" | base64\n    ```\n    \n7. **Add your Google Analytics Property ID:** You will find the Property ID in your Google Analytics dashboard in the `Admin > Property > Property Settings > Property Details` section of your Google Analytics property (**not** your Google Cloud console). Add this 9-digit number to your `.env.server` file under the `GOOGLE_ANALYTICS_PROPERTY_ID` variable.\n\n## Adding Analytics to your Blog\n\nTo add your analytics script to your Astro Starlight blog, all you need to do is modify the `head` property in your `blog/astro.config.mjs` file. \n\nBelow is an example of how to add Google Analytics to your blog:\n\n```js\nexport default defineConfig({\n  site: 'https://opensaas.sh',\n  integrations: [\n    starlightBlog({ \n      // ...\n    }),\n    starlight({\n      //...\n       head: [\n        {\n          tag: 'script',\n          attrs: {\n            src: 'https://www.googletagmanager.com/gtag/js?id=<YOUR-GOOGLE-ANALYTICS-ID>',\n          },\n        },\n        {\n          tag: 'script',\n          content: `\n          window.dataLayer = window.dataLayer || [];\n          function gtag(){dataLayer.push(arguments);}\n          gtag('js', new Date());\n        \n          gtag('config', '<YOUR-GOOGLE-ANALYTICS-ID>');\n          `,\n        },\n      ],\n```\n\n---\n\n# Authentication\n\nSetting up your app's authentication is easy with Wasp. In fact, it's already set up for you in the `main.wasp` file: \n\n```tsx title=\"main.wasp\"\n  auth: {\n    userEntity: User,\n    methods: {\n      email: {}, \n      google: {},\n      gitHub: {},\n      discord: {}\n    },\n    onAuthFailedRedirectTo: \"/\",\n  },\n```\n\nThe great part is, by defining your auth config in the `main.wasp` file, Wasp manages most of the Auth process for you, including the auth-related database entities for user credentials and sessions, as well as auto-generated client components for your app on the fly (aka AuthUI -- you can see them in use in the `src/auth` folder).\n\n## Email Verified Auth\n\n`email` method is the default auth method in Open Saas.\n\nSince it needs to send emails to verify users and reset passwords, it requires an [email sender](https://wasp.sh/docs/advanced/email) provider: a service it can use to send emails.\n\"email sender\" provider is configured via `app.emailSender` field in the `main.wasp` file.\n\n:::caution[Dummy Email Provider]\nTo make it easy for you to get started, Open SaaS initially comes with the `Dummy` \"email sender\" provider, which does not send any emails, but instead logs all email verification links/tokens to the server's console!\nYou can then follow these links to verify the user and continue with the sign-up process.\n\n```tsx title=\"main.wasp\"\n  emailSender: {\n    provider: Dummy, // logs all email verification links/tokens to the server's console\n    defaultFrom: {\n      name: \"Open SaaS App\",\n      email: \"me@example.com\" \n    },\n  },\n```\n\nYou **can not use the Dummy provider in production** and your app **will not build** until you move to a production-ready provider, such as SendGrid. We outline the process of migrating to SendGrid below. \n:::\n\nIn order to use the `email` auth method in production, you'll need to switch from the `Dummy` \"email sender\" provider to a production-ready provider like SendGrid: \n\n1. First, set up your app's `emailSender` in the `main.wasp` file by following [this guide](/guides/email-sending/#integrate-your-email-sender). \n2. Add your `SENDGRID_API_KEY` to the `.env.server` file.\n3. Make sure the email address you use in the `fromField` object is the same email address that you configured your SendGrid account to send out emails with. In the end, your `main.wasp` file should look something like this: \n```ts title=\"main.wasp\" {6,7} del={15} ins={16}\n  auth: {\n    methods: {\n      email: {\n        fromField: {\n          name: \"Open SaaS App\",\n          // When using SendGrid, you must use the same email address that you configured your account to send out emails with!\n          email: \"me@example.com\" \n        },\n        //...\n      }, \n    }\n  },\n  //...\n  emailSender: {\n    provider: Dummy,\n    provider: SendGrid,\n    defaultFrom: {\n      name: \"Open SaaS App\",\n      // When using SendGrid, you must use the same email address that you configured your account to send out emails with!\n      email: \"me@example.com\" \n    },\n  },\n  ```\n\nAnd that's it. Wasp will take care of the rest and update your AuthUI components accordingly.\n\nCheck out the  [Wasp Auth docs](https://wasp.sh/docs/auth/overview) for more info.\n\n## Google, GitHub, & Discord Auth\n\nWe've also customized and pre-built the Google and GitHub auth flow for you. To start using them, you just need to uncomment out the methods you want in your `main.wasp` file and obtain the proper API keys to add to your `.env.server` file. \n\nTo create a Google OAuth app and get your Google API keys, follow the instructions in [Wasp's Google Auth docs](https://wasp.sh/docs/auth/social-auth/google#3-creating-a-google-oauth-app).\n\nTo create a GitHub OAuth app and get your GitHub API keys, follow the instructions in [Wasp's GitHub Auth docs](https://wasp.sh/docs/auth/social-auth/github#3-creating-a-github-oauth-app).\n\nTo create a Discord OAuth app and get your Discord API keys, follow the instructions in [Wasp's Discord Auth docs](https://wasp.sh/docs/auth/social-auth/discord#3-creating-a-discord-app)\n\nAgain, Wasp will take care of the rest and update your AuthUI components accordingly.\n\n---\n\n# Authorization\n\nThis guide will help you get started with authorization in your SaaS app. \n\nAuthorization refers to what users can access in your app. This is useful for differentiating between users who have paid for different subscription tiers (e.g. \"hobby\" vs \"pro\"), or between users who have admin privileges and those who do not.\n\nAuthorization differs from [authentication](/guides/authentication/) in that authentication refers to the process of verifying that a user is who they say they are (e.g. logging in with a username and password).\n\nTo learn more about the different types of user permissions built into this SaaS template, including Stripe subscription tiers and statuses, check out the [User Overview Reference](/general/user-overview/).\n\nAlso, check out our [blog post](https://wasp.sh/blog/2022/11/29/permissions-in-web-apps) to learn more about authorization (access control) in web apps.\n\n### Client-side Authorization\n\nOpen Saas starts with all users having access to the landing page (`/`), but only authenticated users having access to the rest of the app (e.g. to the `/demo-app`, or to the `/account`).\n\nTo control which pages require users to be authenticated to access them, you can set the `authRequired` property of the corresponding `page` definition in your `main.wasp` file:\n\n```tsx title=\"main.wasp\" {3}\nroute AccountRoute { path: \"/account\", to: AccountPage }\npage AccountPage {\n  authRequired: true,\n  component: import Account from \"@src/user/AccountPage\"\n}\n```\n\nThis will automatically redirect users to the login page if they are not logged in while trying to access that page.\n\n:::caution[Client-side authorization is just for the looks]\nUsers can manipulate the client code as they wish, meaning that client-side access control (authorization) serves the purpose of ergonomics/user experience, not the purpose of restricting access to sensitive data.\nThis means that authorization in the client code is a nice-to-have: it is here to make sure users don't get lost in the part of the app they can't work with because data is missing due to them not having access, not to actually restrict them from doing something.\nActually ensuring they don't have access to the data, that is on the server to ensure, via server-side logic that you will implement for authorization (access control).\n:::\n\nIf you want more fine-grained control over what users can access, there are two Wasp-specific options:\n1. When you define the `authRequired: true` property on the `page` definition, Wasp automatically passes the User object to the page component. Here you can check for certain user properties before authorizing access:\n\n```tsx title=\"ExamplePage.tsx\" \"{ user }: { user: User }\"\n\nexport default function Example({ user }: { user: User }) {\n\n  if (user.subscriptionStatus === 'past_due') {\n    return (<span>Your subscription is past due. Please update your payment information.</span>)\n  }\n  if (user.subscriptionStatus === 'cancel_at_period_end') {\n    return (<span>Your susbscription will end on 01.01.2024</span>)\n  }\n  if (user.subscriptionStatus === 'active') {\n    return (<span>Thanks so much for your support!</span>)\n  }\n\n}\n```\n\n2. Or you can take advantage of the `useAuth` hook and check for certain user properties before authorizing access to certain pages or components:\n\n```tsx title=\"ExamplePage.tsx\" {1, 4}\n\nexport default function ExampleHomePage() {\n  const { data: user } = useAuth();\n\n  return (\n    <h1> Hi {user.email || 'there'}  </h1>\n  )\n}\n```\n\n### Server-side Authorization\n\nAuthorization on the server-side is the core of your access control logic, and determines what users actually can or can't do (unlike client-side authorization logic which is there merely for UX).\n\nYou can authorize access to server-side operations by adding a check for a logged-in user on the `context.user` object which is passed to all operations in Wasp:\n\n```tsx title=\"src/server/actions.ts\" \nexport const someServerAction: SomeServerAction<...> = async (args, context) => {\n  if (!context.user) {\n    throw new HttpError(401); // throw an error if user is not logged in\n  }\n\n  if (context.user.subscriptionStatus === 'past_due') {\n    throw new HttpError(403, 'Your subscription is past due. Please update your payment information.');\n  }\n  //...\n}\n```\n\n---\n\n# Cookie Consent Modal\n\nCookie consent banners are annoying, we know. But they are legally required in many countries, so we have to deal with them.\n\nThis guide will help you dynamically add or remove cookies from your app via the Cookie Consent modal that comes with this template. \n\nThis is needed for *non-essential cookies* that are not necessary for the basic functionality of your app, such as analytics cookies or marketing cookies.\n\nThe Modal can be found at `app/src/client/components/cookie-consent/` and contains two main files:\n1. `Banner.tsx` - the component that displays the banner at the bottom of the page.\n2. `Config.ts` - the configuration file that contains the cookies/scripts that will be dynamically added.\n\nThe `Banner.tsx` component is imported in `app/src/client/App.tsx` and is rendered at the bottom of the page, while all the changes to the banner itself are done within the `Config.ts` file, which we explain below.\n\n## Configuration\n\nWe decided to use the `vanilla-cookieconsent` library to handle the cookie consent. We've set it up to give you some basic functionality, using mostly the default settings. For a full list of options, you can check the [official documentation](https://www.npmjs.com/package/vanilla-cookieconsent).\n\nBelow, we will guide you through the necessary steps to get the cookie consent modal set up for your app.\n\n### Google Analytics\n\nWhat's impotant to note for this template is that we are simply using the `onAccept` callbacks to dynamically add or remove our [Google Analytics](/guides/analytics/#google-analytics) cookies from the page. In order for it to work correctly with your app, you need to add your [Google Analytics ID](/guides/analytics/#google-analytics) to your `.env.client` file.\n\n```sh title=\".env.client\"\n REACT_APP_GOOGLE_ANALYTICS_ID=G-1234567890\n```\n\nAnd that's it! The cookie consent modal will now dynamically add or remove the Google Analytics cookies based on the user's choice.\n\nTo check if it's working correctly, you can open the browser's developer tools and check the cookies tab. You should see the following cookies being added or removed based on the user's choice:\n\n```sh\n_ga\n_ga... # Google Analytics cookies.\ncc_cookie # Cookie Consent cookie. The name of this cookie can be changed in the config file.\n```\n\n### Plausible Analytics\n\nIf you decide to go with [Plausible Analytics](/guides/analytics/#plausible), you **DO NOT** need to ask users for their consent to use cookies because Plausible, as a privacy-first analytics provider, [does not use cookies](https://plausible.io/privacy-focused-web-analytics). Instead, It collects website usage data anonymously and in aggregate form only, without any personally identifiable information\n\n**By avoiding cookies, Plausible Analytics avoids the need for cookie consent banners.**\n\n### Your Terms / Privacy Policy\n\nYou should also add a link to your terms and privacy policy within `consentModal` section of `config.language`:\n\n```ts title=\"Config.ts\" {10,11}\n    language: {\n      default: 'en',\n      translations: {\n        en: {\n          consentModal: {\n            title: 'We use cookies',\n            // ...\n            // TODO: Add your own privacy policy and terms and conditions links below.\n            footer: `\n            <a href=\"<your-url-here>\" target=\"_blank\">Privacy Policy</a>\n            <a href=\"<your-url-here>\" target=\"_blank\">Terms and Conditions</a>\n                    `,\n          },\n        },\n      },\n    }\n```\n\n### Allowing Users to Control Certain Cookies (OPTIONAL)\n\nIf you've added more than just Google Analytics cookies to your app, you can allow users to control which cookies they want to accept or reject. For example, if you've added marketing cookies, you can add a button to the modal that allows users to reject them, while accepting analytics cookies.\n\nTo do that, you can change the `preferencesModal.sections` property in `config.language`. Any section that you add to `preferencesModal.sections` must match a `linkedCategory` in the `config.categories` property. Make sure you also add a `showPreferencesBtn` property to `consentModal` (highlighted below). \n\nBelow is an example of what your config might look like if you want to give users the option to control over multiple cookie preferences:\n\n```ts title=\"Config.ts\" {7,9-67}\n    language: {\n      default: 'en',\n      translations: {\n        en: {\n          consentModal: {\n            // ...\n            showPreferencesBtn: 'Manage Individual preferences', // This button will open the preferences modal below.\n          },\n          preferencesModal: {\n            title: 'Manage cookie preferences',\n            acceptAllBtn: 'Accept all',\n            acceptNecessaryBtn: 'Reject all',\n            savePreferencesBtn: 'Accept current selection',\n            closeIconLabel: 'Close modal',\n            serviceCounterLabel: 'Service|Services',\n            sections: [\n              {\n                title: 'Your Privacy Choices',\n                description: `In this panel you can express some preferences related to the processing of your personal information. You may review and change expressed choices at any time by resurfacing this panel via the provided link. To deny your consent to the specific processing activities described below, switch the toggles to off or use the \"Reject all\" button and confirm you want to save your choices.`,\n              },\n              {\n                title: 'Strictly Necessary',\n                description:\n                  'These cookies are essential for the proper functioning of the website and cannot be disabled.',\n                linkedCategory: 'necessary',\n              },\n              {\n                title: 'Performance and Analytics',\n                description:\n                  'These cookies collect information about how you use our website. All of the data is anonymized and cannot be used to identify you.',\n                linkedCategory: 'analytics',\n                cookieTable: {\n                  caption: 'Cookie table',\n                  headers: {\n                    name: 'Cookie',\n                    domain: 'Domain',\n                    desc: 'Description',\n                  },\n                  body: [\n                    {\n                      name: '_ga',\n                      domain: location.hostname,\n                      desc: 'Description 1',\n                    },\n                    {\n                      name: '_gid',\n                      domain: location.hostname,\n                      desc: 'Description 2',\n                    },\n                  ],\n                },\n              },\n              {\n                title: 'YouTube',\n                description: 'This service is used to display video content on the website.',\n                linkedCategory: 'youtube',\n                cookieTable: { \n                  // ...\n                }\n              },\n              {\n                title: 'More information',\n                description:\n                  'For any queries in relation to my policy on cookies and your choices, please <a href=\"#contact-page\">contact us</a>',\n              },\n            ],\n          },\n        },\n      },\n    }\n```\n\nFor more information on how to do that, check the [official documentation](https://cookieconsent.orestbida.com/reference/configuration-reference.html#translation-preferencesmodal-sections).\n\n---\n\n# Deploying\n\nBecause this SaaS app is a React/NodeJS/Postgres app built on top of [Wasp](https://wasp.sh), Open SaaS can take advantage of Wasp's easy, one-command deploy to Fly.io or manual deploy to any provider of your choice.\n\nThe simplest and quickest option is to take advantage of Wasp's one-command deploy to Fly.io.\n\nOr if you prefer to deploy to a different provider, or your frontend and backend separately, you can follow the Deploying Manually section below.\n\n## Deploying your App\n### Steps for Deploying\n\nThese are the steps necessary for you to deploy your app. We recommend you follow these steps in order.\n\n- [ ] Get your [production API keys and environment variables](#prerequisites)\n- [ ] Deploy your app easily to [Fly.io](#deploying-to-flyio) or [manually](#deploying-manually--to-other-providers) to any provider.\n- [ ] Add the correct [redirect URL's to your social auth credentials](#adding-server-redirect-urls-to-social-auth)\n- [ ] Set up your [production webhooks for either [Stripe](#setting-up-your-production-stripe-webhook) or [Lemon Squeezy](#setting-up-your-production-lemon-squeezy-webhook)\n- [ ] Set your [production environment variables](#other-vars) on your deployed apps\n- [ ] (Optional) [Deploy your blog](#deploying-your-blog)\n\nEach of these steps is covered in more detail below.\n\n### Prerequisites\n#### AWS S3 CORS configuration\nIf you're storing files in AWS S3, ensure you've listed your production domain\nin the bucket's CORS configuration under `AllowedOrigins`. Check the [File\nuploading guide](/guides/file-uploading/#change-the-cors-settings) for details.\n\n#### Env Vars\nMake sure you've got all your API keys and environment variables set up before you deploy.\n##### Payment Processor Vars\nIn the [Payments Processor integration guide](/guides/payments-integration/), you set up your API keys using test keys and test product ids. You'll need to get the live/production versions of those keys. To get these, repeat the instructions in the [Integration Guide](/guides/payments-integration/) without being in test mode. Add the new keys to your deployed environment secrets.\n\n##### Other Vars\nMany of your other environment variables will probably be the same as in development, but you should double-check that they are set correctly for production.\n\nHere are a list of all of them (some of which you may not be using, e.g. Analytics, Social Auth) in case you need to check:\n###### General Vars\n- [ ] `DATABASE_URL`\n- [ ] `JWT_SECRET`\n- [ ] `WASP_WEB_CLIENT_URL`\n- [ ] `WASP_SERVER_URL`\n\n###### Open AI API Key\n- [ ] `OPENAI_API_KEY`\n\n###### Sendgrid API Key\n- [ ] `SENDGRID_API_KEY`\n\n###### Social Auth Vars\n- [ ] `GOOGLE_CLIENT_ID`\n- [ ] `GOOGLE_CLIENT_SECRET`\n- [ ] `GITHUB_CLIENT_ID`\n- [ ] `GITHUB_CLIENT_SECRET`\n\n###### Analytics Vars\n- [ ] `REACT_APP_PLAUSIBLE_ANALYTICS_ID` (for client-side)\n- [ ] `PLAUSIBLE_API_KEY`\n- [ ] `PLAUSIBLE_SITE_ID`\n- [ ] `PLAUSIBLE_BASE_URL`\n- [ ] `REACT_APP_GOOGLE_ANALYTICS_ID` (for client-side)\n- [ ] `GOOGLE_ANALYTICS_CLIENT_EMAIL`\n- [ ] `GOOGLE_ANALYTICS_PROPERTY_ID` \n- [ ] `GOOGLE_ANALYTICS_PRIVATE_KEY`\n(Make sure you convert the private key within the JSON file to base64 first with `echo -n \"PRIVATE_KEY\" | base64`. See the [Analytics docs](/guides/analytics/#google-analytics) for more info)\n\n###### AWS S3 Vars\n- [ ] `AWS_S3_IAM_ACCESS_KEY`\n- [ ] `AWS_S3_IAM_SECRET_KEY`\n- [ ] `AWS_S3_FILES_BUCKET`\n- [ ] `AWS_S3_REGION`\n\n:::tip[Deployed? Get some swag! ]\n\nDo you have an Open SaaS app running in production? If yes, we'd love to send some swag your way! All you need to do is fill out [this form](https://e44cy1h4s0q.typeform.com/to/EPJCwsMi) and we'll make it happen.\n\n:::\n\n### Deploying to Fly.io\n\n[Fly.io](https://fly.io) is a platform for running your apps globally. It's a great choice for deploying your SaaS app because it's free to get started, can host your entire full-stack app in one place, scales well, and has one-command deploy integration with Wasp.\n\n**Wasp provides the handy `wasp deploy` command to deploy your entire full-stack app (DB, server, and client) in one command.**\n\nTo learn how, please follow the detailed guide for [deploying to Fly via the Wasp CLI](https://wasp.sh/docs/deployment/deployment-methods/cli) from the Wasp documentation. We suggest you follow this guide carefully to get your app deployed.\n\n:::caution[Setting Environment Variables]\nRemember, because we've set certain client-side env variables, make sure to pass them to the `wasp deploy` commands so that they can be included in the build: \n```sh\nREACT_APP_CLIENT_ENV_VAR_1=<...> REACT_APP_CLIENT_ENV_VAR_2=<...> wasp deploy \n```\n\nThe `wasp deploy` command will also take care of setting the following server-side environment variables for you so you don't have to:\n- `DATABASE_URL`\n- `PORT`\n- `JWT_SECRET`\n- `WASP_WEB_CLIENT_URL`\n- `WASP_SERVER_URL`\n\nFor setting the remaining server-side environment variables, please refer to the [Deploying with the Wasp CLI Guide](https://wasp.sh/docs/deployment/deployment-methods/cli#launch).\n:::\n\n### Deploying Manually / to Other Providers\n\nIf you prefer to deploy manually, your frontend and backend separately, or just prefer using your favorite provider you can follow [Wasp's Manual Deployment Guide](https://wasp.sh/docs/deployment/deployment-methods/paas).\n\n:::caution[Client-side Environment Variables]\nRemember to always set additional client-side environment variables, such as `REACT_APP_STRIPE_CUSTOMER_PORTAL` by appending them to the build command, e.g. \n```sh\nREACT_APP_CLIENT_ENV_VAR_1=<...> npm run build\n```\n:::\n\n### Adding Server Redirect URL's to Social Auth\n\nAfter deploying your server, you need to add the correct redirect URIs to the credential settings. For this, refer to the following guides from the Wasp Docs:\n\n- [Google Auth](https://wasp.sh/docs/auth/social-auth/google#3-creating-a-google-oauth-app:~:text=Under%20Authorized%20redirect%20URIs)\n- [Github Auth](https://wasp.sh/docs/auth/social-auth/github#3-creating-a-github-oauth-app:~:text=Authorization%20callback%20URL)\n\n### Setting up your Production Stripe Webhook\n\nNow you need to set up your stripe webhook for production use. Below are some important steps and considerations you should take as you prepare to deploy your app to production.\n\n#### Stripe API Versions\n\nWhen you create your Stripe account, Stripe will automatically assign you to their latest API version at that time. This API version is important because it determines the structure of the responses Stripe sends to your webhook, as well as the structure it expects of the requests you make toward the Stripe API.\n  \nBecause this template was built with a specific version of the Stripe API in mind, it could be that your Stripe account is set to a different API version. \n\n:::note\n```ts title=\"stripeClient.ts\" \nexport const stripe = new Stripe(process.env.STRIPE_API_KEY!, {\n  apiVersion: 'YYYY-MM-DD', // e.g. 2023-08-16\n});\n```\nWhen you specify a specific API version in your Stripe client, the requests you send to Stripe from your server, along with their responses, will match that API version. On the other hand, Stripe will send all other events to your webhook that didn't originate as a request sent from your server, like those made after a user completes a payment on checkout, using the default API version of the API.\n\nThis is why it's important to make sure your Stripe client version also matches the API version in your Stripe account, and to thoroughly test any changes you make to your Stripe client before deploying to production.\n:::\n\nTo make sure your app is consistent with your Stripe account, here are some steps you can follow:\n\n1. You can find your `default` API version in the Stripe dashboard under the [Developers](https://dashboard.stripe.com/developers) section.\n2. Check that the API version in your `/src/payment/stripe/stripeClient.ts` file matches the default API version in your dashboard:\n```ts title=\"stripeClient.ts\" {2}\nexport const stripe = new Stripe(process.env.STRIPE_KEY!, {\n  apiVersion: 'YYYY-MM-DD', // e.g. 2023-08-16\n});\n```\n3. If they don't match, you can upgrade/downgrade your Stripe NPM package in `package.json` to match the API version in your dashboard:\n  - If your default version on the Stripe dashboard is also the latest version of the API, you can simply upgrade your Stripe NPM package to the latest version.\n  - If your default version on the Stripe dashboard is not the latest version, and you don't want to [upgrade to the latest version](https://docs.stripe.com/upgrades#how-can-i-upgrade-my-api), because e.g. you have other projects that depend on the current version, you can find and install the Stripe NPM package version that matches your default API version by following these steps:\n    - Find and note the date of your default API version in the [developer dashboard](https://dashboard.stripe.com/developers).\n    - Go to the [Stripe NPM package](https://www.npmjs.com/package/stripe) page and hover over `Published` date column until you find the package release that matches your version. For example, here we find the NPM version that matches the default API version of `2023-08-16` in our dashboard, which is `13.x.x`.\n    \n    - Install the correct version of the Stripe NPM package by running, :\n    ```sh\n      npm install stripe@x.x.x # e.g. npm install stripe@13.11.0\n    ```\n4. **Test your app thoroughly** to make sure that the changes you made to your Stripe client are working as expected before deploying to production.\n\n#### Creating Your Production Webhook\n1. go to [https://dashboard.stripe.com/webhooks](https://dashboard.stripe.com/webhooks)\n2. click on `+ add endpoint`\n3. enter your endpoint url, which will be the url of your deployed server + `/payments-webhook`, e.g. `https://open-saas-wasp-sh-server.fly.dev/payments-webhook`\n\n4. select the events you want to listen to. These should be the same events you're consuming in your webhook which you can find listed in [`src/payment/stripe/webhookPayload.ts`](https://github.com/wasp-lang/open-saas/blob/main/template/app/src/payment/stripe/webhookPayload.ts):\n\n5. after that, go to the webhook you just created and `reveal` the new signing secret.\n6. add this secret to your deployed server's `STRIPE_WEBHOOK_SECRET=` environment variable. <br/>If you've deployed to Fly.io, you can do that easily with the following command:\n```sh\nwasp deploy fly cmd --context server secrets set STRIPE_WEBHOOK_SECRET=whsec_...\n```\n\n### Setting up your Production Lemon Squeezy Webhook\n\nTo set up your Lemon Squeezy webhook, you'll need the URL of you newly deployed server + `/payments-webhook`, e.g. `https://open-saas-wasp-sh-server.fly.dev/payments-webhook`. \n\nWith the webhook url ready, go to your [Lemon Squeezy Webhooks Dashboard](https://app.lemonsqueezy.com/settings/webhooks):\n- click the `+` button.\n- add the webhook forwarding url to the `Callback URL` section.\n- give your webhook a signing secret (a long, random string).\n- add this signing secret to your server's production environment variables under `LEMONSQUEEZY_WEBHOOK_SECRET=`\n- make sure to select at least the following updates to be sent:\n  - order_created\n  - subscription_created\n  - subscription_updated\n  - subscription_cancelled\n- click `save`\n\n## Deploying your Blog\n\nDeploying your Astro Starlight blog is a bit different than deploying your SaaS app. As an example, we will show you how to deploy your blog for free to Netlify. You will need a Netlify account and [Netlify CLI](https://docs.netlify.com/cli/get-started/) installed to follow these instructions.\n\nMake sure you are logged in with Netlify CLI. \n- You can check if you are logged in with `netlify status`, \n- you can log in with `netlify login`.\n\nPosition yourself in the `blog` directory and run the following command:\n\n```sh\nnpm run build\n```\n\nThis will build your blog into the `blog/dist` directory. Now you can deploy your blog to Netlify with the following command:\n\n```sh\nnetlify deploy \n``` \n\nSelect the `dist` directory as the deploy path.\n\nFinally, if the deployment looks good, you can deploy your blog to production with the following command: \n  \n```sh\nnetlify deploy --prod\n```\n\n---\n\n# Email Sending\n\nThis guide explains how to use the integrated email sender and how you can integrate your own account in this template.\n\n## Sending Emails\n\n### The `Dummy` Email Provider (for Local Dev Only)\nBy default we've set up the email sender to use the `Dummy` provider. This is **for local development only** and no emails will actually be sent out!\nTo obtain an email verification token/link, you must check the server logs on initial sign up. You can click this link to verify your email and continue with the sign up process.\n```tsx title=\"main.wasp\"\napp SaaSTemplate {\n  // ...\n  emailSender: {\n    provider: Dummy,\n    defaultFrom: {\n      name: \"Open SaaS App\",\n      email: \"me@example.com\" \n    },\n  },\n```\n\nNote that your app will not build if using the `Dummy` provider and you must switch to a production-ready provider in order to do so.\n\n### Using a Production-Ready Email Provider (e.g. SendGrid)\nTo change your email provider to a production-ready one, such as SendGrid, you'll want to configure your `emailSender` like so:\n\n```tsx title=\"main.wasp\"\napp SaaSTemplate {\n  // ...\n  emailSender: {\n    provider: SendGrid,\n    defaultFrom: {\n      name: \"Open SaaS App\",\n      // When using SendGrid, you must use the same email address that you configured your account to send out emails with!\n      email: \"me@example.com\" \n    },\n  },\n```\n\nThis means that you can send emails from your app using the `send` function from the `email` modul provided by Wasp:\n\n```tsx title=\"src/server/webhooks.ts\"\n\n//...\n\n  if (subscription.cancel_at_period_end) {\n    await emailSender.send({\n      to: customer.email,\n      subject: 'We hate to see you go :(',\n      text: 'We hate to see you go. Here is a sweet offer...',\n      html: 'We hate to see you go. Here is a sweet offer...',\n    });\n  }\n```\n\nIn the example above, you can see that we're sending an email to the customer when we receive a cancel subscription event within the Stripe webhook. \n\nThis is a powerful feature and super simple to use.\n\n## Integrate your email sender\n\nTo set up your email sender, you first need an account with one of the supported email providers.\n\n<Tabs>\n  <TabItem label=\"SendGrid\">\n    - Register at SendGrid.com and then get your [API KEYS](https://app.sendgrid.com/settings/api_keys).\n    - Copy yours to the `.env.server` file under the `SENDGRID_API_KEY` variable. \n\n    Make sure to change the `defaultFrom` email address in the `main.wasp` file to use the same email address that you configured your account to send out emails with!\n\n    ```tsx title=\"main.wasp\" {5}\n    emailSender: {\n      provider: SendGrid,\n      defaultFrom: {\n        name: \"Open SaaS App\",\n        email: \"me@example.com\" // <--- same email address you configured your SendGrid account to send emails with!\n      },\n    ``` \n  </TabItem>\n  <TabItem label=\"Mailgun\">\n    - Go to [Mailgun](https://mailgun.com) and create an account.\n    - Go to [API Keys](https://app.mailgun.com/settings/api_security/api_keys?onboardingTask=api-key) and create a new API key.\n    - Copy the API key and add it to your .env.server file under the `MAILGUN_API_KEY=` variable.\n    - Go to [Domains](https://app.mailgun.com/mg/sending/new-domain?onboardingTask=add-verify-domain) and create a new domain.\n    - Copy the domain and add it to your .env.server file as `MAILGUN_DOMAIN=`.\n\n    Make sure to change the `defaultFrom` email address in the `main.wasp` file to use the same email address that you configured your account to send out emails with!\n\n    ```tsx title=\"main.wasp\" {5}\n    emailSender: {\n      provider: Mailgun,\n      defaultFrom: {\n        name: \"Open SaaS App\",\n        email: \"me@example.com\" // <--- same email address you configured your Mailgun account to send emails with!\n      },\n    ```\n  </TabItem>\n</Tabs>\n\nIf you want more detailed info, or would like to use SMTP, check out the [Wasp docs](https://wasp.sh/docs/advanced/email).\n\n---\n\n# File Uploading\n\nThis guide will show you how to set up file uploading in your SaaS app.\n\nThere are two options we recommend:\n1. Using [AWS S3](https://aws.amazon.com/s3/) with presigned URLS for secure file storage\n2. Using Multer middleware to upload files to your own server\n\n**We recommend using AWS S3 as it's a scalable, secure option, that can handle a large amount of storage.** \n\nIf you're just looking to upload small files and don't expect your app to grow to a large scale, you can use Multer to upload files to your app's server.\n\n:::tip[Star our Repo on GitHub! ]\nWe've packed in a ton of features and love into this SaaS starter, and offer it all to you for free!\n\nIf you're finding this template and its guides useful, consider giving us [a star on GitHub](https://github.com/wasp-lang/wasp)\n:::\n\n## Using AWS S3\n\n### How presigned URLs work\n\nPresigned URLs are URLs that have been signed with your AWS credentials and can be used to upload files to your S3 bucket. They are time-limited and can be generated on the server and sent to the client to upload files directly to S3.\n\nThe process of generating a presigned URL is as follows:\n1. The client sends a request to the server to upload a file\n2. The server generates a presigned URL using its AWS credentials\n3. The server sends the presigned URL to the client\n4. The client uses the presigned URL to upload the file directly to S3 before the URL expires\n\nWe use this method to upload files to S3 because it is more secure than uploading files directly from the client to S3. It also allows us to keep our AWS credentials private and not expose them to the client.\n\nTo use presigned URLs, we'll need to set up an S3 bucket and get our AWS credentials.\n\n### Create an AWS Account\n\nBefore you begin, you'll need to create an AWS account. AWS accounts are free to create and are split up into:\n1. Root account\n2. IAM users\n\nYou'll need to first create a root account, and then an IAM user for your SaaS app before you can start uploading files to S3.\n\nTo do so, follow the steps in this external guide: [Creating IAM users and S3 buckets in AWS](https://medium.com/@emmanuelnwright/create-iam-users-and-s3-buckets-in-aws-264e78281f7f)\n\n### Create an AWS S3 Bucket\n\nOnce you are logged in with your IAM user, you'll need to create an S3 bucket to store your files.\n\n1. Navigate to the S3 service in the AWS console\n    \n2. Click on the `Create bucket` button\n    \n3. Fill in the bucket name and region\n4. **Leave all the settings as default** and click `Create bucket`\n    \n\n### Change the CORS settings\n\nNow we need to change some permissions on the bucket to allow for file uploads from your app.\n\n1. Click on the bucket you just created\n    \n2. Click on the `Permissions` tab\n    \n3. Scroll down to the `Cross-origin resource sharing (CORS)` section and click `Edit`\n    \n5. Insert the correct CORS configuration and click `Save changes`. You can\n   copy-paste most of the config below, but **you must edit the\n   `AllowedOrigins` field** to fit your app. Include `http://localhost:3000` for\n   local development, and `https://<your domain>` for production.\n\n   If you don't yet have a domain name, just list `http://localhost:3000` for\n   now. We'll remind you to add your domain before deploying to production in\n   the [Deployment docs](/guides/deploying/#aws-s3-cors-configuration).\n   ```json {11,12}\n   [\n       {\n           \"AllowedHeaders\": [\n               \"*\"\n           ],\n           \"AllowedMethods\": [\n               \"POST\",\n               \"GET\"\n           ],\n           \"AllowedOrigins\": [\n               \"http://localhost:3000\",\n               \"https://<your-domain>\"\n           ],\n           \"ExposeHeaders\": []\n       }\n   ]\n   ```\n\n### Get your AWS S3 credentials\n\nNow that you have your S3 bucket set up, you'll need to get your S3 credentials to use in your app.\n\n1. Click on your username in the top right corner of the AWS console and select `Security Credentials`\n    \n2. Scroll down to the `Access keys` section\n3. Click on `Create Access Key`\n4. Select the `Application running on an AWS service` option and create the access key\n    \n5. Copy the `Access key ID` and `Secret access key` and paste them in your `src/app/.env.server` file: \n```sh\n  AWS_S3_IAM_ACCESS_KEY=ACK...\n  AWS_S3_IAM_SECRET_KEY=t+33a...\n  AWS_S3_FILES_BUCKET=your-bucket-name\n  AWS_S3_REGION=your-region // (e.g. us-west-2)\n```\n\n:::tip[Star our Repo on GitHub! ]\nWe've packed in a ton of features and love into this SaaS starter, and offer it all to you for free!\n\nIf you're finding this template and its guides useful, consider giving us [a star on GitHub](https://github.com/wasp-lang/wasp)\n:::\n\n### Using and Customizing File Uploads with S3 in your App\n\nWith your S3 bucket set up and your AWS credentials in place, you can now start uploading files in your app using presigned URLs by navigating to `localhost:3000/file-upload` and uploading a file.\n\nTo begin customizing file uploads, is important to know where everything lives in your app. Here's a quick overview:\n- `main.wasp`:\n  - The `File entity` can be found here. Here you can modify the fields to suit your needs.\n- `src/file-upload/FileUploadPage.tsx`:\n  - The `FileUploadPage` component is where the file upload form lives. It also allows you to download the file from S3 by calling the `getDownloadFileSignedURL` based on that files `key` in the app DB.\n- `src/file-upload/operations.ts`:\n  - The `createFile` action lives here and calls the `getUploadFileSignedURLFromS3` within it using your AWS credentials before passing it to the client. This function stores the files in the S3 bucket within folders named after the user's ID, so that each user's files are stored separately.\n  - The `getAllFilesByUser` fetches all File information uploaded by the user. Note that the files do not exist in the app database, but rather the file data, its name and its `key`, which is used to fetch the file from S3.\n  - The `getDownloadFileSignedURL` query fetches the presigned URL for a file to be downloaded from S3 using the file's `key` stored in the app's database.\n\n## Using Multer to upload files to your server\n\nIf you're looking to upload files to the app server, you can use the Multer middleware to handle file uploads. This will allow you to store files on your server and is a good option if you need a quick and dirty, free solution for simple file uploads.\n\nBelow are GitHub Gists that show you how to set up file uploads using Multer in your app:\n\n### Wasp version 0.12 & higher\n\n<script src=\"https://gist.github.com/infomiho/ec379df4e33f3ae3410a251ba3aa81af.js\"></script>\n\n---\n\n# Payments Integration\n\nThis guide will show you how to set up Payments for testing and local development with the following payment processors:\n- Stripe\n- Lemon Squeezy\n\n:::note[Which should I choose?]\nStripe is the industry standard, is more configurable, and has cheaper fees.\nLemon Squeezy acts a [Merchant of Record](https://www.lemonsqueezy.com/reporting/merchant-of-record). This means they take care of paying taxes in multiple countries for you, but charge higher fees per transaction. \n:::\n\n## Important First Steps\n\nFirst, go to `/src/payment/paymentProcessor.ts` and choose which payment processor you'd like to use, e.g. Stripe or Lemon Squeezy:\n\n```ts title=\"src/payment/paymentProcessor.ts\" ins={5, 7}\n\n//...\n\nexport const paymentProcessor: PaymentProcessor = stripePaymentProcessor;\n// or... \nexport const paymentProcessor: PaymentProcessor = lemonSqueezyPaymentProcessor;\n```\n\nAt this point, you can delete:\n- the unused payment processor code within the `/src/payment/<unused-provider>` directory, \n- any unused environment variables from `.env.server` (they will be prefixed with the name of the provider your are not using):\n  - e.g. `STRIPE_API_KEY`, `STRIPE_CUSTOMER_PORTAL_URL`, `LEMONSQUEEZY_API_KEY`, `LEMONSQUEEZY_WEBHOOK_SECRET`\n- Make sure to also uninstall the unused dependencies:\n  - `npm uninstall @lemonsqueezy/lemonsqueezy.js`\n  - or\n  - `npm uninstall stripe`\n- Remove any unused fields from the `User` model in the `schema.prisma` file if they exist:\n  - e.g. `lemonSqueezyCustomerPortalUrl`\n\nNow your code is ready to go with your preferred payment processor and it's time to configure your payment processor's API keys, products, and other settings.\n\n## Stripe\n\nFirst, you'll need to create a Stripe account. You can do that [here](https://dashboard.stripe.com/register).\n\n:::tip[Star our Repo on GitHub! ]\nWe've packed in a ton of features and love into this SaaS starter, and offer it all to you for free!\n\nIf you're finding this template and its guides useful, consider giving us [a star on GitHub](https://github.com/wasp-lang/wasp)\n:::\n\n### Get your test Stripe API Keys\n\nOnce you've created your account, you'll need to get your test API keys. You can do that by navigating to [https://dashboard.stripe.com/test/apikeys](https://dashboard.stripe.com/test/apikeys) or by going to the [Stripe Dashboard](https://dashboard.stripe.com/test/dashboard) and clicking on the `Developers`.\n\n- Click on the `Reveal test key token` button and copy the `Secret key`.\n- Paste it in your `.env.server` file under `STRIPE_API_KEY=`\n\n### Create Test Products\n\nTo create a test product, go to the test products url [https://dashboard.stripe.com/test/products](https://dashboard.stripe.com/test/products), or after navigating to your dashboard, click the `test mode` toggle.\n\n- Click on the `Add a product` button and fill in the relevant information for your product. \n- Make sure you select `Software as a service (SaaS)` as the product type.\n- For Subscription products, make sure you select `Recurring` as the billing type.\n- For One-time payment products, make sure you select `One-time` as the billing type.\n- If you intend to let your users switch between two subscription plans, e.g. upgrade from hobby to pro, you'll need to create two separate products and with their own price IDs. The ability for users to swich plans can then be configured later in the [Customer Portal](#set-up-the-customer-portal).\n- If you want to add different price tiers for the same product (e.g. monthly and yearly), click the `Add another price` button at the buttom. \n\n- After you save the product, you'll be directed to the product page. \n- Copy the price IDs and paste them in the `.env.server` file\n  - We've set you up with two example subscription product environment variables, `PAYMENTS_HOBBY_SUBSCRIPTION_PLAN_ID=` and `PAYMENTS_PRO_SUBSCRIPTION_PLAN_ID=`.\n  - As well as a one-time payment product/credits-based environment variable, `PAYMENTS_CREDITS_10_PLAN_ID=`.\n- Note that if you change the names of the price IDs, you'll need to update your server code to match these names as well\n\n### Create a Test Customer\n\nTo create a test customer, go to the test customers url [https://dashboard.stripe.com/test/customers](https://dashboard.stripe.com/test/customers).\n\n- Click on the `Add a customer` button and fill in the relevant information for your test customer.\n:::note\n When filling in the test customer email address, use an address you have access to and will use when logging into your SaaS app. This is important because the email address is used to identify the customer when creating a subscription and allows you to manage your test user's payments/subscriptions via the test customer portal\n:::\n\n### Set up the Customer Portal\n\nGo to https://dashboard.stripe.com/test/settings/billing/portal in the Stripe Dashboard and activate and copy the `Customer portal link`. Paste it in your `.env.server` file:\n\n```ts title=\".env.server\"\nSTRIPE_CUSTOMER_PORTAL_URL=<your-test-customer-portal-link>\n```\n\nIf you'd like to give users the ability to switch between different plans, e.g. upgrade from a hobby to a pro subscription, go down to the `Subscriptions` dropdown and select `customers can switch plans`. \n\nThen select the products you'd like them to be able to switch between.\n\nNow, after your users have paid, they can click on `Manage Subscription` in the client and will be taken to the customer portal where they can update their current plan.\n\n### Install the Stripe CLI\n\nTo install the Stripe CLI with homebrew, run the following command in your terminal:\n\n```sh\nbrew install stripe/stripe-cli/stripe\n```\n\nor for other install scripts or OSes, follow the instructions [here](https://stripe.com/docs/stripe-cli#install).\n\nNow, let's start the webhook server and get our webhook signing secret.\n\nFirst, login:\n```sh\nstripe login\n```\n\n:::caution[Errors running the Stripe CLI]\nIf you're seeing errors, consider appending `sudo` to the stripe commands.\nSee this [GitHuh issue](https://github.com/stripe/stripe-cli/issues/933) for more details.\n:::\n\n```sh\nstripe listen --forward-to localhost:3001/payments-webhook\n```\n\nYou should see a message like this:\n\n```sh\n> Ready! You are using Stripe API Version [2023-08-16]. Your webhook signing secret is whsec_8a... (^C to quit)\n```\n\ncopy this secret to your `.env.server` file under `STRIPE_WEBHOOK_SECRET=`.\n\n### Testing Webhooks via the Stripe CLI\n\n- In a new terminal window, run the following command:\n\n```sh\nstripe login\n```\n\n- start the Stripe CLI webhook forwarding on port 3001 where your Node server is running. \n\n```sh\nstripe listen --forward-to localhost:3001/payments-webhook\n```\n\n:::caution[Webhook URL]\nIn older versions of this template, the webhook URL was `http://localhost:3001/stripe-webhook`.\nIf you're using an older version, **make sure to use the url that matches the webhook url in your `main.wasp` file payemnts API definition.**\n:::\n\nremember to copy and paste the outputted webhook signing secret (`whsec_...`) into your `.env.server` file under `STRIPE_WEBHOOK_SECRET=` if you haven't already.\n\n- In another terminal window, trigger a test event:\n\n```sh\nstripe trigger payment_intent.succeeded\n```\n\nThe results of the event firing will be visible in the initial terminal window. You should see messages like this:\n\n```sh\n...\n2023-11-21 09:31:09   --> invoice.paid [evt_1OEpMPILOQf67J5TjrUgRpk4]\n2023-11-21 09:31:09  <--  [200] POST http://localhost:3001/payments-webhook [evt_1OEpMPILOQf67J5TjrUgRpk4]\n2023-11-21 09:31:10   --> invoice.payment_succeeded [evt_1OEpMPILOQf67J5T3MFBr1bq]\n2023-11-21 09:31:10  <--  [200] POST http://localhost:3001/payments-webhook [evt_1OEpMPILOQf67J5T3MFBr1bq]\n2023-11-21 09:31:10   --> checkout.session.completed [evt_1OEpMQILOQf67J5ThTZ0999r]\n2023-11-21 09:31:11  <--  [200] POST http://localhost:3001/payments-webhook [evt_1OEpMQILOQf67J5ThTZ0999r]\n```\n\nFor more info on testing webhooks, check out https://stripe.com/docs/webhooks#test-webhook\n\n:::tip[Star our Repo on GitHub! ]\nWe've packed in a ton of features and love into this SaaS starter, and offer it all to you for free!\n\nIf you're finding this template and its guides useful, consider giving us [a star on GitHub](https://github.com/wasp-lang/wasp)\n:::\n\n### Testing Checkout and Payments via the Client\n\nMake sure the **Stripe CLI is running** by following the steps above.\nYou can then test the payment flow via the client by doing the following:\n\n- Click on a Buy button on the for any of the products on the homepage. You should be redirected to the checkout page.\n- Fill in the form with the following test credit card number `4242 4242 4242 4242` and any future date for the expiration date and any 3 digits for the CVC.\n\n- Click on the \"Pay\" button. You should be redirected to the success page.\n\n- Check your terminal window for status messages and logs\n\n- You can also check your Database via the DB Studio to see if the user entity has been updated by running:\n\n```sh\nwasp db studio\n```\n\n- Navigate to `localhost:5555` and click on the `users` table. You should see the `subscriptionStatus` is `active` for the user that just made the purchase.\n\n:::note\nIf you want to learn more about how a user's payment status, subscription status, and subscription tier affect a user's priveledges within the app, check out the [User Overview](/general/user-overview) reference.\n:::\n\n## Lemon Squeezy\n\nFirst, make sure you've defined your payment processor in `src/payment/paymentProcessor.ts`, as described in the [important first steps](#important-first-steps).\n\nNext, you'll need to create a Lemon Squeezy account in test mode. You can do that [here](https://lemonsqueezy.com).\n\n:::tip[Star our Repo on GitHub! ]\nWe've packed in a ton of features and love into this SaaS starter, and offer it all to you for free!\n\nIf you're finding this template and its guides useful, consider giving us [a star on GitHub](https://github.com/wasp-lang/wasp)\n:::\n\n### Get your test Lemon Squeezy API Keys\n\nOnce you've created your account, you'll need to get your test API keys. You can do that by navigating to [https://app.lemonsqueezy.com/settings/api](https://app.lemonsqueezy.com/settings/api) and creating a new API key.\n\n- Click on the `+` button\n- Give your API key a name\n- Copy and paste it in your `.env.server` file under `LEMONSQUEEZY_API_KEY=`\n\n### Get your Lemon Squeezy Store ID\n\nTo get your store ID, go to the [Lemon Squeezy Dashboard](https://app.lemonsqueezy.com/settings/stores) and copy the `Store ID` from the top right corner.\n\nCopy and paste this number in your `.env.server` file under `LEMONSQUEEZY_STORE_ID=`\n\n### Create Test Products\n\nTo create a test product, go to the test products url [https://app.lemonsqueezy.com/products](https://app.lemonsqueezy.com/products).\n\n- Click on the `+ New Product` button and fill in the relevant information for your product. \n- Fill in the general information.\n- For pricing, select the type of product you'd like to create, e.g. `Subscription` for a recurring monthly payment product or  `Single Payment` for credits-based product.\n\n- Make sure you select `Software as a service (SaaS)` as the Tax category type.\n- If you want to add different price tiers for `Subscription` products, click on `add variant` under the `variants` tab. Here you can input the name of the variant (e.g. \"Hobby\", \"Pro\"), and that variant's price.\n\n- For a product with no variants, on the product page, click the `...` menu button and select `Copy variant ID`\n\n- For a product with variants, on the product page, click on the product, go to the variants tab and select `Copy ID` for each variant.\n\n- Paste these IDs in the `.env.server` file:\n  - We've set you up with two example subscription product environment variables, `PAYMENTS_HOBBY_SUBSCRIPTION_PLAN_ID=` and `PAYMENTS_PRO_SUBSCRIPTION_PLAN_ID=`.\n  - As well as a one-time payment product/credits-based environment variable, `PAYMENTS_CREDITS__10_PLAN_ID=`.\n- Note that if you change the names of the these environment variables, you'll need to update your app code to match these names as well.\n\n### Create and Use the Lemon Squeezy Webhook in Local Development\n\nLemon Squeezy sends messages/updates to your Wasp app via its webhook, e.g. when a payment is successful. For that to work during development, we need to expose our locally running (via `wasp start`) Wasp app and make it available online, specifically the server part of it. Since the Wasp server runs on port 3001, you should run ngrok on port 3001, which will provide you with a public URL that you can use to configure Lemon Squeezy with.\n\nTo do this, first make sure you have installed [ngrok](https://ngrok.com/docs/getting-started/).\n\nOnce installed, and with your wasp app running, run:\n```sh\nngrok http 3001\n```\n\nNgrok will output a forwarding address for you. Copy and paste this address and add `/payments-webhook` to the end (this URL path has been configured for you already in `main.wasp` under the `api paymentsWebhook` definition). It should look something like this: \n\n```sh title=\"Callback URL\"\nhttps://89e5-2003-c7-153c-72a5-f837.ngrok-free.app/payments-webhook\n```\n\nNow go to your [Lemon Squeezy Webhooks Dashboard](https://app.lemonsqueezy.com/settings/webhooks):\n- click the `+` button.\n- add the newly created webhook forwarding url to the `Callback URL` section.\n- give your webhook a signing secret (a long, random string).\n- copy and paste this same signing secret into your `.env.server` file under `LEMONSQUEEZY_WEBHOOK_SECRET=`\n- make sure to select at least the following updates to be sent:\n  - order_created\n  - subscription_created\n  - subscription_updated\n  - subscription_cancelled\n- click `save`\n\nYou're now ready to start consuming Lemon Squeezy webhook events in local development.\n\n## Deploying\n\nOnce you deploy your app, you can follow the same steps, just make sure that you are no longer in test mode within the Stripe or Lemon Squeezy Dashboards. After you've repeated the steps in live mode, add the new API keys and price/variant IDs to your environment variables in your deployed environment.\n\n---\n\n# SEO\n\nThis guides explains how to improve SEO for of your app\n\n## Landing Page Meta Tags\n\nWasp gives you the ability to add meta tags to your landing page HTML via the `main.wasp` file's `head` property:\n\n```js {8-11}\napp SaaSTemplate {\n  wasp: {\n    version: \"^0.13.0\"\n  },\n  title: \"Open SaaS\",\n  head: [\n        \"<meta property='og:type' content='website' />\",\n        \"<meta property='og:url' content='https://opensaas.sh' />\",\n        \"<meta property='og:title' content='Open SaaS' />\",\n        \"<meta property='og:description' content='Free, open-source SaaS boilerplate starter for React & NodeJS.' />\",\n        \"<meta property='og:image' content='https://opensaas.sh/public-banner.webp' />\",\n        //...\n  ],\n  //...\n```\n\nChange the above highlighted meta tags to match your app. Wasp will inject these tags into the HTML of your `index.html` file, which is the Landing Page (`app/src/client/landing-page/LandingPage.tsx`), in this case.\n\nThis means you **do not** need to rely on a separate app or framework to serve your landing page for SEO purposes.\n\n:::tip[Star our Repo on GitHub! ]\nWe've packed in a ton of features and love into this SaaS starter, and offer it all to you for free!\n\nIf you're finding this template and its guides useful, consider giving us [a star on GitHub](https://github.com/wasp-lang/wasp)\n:::\n\n## Docs & Blog Meta Tags\n\nAstro, being a static-site generator, will automatically inject relevant information provided in the `blog/astro.config.mjs` file, as well as in the frontmatter of `.md` files into the pages HTML:\n\n```yaml\n---\ntitle: 'My First Blog Post'\npubDate: 2022-07-01\ndescription: 'This is the first post of my new Astro blog.'\nauthor: 'Astro Learner'\nimage:\n    url: 'https://docs.astro.build/assets/full-logo-light.png'\n    alt: 'The full Astro logo.'\ntags: [\"astro\", \"blogging\", \"learning in public\"]\n---\n```\n\nImproving your SEO is as simple as adding these properties to your docs and blog content!\n\n## A Word on SSR & SEO\n\nOpen SaaS and Wasp do not currently have a SSR option (although it is coming soon!), but that does not mean that Open SaaS apps are at a disadvantage with regards to SEO.\n\nThat's because the meta tags for the landing page (described above), plus the Astro docs/blog provided with Open SaaS are more than enough! Not to mention, Google is also able to crawl websites with JavaScript activated, making SSR unnecessary. \n\nFor example, try searching \"Open SaaS\" on Google and you'll see this App, which was built with this template, as the first result!\n\n---\n\n# Tests\n\nThis guide will show you how to use the included end-to-end (e2e) tests for your Open SaaS application.\n\n## The Tests Directory\n\nIn the root of your project, you'll find an `e2e-tests` directory which contains the [Playwright](https://playwright.dev) tests for your Open SaaS application.:\n\n```\n.\n e2e-tests/\n    tests/                  # Directory containing the test files\n    README.md               # Instructions on how to run the tests\n    ci-start-app-and-db.js  # Script to start the app and db for CI\n    playwright.config.ts    # Playwright configuration\n    package.json\n    ...\n```\n\nTo run the tests locally, or in a CI pipeline, follow the instructions in the `README.md` file in the `e2e-tests` directory.\n\n## Using Tests in CI with GitHub Actions\nAlthough the Open SaaS template does not come with an example workflow, you can find one at `.github/workflows/e2e-tests.yml` of the [remote repo](https://github.com/wasp-lang/open-saas).\n\nYou can copy and paste the `.github/` directory containing the `e2e-tests.yml` workflow into the root of your own repository to run the tests as part of your CI pipeline.\n\n:::caution[WASP_VERSION]\nPlease make sure to update the `WASP_VERSION` environment variable in the `e2e-tests.yml` file to match the version of Wasp you are using in your project.\n:::\n\nIn order for these tests to run correctly on GitHub, you need to provide the environment variables mentioned in the `e2e-tests.yml` file within your GitHub repository's \"Actions\" secrets so that they can be accessed by the tests.\n\n---\n\n# How (Not) to Update Your Open SaaS App\n\n:::danger[We advise against merging the latest template changes into your app]\nIf you've already started building your app, we generally advise against merging the latest template changes into your app.\n\nBelow we outline our reasoning why, and provide a basic guide to help you update your app if you decide to do so anyway.\n:::\n\n## Why you probably shouldn't include the latest template changes in your app\n\nWe generally **advise against updating your Open SaaS-based applications** after initial setup. \n\nWhy? \n\nBecause your codebase will naturally diverge from the template as you build your unique application, and any updates we may make to the template may not be compatible with your modified codebase, or your version of Wasp.\n\nEven if you *really* want to include a new feature from the template in your app, proceed with caution and thoroughly consider the following:\n\n- Changes to the template may be tightly coupled. Implementing one change without related ones could cause unexpected issues.\n- Updates might not be compatible with your version of Wasp.\n- The more your codebase has diverged, the more challenging the update will be.\n\n## If you still decide to update your app\n\nIf you read above, considered the risks, and still need specific improvements, we recommend that you manually merge the changes.\n\nTo do this, you should can either 1) merge new Open SaaS template changes into your current project, or 2) merge project changes into a fresh Open SaaS template.\n\n1) Merge new Open SaaS template changes into your current project by:\n- reviewing the latest commits, \n- understanding what happened, \n- being mindful of the Wasp version you're using,\n- and then fitting those changes into your own codebase.\n\n2) Merge your project changes into a fresh Open SaaS template by:\n- starting a new, fresh project with the latest Open SaaS template,\n- and then copying over the logic from your existing project that you want to keep.\n\nThe method you choose is up to you and will largely depend on the complexity of the changes you need to make.\n\n---\n\n# Vibe Coding with Open SaaS\n\nIf you're looking to use AI to help build (or \"vibe code\") your SaaS app, this guide is for you.\n\n## Coding with AI, Open SaaS, & Wasp\n\nWasp is particularly well suited to coding with AI due to its central config file which gives LLMs context about the entire full-stack app, and its ability to manage boilerplate code so AI doesn't have to. \n\nRegardless, there are still some shortcomings to using AI to code with Wasp, as well as a learning curve to using it effectively.\n\nLuckily, we did the work for you and put together a bunch of resources to help you use Wasp & Open SaaS with AI as effectively as possible.\n\n### AI Resources in the Template\n\nThe template comes with:\n- A full set of rules files, `app/.cursor/rules`, to be used with Cursor or adapted to your coding tool of choice (Windsurf, Claude Code, etc.).\n- A set of example prompts, `app/.cursor/example-prompts.md`, to help you get started.\n\n### LLM-Friendly Documentation\n\nWe've also created a bunch of LLM-friendly documentation:\n- [Open SaaS Docs - LLMs.txt](https://docs.opensaas.sh/llms.txt) - Links to the raw text docs.\n- **[Open SaaS Docs - LLMs-full.txt](https://docs.opensaas.sh/llms-full.txt) - Complete docs as one text file.** \n- Coming Soon! ~~[Wasp Docs - LLMs.txt](https://wasp.sh/llms.txt)~~ - Links to the raw text docs.\n- Coming Soon! ~~[Wasp Docs - LLMs-full.txt](https://wasp.sh/llms-full.txt)~~ - Complete docs as one text file.\n\nAdd these to your AI-assisted IDE settings so you can easily reference them in your chat sessions with the LLM.\n**In most cases, you'll want to pass the `llms-full.txt` to the LLM and ask it to help you with a specific task.**\n\n### More AI-assisted Coding Learning Resources\n\nHere's a list of articles and tutorials we've made:\n- [3hr YouTube tutorial: Vibe Coding a Personal Finance App w/ Wasp & Cursor](https://www.youtube.com/watch?v=WYzEROo7reY)\n- [Article: A Structured Workflow for \"Vibe Coding\" Full-Stack Apps](https://dev.to/wasp/a-structured-workflow-for-vibe-coding-full-stack-apps-352l)\n\n---\n\n# Admin Dashboard\n\nThis is a reference on how the Admin dashboard, available at `/admin`, is set up.\n\n## Permissions\n\nThe Admin dashboard is only accessible to users with the `isAdmin` field set to true.\n\n```tsx title=\"schema.prisma\" {5}\nmodel User {\n  id                        Int             @id @default(autoincrement())\n  email                     String?         @unique\n  username                  String?\n  isAdmin                   Boolean         @default(false)\n  //...\n```\n\nTo give yourself administrator priveledges, make sure you add your email addresses to the `ADMIN_EMAILS` environment variable in `.env.server` file before registering/logging in with that email address:\n```sh title=\".env.server\"\nADMIN_EMAILS=me@example.com\n\n// or add many admins with a comma-separated list\n\nADMIN_EMAILS=me@example.com,you@example.com,them@example.com\n```\n\nOr if you've already logged in with an email address that you want to give admin priveledges to, you can run the following command in a separate terminal window to update the user's `isAdmin` field manually:\n\n```sh\nwasp db studio\n```\n\n---\n\n:::tip[Star our Repo on GitHub! ]\nWe've packed in a ton of features and love into this SaaS starter, and offer it all to you for free!\n\nIf you're finding this template and its guides useful, consider giving us [a star on GitHub](https://github.com/wasp-lang/wasp)\n:::\n\n## Admin Dashboard Pages\n\n### Analytics Dashboard\nThe Admin analytics dashboard is a single place for you to view your most important metrics and perform some admin tasks. At the moment, it pulls data from:\n\n- [Payments Processor](/guides/payments-integration/):\n  - total revenue\n  - revenue for each day of the past week\n- [Google or Plausible](/guides/analytics/): \n  - total number of page views (non-unique)\n  - percentage change in page views from the previous day\n  - top sources/referrers with unique visitor count (i.e. how many people came from that source to your app)\n- Database:\n  - total number of registered users\n  - daily change in number of registered users \n  - total number of paying users\n  - daily change in number of paying users\n\nThese metrics are aggregated within the background job `dailyStatsJob`, which by default is run every hour. You can change the frequency of this job by modifying its `cron` field:\n\n```ts title=\"main.wasp\" {8,7}\njob dailyStatsJob {\n  executor: PgBoss,\n  perform: {\n    fn: import { calculateDailyStats } from \"@src/analytics/stats\"\n  },\n  schedule: {\n    cron: \"0 * * * *\" // every hour. useful in production\n    // cron: \"* * * * *\" // every minute. useful for debugging\n  },\n  entities: [User, DailyStats, Logs, PageViewSource]\n}\n```\nFor more info on Wasp's recurring background jobs, check out the [Wasp Jobs docs](https://wasp.sh/docs/advanced/jobs).\n\nFor a guide on how to integrate these services so that you can view your analytics via the dashboard, check out the [Payments Integration](/guides/payments-integration/) and [Analytics guide](/guides/analytics/) of the docs.\n\n:::note[Help us improve]\nWe're always looking to improve the Admin dashboard. If you feel something is missing or could be improved, consider [opening an issue](https://github.com/wasp-lang/open-saas/issues) or [submitting a pull request](https://github.com/wasp-lang/open-saas/pulls)\n:::\n\n### Users\nThe Users page is where you can view all your users and their most important details. You can also search and filter users by:\n- email address\n- subscription/payment status\n- admin status\n\n---\n\n# User Overview\n\nThis reference will help you understand how the User entity works in this template.\nThis includes the user roles, subscription plans and statuses, and how to authorize access to certain pages and components.\n\n## User Entity\n\nThe `User` entity within your app is defined in the `schema.prisma` file:\n\n```tsx title=\"schema.prisma\" ins=\"User: {}\"\nmodel User {\n  id                        Int             @id @default(autoincrement())\n  email                     String?         @unique\n  username                  String?         \n  createdAt                 DateTime        @default(now())\n  isAdmin                   Boolean         @default(false)\n  paymentProcessorUserId    String?         @unique\n  lemonSqueezyCustomerPortalUrl String?     // You can delete this if you're not using Lemon Squeezy as your payments processor.\n  subscriptionPlan          String?\n  subscriptionStatus        String?\n  sendEmail                 Boolean         @default(false)\n  datePaid                  DateTime?\n  credits                   Int             @default(3)\n  gptResponses              GptResponse[]\n  contactFormMessages       ContactFormMessage[]\n  tasks                     Task[]\n  files                     File[] \n}\n```\n\nWe store all pertinent information to the user, including identification, subscription, and payment processor information. Meanwhile, Wasp abstracts away all the Auth related entities dealing with `passwords`, `sessions`, and `socialLogins`, so you don't have to worry about these at all in your Prisma schema (if you want to learn more about this process, check out the [Wasp Auth Docs](https://wasp.sh/docs/auth/overview)).\n\n## Stripe and Subscriptions\n\nWe use Stripe to handle all of our subscription payments. The `User` entity has a number of fields that are related to Stripe and their ability to access features behind the paywall:\n\n```tsx title=\"schema.prisma\" {4-10}\nmodel User {\n  id                        Int             @id @default(autoincrement())\n  //...\n  paymentProcessorUserId    String?         @unique\n  subscriptionPlan          String?\n  subscriptionStatus        String?\n  datePaid                  DateTime?\n  credits                   Int             @default(3)\n  //...\n}\n```\n\n- `paymentProcessorUserId`: The payment processor customer ID. This is created on checkout and used to identify the customer.\n- `subscriptionPlan`: The subscription plan the user is on. This is set by the app and is used to determine what features the user has access to. By default, we have three plans: `hobby` and `pro` subscription plans, as well as a `credits10` one-time purchase plan.\n- `subscriptionStatus`: The subscription status of the user. This is set by the payment processor and is used to determine whether the user has access to the app or not. By default, we have four statuses: `active`, `past_due`, `cancel_at_period_end`, and `deleted`.\n- `credits` (optional): By default, a user is given 3 credits to trial your product before they have to pay. You can create a one-time purchase product in Stripe to allow users to purchase more credits if they run out, e.g. the `credits10` plan in the template.\n\n### Subscription Statuses\n\nIn general, we determine if a user has paid for an initial subscription by checking if the `subscriptionStatus` field is set. This field is set by Stripe within your webhook handler and is used to signify more detailed information on the user's current status. By default, the template handles four statuses: `active`, `past_due`, `cancel_at_period_end`, and `deleted`.\n\n- When `active` the user has paid for a subscription and has full access to the app. \n\n- When `cancel_at_period_end`, the user has canceled their subscription and has access to the app until the end of their billing period. \n\n- When `deleted`, the user has reached the end of their subscription period after canceling and no longer has access to the app.\n\n- When `past_due`, the user's automatic subscription renewal payment was declined (e.g. their credit card expired). You can choose how to handle this status within your app. For example, you can send the user an email to update their payment information:\n```tsx title=\"src/payment/stripe/webhook.ts\" \n\n//...\n\nif (subscription.status === 'past_due') {\n  const updatedCustomer = await context.entities.User.update({\n    where: {\n      id: customer.id,\n    },\n    data: {\n      subscriptionStatus: 'past_due',\n    },\n  });\n\n  if (updatedCustomer.email) {\n    await emailSender.send({\n      to: updatedCustomer.email,\n      subject: 'Your Payment is Past Due',\n      text: 'Please update your payment information to continue using our service.',\n      html: '...',\n    });\n  }\n}\n```\n\nSee the client-side [authorization section](/guides/authorization/) below for more info on how to handle these statuses within your app.\n\n### Subscription Plans\n\nThe `subscriptionPlan` field is used to determine what features the user has access to. \n\nBy default, we have three plans: `hobby` and `pro` subscription plans, as well as a `credits10` one-time purchase plan. \n\nYou can add more plans by adding more products and price IDs to your Stripe product and updating environment variables in your `.env.server` file as well as the relevant code in your app.\n\nSee the [Payments Integration Guide](/guides/payments-integration/) for more info on how to do this.\n\n## User Roles\n\nAt the moment, we have two user roles: `admin` and `user`. This is defined within the `isAdmin` field in the `User` entity:\n\n```tsx title=\"schema.prisma\" {7}\nmodel User {\n  id                        Int             @id @default(autoincrement())\n  email                     String?         @unique\n  username                  String?\n  createdAt                 DateTime        @default(now())\n  isAdmin                   Boolean         @default(false)\n//...\n}\n```\n\nAs an Admin, a user has access to the Admin dashboard, along with the user table where they can view and search for users, and edit and update information manually if necessary.\n\n:::tip[Admin Privileges]\nIf you'd like to give yourself and/or certain users admin privileges, follow the instructions in the [Admin Dashboard](/general/admin-dashboard/#permissions) section.\n:::\n\nAs a general User, a user has access to the user-facing app that sits behind the login, but not the Admin dashboard. You can further restrict access to certain features within the app by following the [authorization guide](/guides/authorization/).\n\n---",
        "namespace": "xtasker",
        "timestamp": 1754702520372
      },
      {
        "key": "waspfull_aa",
        "value": "# Getting Started\n\n## Introduction\n\n<HiddenLLMHelper />\n\n:::note\nIf you are looking for the installation instructions, check out the [Quick Start](./quick-start.md) section.\n:::\n\nWe will give a brief overview of what Wasp is, how it works on a high level and when to use it.\n\n### Wasp is a tool to build modern web applications\n\nIt is an opinionated way of building **full-stack web applications**. It takes care of all three\nmajor parts of a web application: **client** (front-end), **server** (back-end) and **database**.\n\n#### Works well with your existing stack\n\nWasp is not trying to do everything at once but rather focuses on the complexity that arises from connecting all the parts of the stack (client, server, database, deployment).\n\nWasp is using **React**, **Node.js** and **Prisma** under the hood and relies on them to define web components and server queries and actions.\n\n#### Wasp's secret sauce\n\nAt the core is the Wasp compiler which takes the Wasp config and your Javascript code and outputs the client app, server app and deployment code.\n\n<ImgWithCaption source=\"/img/lp/wasp-compilation-diagram.png\" caption=\"How the magic happens 🌈\" />\n\nThe cool thing about having a compiler that understands your code is that it can do a lot of things for you.\n\nDefine your app in the Wasp config and get:\n\n- login and signup with Auth UI components,\n- full-stack type safety,\n- e-mail sending,\n- async processing jobs,\n- React Query powered data fetching,\n- security best practices,\n- and more.\n\nYou don't need to write any code for these features, Wasp will take care of it for you 🤯 And what's even better, Wasp also maintains the code for you, so you don't have to worry about keeping up with the latest security best practices. As Wasp updates, so does your app.\n\n### So what does the code look like?\n\nLet's say you want to build a web app that allows users to **create and share their favorite recipes**.\n\nLet's start with the `main.wasp` file: it is the central file of your app, where you describe the app from the high level.\n\nLet's give our app a title and let's immediately turn on the full-stack authentication via username and password:\n\n```wasp title=\"main.wasp\"\napp RecipeApp {\n  title: \"My Recipes\",\n  wasp: { version: \"{latestWaspVersion}\" },\n  auth: {\n    methods: { usernameAndPassword: {} },\n    onAuthFailedRedirectTo: \"/login\",\n    userEntity: User\n  }\n}\n```\n\nLet's then add the data models for your recipes. Wasp understands and uses the models from the `schema.prisma` file. We will want to have Users and Users can own Recipes:\n\n```prisma title=\"schema.prisma\"\n...\n\n// Data models are defined using Prisma Schema Language.\nmodel User {\n  id          Int @id @default(autoincrement())\n  recipes     Recipe[]\n}\n\nmodel Recipe {\n  id          Int @id @default(autoincrement())\n  title       String\n  description String?\n  userId      Int\n  user        User @relation(fields: [userId], references: [id])\n}\n```\n\nNext, let's define how to do something with these data models!\n\nWe do that by defining Operations, in this case, a Query `getRecipes` and Action `addRecipe`,\nwhich are in their essence Node.js functions that execute on the server and can, thanks to Wasp, very easily be called from the client.\n\nFirst, we define these Operations in our `main.wasp` file, so Wasp knows about them and can \"beef them up\":\n\n```wasp title=\"main.wasp\"\n// Queries have automatic cache invalidation and are type-safe.\nquery getRecipes {\n  fn: import { getRecipes } from \"@src/recipe/operations\",\n  entities: [Recipe],\n}\n\n// Actions are type-safe and can be used to perform side-effects.\naction addRecipe {\n  fn: import { addRecipe } from \"@src/recipe/operations\",\n  entities: [Recipe],\n}\n```\n\n... and then implement them in our Javascript (or TypeScript) code (we show just the query here, using TypeScript):\n\n```ts title=\"src/recipe/operations.ts\"\n// Wasp generates the types for you.\n\nexport const getRecipes: GetRecipes<{}, Recipe[]> = async (_args, context) => {\n  return context.entities.Recipe.findMany( // Prisma query\n    { where: { user: { id: context.user.id } } }\n  );\n};\n\nexport const addRecipe ...\n```\n\nNow we can very easily use these in our React components!\n\nFor the end, let's create a home page of our app.\n\nFirst, we define it in `main.wasp`:\n\n```wasp title=\"main.wasp\"\n...\n\nroute HomeRoute { path: \"/\", to: HomePage }\npage HomePage {\n  component: import { HomePage } from \"@src/pages/HomePage\",\n  authRequired: true // Will send user to /login if not authenticated.\n}\n```\n\nand then implement it as a React component in JS/TS (that calls the Operations we previously defined):\n\n```tsx title=\"src/pages/HomePage.tsx\"\n\nexport function HomePage({ user }: { user: User }) {\n  // Due to full-stack type safety, `recipes` will be of type `Recipe[]` here.\n  const { data: recipes, isLoading } = useQuery(getRecipes) // Calling our query here!\n\n  if (isLoading) {\n    return <div>Loading...</div>\n  }\n\n  return (\n    <div>\n      <h1>Recipes</h1>\n      <ul>\n        {recipes\n          ? recipes.map((recipe) => (\n              <li key={recipe.id}>\n                <div>{recipe.title}</div>\n                <div>{recipe.description}</div>\n              </li>\n            ))\n          : 'No recipes defined yet!'}\n      </ul>\n    </div>\n  )\n}\n```\n\nAnd voila! We are listing all the recipes in our app 🎉\n\nThis was just a quick example to give you a taste of what Wasp is. For step by step tour through the most important Wasp features, check out the [Todo app tutorial](../tutorial/01-create.md).\n\n:::note\nAbove we skipped defining `/login` and `/signup` pages to keep the example a bit shorter, but those are very simple to do by using Wasp's Auth UI feature.\n:::\n\n### When to use Wasp\n\nWasp addresses the same core problems that typical web app frameworks are addressing, and it in big part [looks, swims and quacks](https://en.wikipedia.org/wiki/Duck_test) like a web app framework.\n\n#### Best used for\n\n- building full-stack web apps (like e.g. Airbnb or Asana)\n- quickly starting a web app with industry best practices\n- to be used alongside modern web dev stack (React and Node.js are currently supported)\n\n#### Avoid using Wasp for\n\n- building static/presentational websites\n- to be used as a no-code solution\n- to be a solve-it-all tool in a single language\n\n### Wasp is a DSL\n\n:::note\nYou don't need to know what a DSL is to use Wasp, but if you are curious, you can read more about it below.\n:::\n\nWasp does not match typical expectations of a web app framework: it is not a set of libraries, it is instead a simple programming language that understands your code and can do a lot of things for you.\n\nWasp is a programming language, but a specific kind: it is specialized for a single purpose: **building modern web applications**. We call such languages _DS&#x4C;_&#x73; (Domain Specific Language).\n\nOther examples of _DS&#x4C;_&#x73; that are often used today are e.g. _SQL_ for databases and _HTML_ for web page layouts.\nThe main advantage and reason why _DS&#x4C;_&#x73; exist is that they need to do only one task (e.g. database queries)\nso they can do it well and provide the best possible experience for the developer.\n\nThe same idea stands behind Wasp - a language that will allow developers to **build modern web applications with 10x less code and less stack-specific knowledge**.\n\n## Quick Start\n\n### Installation\n\nWelcome, new Waspeteer 🐝!\n\nLet's create and run our first Wasp app in 3 short steps:\n\n1. **To install Wasp on Linux / OSX / WSL (Windows), open your terminal and run:**\n\n   ```shell\n   curl -sSL https://get.wasp.sh/installer.sh | sh\n   ```\n\n   ℹ️ Wasp requires Node.js and will warn you if it is missing: check below for [more details](#requirements).\n\n2. **Then, create a new app by running:**\n\n   ```shell\n   wasp new\n   ```\n\n3. **Finally, run the app:**\n\n   ```shell\n   cd <my-project-name>\n   wasp start\n   ```\n\nThat's it 🎉 You have successfully created and served a new full-stack web app at [http://localhost:3000](http://localhost:3000) and Wasp is serving both frontend and backend for you.\n\n:::note Something Unclear?\nCheck [More Details](#more-details) section below if anything went wrong with the installation, or if you have additional questions.\n:::\n\n:::tip Want an even faster start?\nTry out [Wasp AI](../wasp-ai/creating-new-app.md) 🤖 to generate a new Wasp app in minutes just from a title and short description!\n:::\n\n:::tip Try Wasp Without Installing 🤔?\nGive Wasp a spin in the browser with GitHub Codespaces by following the intructions in our [Tutorial App README](https://github.com/wasp-lang/wasp/tree/release/examples/tutorials/TodoApp)\n:::\n\n:::tip Having trouble running Wasp?\n  If you get stuck with a weird error while developing with Wasp, try running `wasp clean` - this is the Wasp equivalent of \"turning it off and on again\"!\n  Do however let us know about the issue on our GitHub repo or Discord server.\n:::\n\n#### What next?\n\n- [ ] 👉 **Check out the [Todo App tutorial](../tutorial/01-create.md), which will take you through all the core features of Wasp!** 👈\n- [ ] [Setup your editor](./editor-setup.md) for working with Wasp.\n- [ ] Join us on [Discord](https://discord.gg/rzdnErX)! Any feedback or questions you have, we are there for you.\n- [ ] Follow Wasp development by subscribing to our newsletter: https://wasp.sh/#signup . We usually send 1 per month, and [Matija](https://github.com/matijaSos) does his best to unleash his creativity to make them engaging and fun to read :D!\n\n---\n\n### More details\n\n#### Requirements\n\nYou must have Node.js (and NPM) installed on your machine and available in `PATH`.\nA version of Node.js must be >= 20.\n\nIf you need it, we recommend using [nvm](https://github.com/nvm-sh/nvm) for managing your Node.js installation version(s).\n\n<details>\n  <summary style={{cursor: 'pointer', 'textDecoration': 'underline'}}>\n    A quick guide on installing/using nvm\n  </summary>\n\n  <div>\n    Install nvm via your OS package manager (`apt`, `pacman`, `homebrew`, ...) or via the [nvm](https://github.com/nvm-sh/nvm#install--update-script) install script.\n\n    Then, install a version of Node.js that you need:\n\n    ```shell\n    nvm install 20\n    ```\n\n    Finally, whenever you need to ensure a specific version of Node.js is used, run:\n\n    ```shell\n    nvm use 20\n    ```\n\n    to set the Node.js version for the current shell session.\n\n    You can run\n\n    ```shell\n    node -v\n    ```\n\n    to check the version of Node.js currently being used in this shell session.\n\n    Check NVM repo for more details: https://github.com/nvm-sh/nvm.\n  </div>\n</details>\n\n#### Installation\n\n<Tabs\n  defaultValue=\"linux/osx\"\n  values={[\n    {label: 'Linux / macOS', value: 'linux/osx'},\n    {label: 'Windows', value: 'win'},\n    {label: 'From source', value: 'source'}\n  ]}\n>\n  <TabItem value=\"linux/osx\">\n    Open your terminal and run:\n\n    ```shell\n    curl -sSL https://get.wasp.sh/installer.sh | sh\n    ```\n\n    :::note Running Wasp on Mac with Mx chip (arm64)\n    **Experiencing the 'Bad CPU type in executable' issue on a device with arm64 (Apple Silicon)?**\n    Given that the wasp binary is built for x86 and not for arm64 (Apple Silicon), you'll need to install [Rosetta on your Mac](https://support.apple.com/en-us/HT211861) if you are using a Mac with Mx (M1, M2, ...). Rosetta is a translation process that enables users to run applications designed for x86 on arm64 (Apple Silicon). To install Rosetta, run the following command in your terminal\n\n    ```bash\n    softwareupdate --install-rosetta\n    ```\n\n    Once Rosetta is installed, you should be able to run Wasp without any issues.\n    :::\n  </TabItem>\n\n  <TabItem value=\"win\">\n    With Wasp for Windows, we are almost there: Wasp is successfully compiling and running on Windows but there is a bug or two stopping it from fully working. Check it out [here](https://github.com/wasp-lang/wasp/issues/48) if you are interested in helping.\n\n    In the meantime, the best way to start using Wasp on Windows is by using [WSL](https://learn.microsoft.com/en-us/windows/wsl/install). Once you set up Ubuntu on WSL, just follow Linux instructions for installing Wasp. You can refer to this [article](https://wasp.sh/blog/2023/11/21/guide-windows-development-wasp-wsl) if you prefer a step by step guide to using Wasp in WSL environment. If you need further help, reach out to us on [Discord](https://discord.gg/rzdnErX) - we have some community members using WSL that might be able to help you.\n    :::caution\n    If you are using WSL2, make sure that your Wasp project is not on the Windows file system, but instead on the Linux file system. Otherwise, Wasp won't be able to detect file changes, due to the [issue in WSL2](https://github.com/microsoft/WSL/issues/4739).\n    :::\n  </TabItem>\n\n  <TabItem value=\"source\">\n    If the installer is not working for you or your OS is not supported, you can try building Wasp from the source.\n\n    To install from source, you need to clone the [wasp repo](https://github.com/wasp-lang/wasp), install [Cabal](https://cabal.readthedocs.io/en/stable/getting-started.html) on your machine and then run `cabal install` from the `waspc/` dir.\n\n    If you have never built Wasp before, this might take some time due to `cabal` downloading dependencies for the first time.\n\n    Check [waspc/](https://github.com/wasp-lang/wasp/tree/main/waspc) for more details on building Wasp from the source.\n  </TabItem>\n</Tabs>\n\n## Editor Setup\n\n:::note\nThis page assumes you have already installed Wasp. If you do not have Wasp installed yet, check out the [Quick Start](./quick-start.md) guide.\n:::\n\nWasp comes with the Wasp language server, which gives supported editors powerful support and integration with the language.\n\n### VSCode\n\nCurrently, Wasp only supports integration with VSCode. Install the [Wasp language extension](https://marketplace.visualstudio.com/items?itemName=wasp-lang.wasp) to get syntax highlighting and integration with the Wasp language server.\n\nThe extension enables:\n\n- syntax highlighting for `.wasp` files\n- the Prisma extension for `.prisma` files\n- scaffolding of new project files\n- code completion\n- diagnostics (errors and warnings)\n- go to definition\n\nand more!\n\n<TypescriptServerNote />\n\n------\n\n# Tutorial\n\n## 1. Creating a New Project\n\n:::info\nYou'll need to have the latest version of Wasp installed locally to follow this tutorial. If you haven't installed it yet, check out the [QuickStart](../quick-start) guide!\n:::\n\nIn this section, we'll guide you through the process of creating a simple Todo app with Wasp. In the process, we'll take you through the most important and useful features of Wasp.\n\n<img alt=\"How Todo App will work once it is done\" src={useBaseUrl('img/todo-app-tutorial-intro.gif')} className=\"tutorial-image\" />\n\n<br />\n\n<br />\n\nIf you get stuck at any point (or just want to chat), reach out to us on [Discord](https://discord.gg/rzdnErX) and we will help you!\n\nYou can find the complete code of the app we're about to build [here](https://github.com/wasp-lang/wasp/tree/release/examples/tutorials/TodoApp).\n\n### Creating a Project\n\nTo setup a new Wasp project, run the following command in your terminal:\n\n```sh\nwasp new TodoApp -t minimal\n```\n\n<small>\n\nWe are using the `minimal` template because we're going to implement the app from scratch, instead of the more full-featured default template.\n</small>\n\nEnter the newly created directory and start the development server:\n\n```sh\ncd TodoApp\nwasp start\n```\n\n`wasp start` will take a bit of time to start the server the first time you run it in a new project.\n\nYou will see log messages from the client, server, and database setting themselves up. When everything is ready, a new tab should open in your browser at `http://localhost:3000` with a simple placeholder page:\n\n<img alt=\"Screenshot of the Wasp minimal starter app\" src={useBaseUrl('img/wasp-new-screenshot.png')} className=\"tutorial-image\" />\n\n<br />\n\n<br />\n\nWasp has generated for you the full front-end and back-end code of the app! Next, we'll take a closer look at how the project is structured.\n\n### A note on supported languages\n\nWasp supports both JavaScript and TypeScript out of the box, but you are free to choose between or mix JavaScript and TypeScript as you see fit.\n\nWe'll provide you with both JavaScript and TypeScript code in this tutorial.\nCode blocks will have a toggle to switch between vanilla JavaScript and TypeScript.\n\nTry it out:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    :::note Welcome to JavaScript!\n\n    You are now reading the JavaScript version of the docs. The site will remember your preference as you switch pages.\n\n    You'll have a chance to change the language on every code snippet - both the snippets and the text will update accordingly.\n    :::\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    :::note Welcome to TypeScript!\n\n    You are now reading the TypeScript version of the docs. The site will remember your preference as you switch pages.\n\n    You'll have a chance to change the language on every code snippet - both the snippets and the text will update accordingly.\n    :::\n  </TabItem>\n</Tabs>\n\n## 2. Project Structure\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    By default, Wasp will create a TypeScript project. We recommend using TypeScript in new projects, and you can always mix-and-match TypeScript and JavaScript files.\n    \n    To use JavaScript in the main page, you must manually rename the file\n    `src/MainPage.tsx` to `src/MainPage.jsx`. Restart `wasp start` after you do this.\n\n    No updates to the `main.wasp` file are necessary - it stays the same regardless of the language you use.\n\n    After creating a new Wasp project and renaming the `src/MainPage.tsx` file, your project should look like this:\n\n    <!-- NOTE: Using python as language to get syntax highlighting for the comments -->\n    ```python\n    .\n    ├── .gitignore\n    ├── main.wasp     # Your Wasp code goes here.\n    ├── schema.prisma # Your database models go here.\n    ├── package.json  # Your dependencies and project info go here.\n    ├── public        # Your static files (e.g., images, favicon) go here.\n    │   └── favicon.ico\n    ├── src           # Your source code (JS/React/Node.js) goes here.\n    │   ├── Main.css\n    # highlight-next-line\n    │   ├── MainPage.jsx\n    │   ├── assets\n    │   │   └── logo.svg\n    │   └── vite-env.d.ts\n    ├── tsconfig.json\n    └── vite.config.ts\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    After creating a new Wasp project, your project should look like this:\n\n    ```python\n    .\n    ├── .gitignore\n    ├── main.wasp     # Your Wasp code goes here.\n    ├── schema.prisma # Your database models go here.\n    ├── package.json  # Your dependencies and project info go here.\n    ├── public        # Your static files (e.g., images, favicon) go here.\n    │   └── favicon.ico\n    ├── src           # Your source code (TS/React/Node.js) goes here.\n    │   ├── Main.css\n    │   ├── MainPage.tsx\n    │   ├── assets\n    │   │   └── logo.svg\n    │   └── vite-env.d.ts\n    ├── tsconfig.json\n    └── vite.config.ts\n    ```\n  </TabItem>\n</Tabs>\n\nBy _your code_, we mean the _\"the code you write\"_, as opposed to the code generated by Wasp. Wasp allows you to organize and structure your code however you think is best - there's no need to separate client files and server files into different directories.\n\nWe'd normally recommend organizing code by features (i.e., vertically).\nHowever, since this tutorial contains only a handful of files, there's no need for fancy organization.\nWe'll keep it simple by placing everything in the root `src` directory.\n\nMany other files (e.g., `tsconfig.json`, `vite-env.d.ts`, `.wasproot`, etc.) help Wasp and the IDE improve your development experience with autocompletion, IntelliSense, and error reporting.\n\nThe `vite.config.ts` file is used to configure [Vite](https://vitejs.dev/guide/), Wasp's build tool of choice.\nWe won't be configuring Vite in this tutorial, so you can safely ignore the file. Still, if you ever end up wanting more control over Vite, you'll find everything you need to know in [custom Vite config docs](../project/custom-vite-config.md).\n\nThe `schema.prisma` file is where you define your database schema using [Prisma](https://www.prisma.io/). We'll cover this a bit later in the tutorial.\n\nThe most important file in the project is `main.wasp`. Wasp uses the configuration within it to perform its magic. Based on what you write, it generates a bunch of code for your database, server-client communication, React routing, and more.\n\nLet's take a closer look at `main.wasp`\n\n### `main.wasp`\n\n`main.wasp` is your app's definition file.\nIt defines the app's central components and helps Wasp to do a lot of the legwork for you.\n\n:::tip Wasp TS config \\[Early-preview feature\\]\nIf you wish, you can alternatively define your [Wasp config in TS](../general/wasp-ts-config.md) (`main.wasp.ts`) instead of `main.wasp`.\n:::\n\nThe file is a list of _declarations_. Each declaration defines a part of your app.\n\nThe default `main.wasp` file generated with `wasp new` on the previous page looks like this:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app TodoApp {\n      wasp: {\n        version: \"{latestWaspVersion}\" // Pins the version of Wasp to use.\n      },\n      title: \"TodoApp\", // Used as the browser tab title. Note that all strings in Wasp are double quoted!\n      head: [\n        \"<link rel='icon' href='/favicon.ico' />\",\n      ]\n    }\n\n    route RootRoute { path: \"/\", to: MainPage }\n    page MainPage {\n      // We specify that the React implementation of the page is exported from\n      // `src/MainPage.jsx`. This statement uses standard JS import syntax.\n      // Use `@src` to reference files inside the `src` folder.\n      component: import { MainPage } from \"@src/MainPage\"\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app TodoApp {\n      wasp: {\n        version: \"{latestWaspVersion}\" // Pins the version of Wasp to use.\n      },\n      title: \"TodoApp\", // Used as the browser tab title. Note that all strings in Wasp are double quoted!\n      head: [\n        \"<link rel='icon' href='/favicon.ico' />\",\n      ]\n    }\n\n    route RootRoute { path: \"/\", to: MainPage }\n    page MainPage {\n      // We specify that the React implementation of the page is exported from\n      // `src/MainPage.tsx`. This statement uses standard JS import syntax.\n      // Use `@src` to reference files inside the `src` folder.\n      component: import { MainPage } from \"@src/MainPage\"\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThis file uses three declaration types:\n\n- **app**: Top-level configuration information about your app.\n\n- **route**: Describes which path each page should be accessible from.\n\n- **page**: Defines a web page and the React component that gets rendered when the page is loaded.\n\nIn the next section, we'll explore how **route** and **page** work together to build your web app.\n\n## 3. Pages & Routes\n\nIn the default `main.wasp` file created by `wasp new`, there is a **page** and a **route** declaration:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    route RootRoute { path: \"/\", to: MainPage }\n    page MainPage {\n      // We specify that the React implementation of the page is exported from\n      // `src/MainPage.jsx`. This statement uses standard JS import syntax.\n      // Use `@src` to reference files inside the `src` folder.\n      component: import { MainPage } from \"@src/MainPage\"\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    route RootRoute { path: \"/\", to: MainPage }\n    page MainPage {\n      // We specify that the React implementation of the page is exported from\n      // `src/MainPage.tsx`. This statement uses standard JS import syntax.\n      // Use `@src` to reference files inside the `src` folder.\n      component: import { MainPage } from \"@src/MainPage\"\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nTogether, these declarations tell Wasp that when a user navigates to `/`, it should render the named export from `src/MainPage.{jsx,tsx}`.\n\n### The MainPage Component\n\nLet's take a look at the React component referenced by the page declaration:\n\n```tsx title=\"src/MainPage.tsx\" auto-js\n\nexport function MainPage() {\n  // ...\n}\n```\n\nThis is a regular functional React component. It also imports some CSS and a logo from the `assets` folder.\n\nThat is all the code you need! Wasp takes care of everything else necessary to define, build, and run the web app.\n\n<WaspStartNote />\n\n<ShowForTs>\n  <TypescriptServerNote />\n</ShowForTs>\n\n### Adding a Second Page\n\nTo add more pages, you can create another set of **page** and **route** declarations. You can even add parameters to the URL path, using the same syntax as [React Router](https://reactrouter.com/en/6.26.1). Let's test this out by adding a new page:\n\n```wasp title=\"main.wasp\"\nroute HelloRoute { path: \"/hello/:name\", to: HelloPage }\npage HelloPage {\n  component: import { HelloPage } from \"@src/HelloPage\"\n}\n```\n\nWhen a user visits `/hello/their-name`, Wasp renders the component exported from `src/HelloPage.{jsx,tsx}` and you can use the `useParams` hook from `react-router-dom` to access the `name` parameter:\n\n```tsx title=\"src/HelloPage.tsx\" auto-js\n\nexport const HelloPage = () => {\n  const { name } = useParams<'name'>()\n  return <div>Here's {name}!</div>\n}\n```\n\nNow you can visit `/hello/johnny` and see \"Here's johnny!\"\n\n<ShowForTs>\n  :::tip Type-safe links\n  Since you are using Typescript, you can benefit from using Wasp's type-safe `Link` component and the `routes` object. Check out the [type-safe links docs](../advanced/links) for more details.\n  :::\n</ShowForTs>\n\n### Cleaning Up\n\nNow that you've seen how Wasp deals with Routes and Pages, it's finally time to build the Todo app.\n\nStart by cleaning up the starter project and removing unnecessary code and files.\n\nFirst, remove most of the code from the `MainPage` component:\n\n```tsx title=\"src/MainPage.tsx\" auto-js\nexport const MainPage = () => {\n  return <div>Hello world!</div>\n}\n```\n\nAt this point, the main page should look like this:\n\n<img alt=\"Todo App - Hello World\" src={useBaseUrl('img/todo-app-hello-world.png')} className=\"tutorial-image\" />\n\nYou can now delete redundant files: `src/Main.css`, `src/assets/logo.svg`, and `src/HelloPage.{jsx,tsx}` (we won't need this page for the rest of the tutorial).\n\nSince `src/HelloPage.{jsx,tsx}` no longer exists, remove its `route` and `page` declarations from the `main.wasp` file.\n\nYour Wasp file should now look like this:\n\n```wasp title=\"main.wasp\"\napp TodoApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"TodoApp\",\n  head: [\n    \"<link rel='icon' href='/favicon.ico' />\",\n  ]\n}\n\nroute RootRoute { path: \"/\", to: MainPage }\npage MainPage {\n  component: import { MainPage } from \"@src/MainPage\"\n}\n```\n\nExcellent work!\n\nYou now have a basic understanding of Wasp and are ready to start building your TodoApp.\nWe'll implement the app's core features in the following sections.\n\n## 4. Database Entities\n\nEntities are one of the most important concepts in Wasp and are how you define what gets stored in the database.\n\nWasp uses Prisma to talk to the database, and you define Entities by defining Prisma models in the `schema.prisma` file.\n\nSince our Todo app is all about tasks, we'll define a Task entity by adding a Task model in the `schema.prisma` file:\n\n```prisma title=\"schema.prisma\"\n// ...\n\nmodel Task {\n    id          Int     @id @default(autoincrement())\n    description String\n    isDone      Boolean @default(false)\n}\n```\n\n:::note\nRead more about how Wasp Entities work in the [Entities](../data-model/entities.md) section or how Wasp uses the `schema.prisma` file in the [Prisma Schema File](../data-model/prisma-file.md) section.\n:::\n\nTo update the database schema to include this entity, stop the `wasp start` process, if it's running, and run:\n\n```sh\nwasp db migrate-dev\n```\n\nYou'll need to do this any time you change an entity's definition. It instructs Prisma to create a new database migration and apply it to the database.\n\nTo take a look at the database and the new `Task` entity, run:\n\n```sh\nwasp db studio\n```\n\nThis will open a new page in your browser to view and edit the data in your database.\n\n<img alt=\"Todo App - Db studio showing Task schema\" src={useBaseUrl('img/todo-app-db-studio-task-entity.png')} className=\"tutorial-image\" />\n\nClick on the `Task` entity and check out its fields! We don't have any data in our database yet, but we are about to change that.\n\n## 5. Querying the Database\n\nWe want to know which tasks we need to do, so let's list them!\n\nThe primary way of working with Entities in Wasp is with [Queries and Actions](../data-model/operations/overview), collectively known as **_Operations_**.\n\nQueries are used to read an entity, while Actions are used to create, modify, and delete entities. Since we want to list the tasks, we'll want to use a Query.\n\nTo list the tasks, you must:\n\n1. Create a Query that fetches the tasks from the database.\n2. Update the `MainPage.{jsx,tsx}` to use that Query and display the results.\n\n### Defining the Query\n\nWe'll create a new Query called `getTasks`. We'll need to declare the Query in the Wasp file and write its implementation in <ShowForJs>JS</ShowForJs><ShowForTs>TS</ShowForTs>.\n\n#### Declaring a Query\n\nWe need to add a **query** declaration to `main.wasp` so that Wasp knows it exists:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    query getTasks {\n      // Specifies where the implementation for the query function is.\n      // The path `@src/queries` resolves to `src/queries.js`.\n      // No need to specify an extension.\n      fn: import { getTasks } from \"@src/queries\",\n      // Tell Wasp that this query reads from the `Task` entity. Wasp will\n      // automatically update the results of this query when tasks are modified.\n      entities: [Task]\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    query getTasks {\n      // Specifies where the implementation for the query function is.\n      // The path `@src/queries` resolves to `src/queries.ts`.\n      // No need to specify an extension.\n      fn: import { getTasks } from \"@src/queries\",\n      // Tell Wasp that this query reads from the `Task` entity. Wasp will\n      // automatically update the results of this query when tasks are modified.\n      entities: [Task]\n    }\n    ```\n\n    :::note\n    To generate the types used in the next section, make sure that `wasp start` is still running.\n    :::\n  </TabItem>\n</Tabs>\n\n#### Implementing a Query\n\n<ShowForJs>\n  Next, create a new file called `src/queries.js` and define the JavaScript function we've just imported in our `query` declaration:\n</ShowForJs>\n\n<ShowForTs>\n  Next, create a new file called `src/queries.ts` and define the TypeScript function we've just imported in our `query` declaration:\n</ShowForTs>\n\n```ts title=\"src/queries.ts\" auto-js\n\nexport const getTasks: GetTasks<void, Task[]> = async (args, context) => {\n  return context.entities.Task.findMany({\n    orderBy: { id: 'asc' },\n  })\n}\n```\n\n<ShowForTs>\nWasp automatically generates the types `GetTasks` and `Task` based on the contents of `main.wasp`:\n\n- `Task` is a type corresponding to the `Task` entity you defined in `schema.prisma`.\n- `GetTasks` is a generic type Wasp automatically generated based on the `getTasks` Query you defined in `main.wasp`.\n\nYou can use these types to specify the Query's input and output types. This Query doesn't expect any arguments (its input type is `void`), but it does return an array of tasks (its output type is `Task[]`).\n\nAnnotating the Queries is optional, but highly recommended because doing so enables **full-stack type safety**. We'll see what this means in the next step.\n</ShowForTs>\n\nQuery function parameters:\n\n- `args: object`\n\nThe arguments the caller passes to the Query.\n\n- `context`\n\n  An object with extra information injected by Wasp. Its type depends on the Query declaration.\n\nSince the Query declaration in `main.wasp` says that the `getTasks` Query uses `Task` entity, Wasp injected a [Prisma client](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud) for the `Task` entity as `context.entities.Task` - we used it above to fetch all the tasks from the database.\n\n:::info\nQueries and Actions are NodeJS functions executed on the server.\n:::\n\n### Invoking the Query On the Frontend\n\nWhile we implement Queries on the server, Wasp generates client-side functions that automatically take care of serialization, network calls, and cache invalidation, allowing you to call the server code like it's a regular function.\n\nThis makes it easy for us to use the `getTasks` Query we just created in our React component:\n\n```tsx title=\"src/MainPage.tsx\" auto-js\n\n// highlight-next-line\n\nexport const MainPage = () => {\n  // highlight-start\n  const { data: tasks, isLoading, error } = useQuery(getTasks)\n\n  return (\n    <div>\n      {tasks && <TasksList tasks={tasks} />}\n\n      {isLoading && 'Loading...'}\n      {error && 'Error: ' + error}\n    </div>\n  )\n  // highlight-end\n}\n\n// highlight-start\nconst TaskView = ({ task }: { task: Task }) => {\n  return (\n    <div>\n      <input type=\"checkbox\" id={String(task.id)} checked={task.isDone} />\n      {task.description}\n    </div>\n  )\n}\n\nconst TasksList = ({ tasks }: { tasks: Task[] }) => {\n  if (!tasks?.length) return <div>No tasks</div>\n\n  return (\n    <div>\n      {tasks.map((task, idx) => (\n        <TaskView task={task} key={idx} />\n      ))}\n    </div>\n  )\n}\n// highlight-end\n```\n\nMost of this code is regular React, the only exception being the <ShowForJs>two</ShowForJs><ShowForTs>three</ShowForTs> special `wasp` imports:\n\n<ShowForJs>\n  - `getTasks` - The client-side Query function Wasp generated based on the `getTasks` declaration in `main.wasp`.\n  - `useQuery` - Wasp's [useQuery](../data-model/operations/queries#the-usequery-hook-1) React hook, which is based on [react-query](https://github.com/tannerlinsley/react-query)'s hook with the same name.\n</ShowForJs>\n\n<ShowForTs>\n  - `getTasks` - The client-side Query function Wasp generated based on the `getTasks` declaration in `main.wasp`.\n  - `useQuery` - Wasp's [useQuery](../data-model/operations/queries#the-usequery-hook-1) React hook, which is based on [react-query](https://github.com/tannerlinsley/react-query)'s hook with the same name.\n  - `Task` - The type for the Task entity defined in `schema.prisma`.\n\n  Notice how you don't need to annotate the type of the Query's return value: Wasp uses the types you defined while implementing the Query for the generated client-side function. This is **full-stack type safety**: the types on the client always match the types on the server.\n</ShowForTs>\n\nWe could have called the Query directly using `getTasks()`, but the `useQuery` hook makes it reactive: React will re-render the component every time the Query changes. Remember that Wasp automatically refreshes Queries whenever the data is modified.\n\nWith these changes, you should be seeing the text \"No tasks\" on the screen:\n\n<img alt=\"Todo App - No Tasks\" src={useBaseUrl('img/todo-app-no-tasks.png')} className=\"tutorial-image\" />\n\nWe'll create a form to add tasks in the next step 🪄\n\n## 6. Modifying Data\n\nIn the previous section, you learned about using Queries to fetch data.\nLet's now learn about Actions so you can add and update tasks in the database.\n\nIn this section, you will create:\n\n1. A Wasp Action that creates a new task.\n2. A React form that calls that Action when the user creates a task.\n\n### Creating a New Action\n\nCreating an Action is very similar to creating a Query.\n\n#### Declaring an Action\n\nWe must first declare the Action in `main.wasp`:\n\n```wasp title=\"main.wasp\"\n// ...\n\naction createTask {\n  fn: import { createTask } from \"@src/actions\",\n  entities: [Task]\n}\n```\n\n#### Implementing an Action\n\nLet's now define a <ShowForJs>JavaScript</ShowForJs><ShowForTs>TypeScript</ShowForTs> function for our `createTask` Action:\n\n```ts title=\"src/actions.ts\" auto-js\n\ntype CreateTaskPayload = Pick<Task, 'description'>\n\nexport const createTask: CreateTask<CreateTaskPayload, Task> = async (\n  args,\n  context\n) => {\n  return context.entities.Task.create({\n    data: { description: args.description },\n  })\n}\n```\n\n<ShowForTs>\nOnce again, we've annotated the Action with the `CreateTask` and `Task` types generated by Wasp. Just like with queries, defining the types on the implementation makes them available on the frontend, giving us **full-stack type safety**.\n</ShowForTs>\n\n:::tip\nWe put the function in a new file `src/actions.{js,ts}`, but we could have put it anywhere we wanted! There are no limitations here, as long as the declaration in the Wasp file imports it correctly and the file is located within `src` directory.\n:::\n\n### Invoking the Action on the Client\n\nStart by defining a form for creating new tasks.\n\n```tsx title=\"src/MainPage.tsx\" auto-js\n\n  // highlight-next-line\n  createTask,\n  getTasks,\n  useQuery\n} from 'wasp/client/operations'\n\n// ... MainPage, TaskView, TaskList ...\n\n// highlight-start\nconst NewTaskForm = () => {\n  const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {\n    event.preventDefault()\n    try {\n      const target = event.target as HTMLFormElement\n      const description = target.description.value\n      target.reset()\n      await createTask({ description })\n    } catch (err: any) {\n      window.alert('Error: ' + err.message)\n    }\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input name=\"description\" type=\"text\" defaultValue=\"\" />\n      <input type=\"submit\" value=\"Create task\" />\n    </form>\n  )\n}\n// highlight-end\n```\n\nUnlike Queries, you can call Actions directly (without wrapping them in a hook) because they don't need reactivity. The rest is just regular React code.\n\n<ShowForTs>\n  Finally, because we've previously annotated the Action's server implementation with the correct type, Wasp knows that the `createTask` Action expects a value of type `{ description: string }` (try changing the argument and reading the error message). Wasp also knows that a call to the `createTask` Action returns a `Task` but are not using it in this example.\n</ShowForTs>\n\nAll that's left now is adding this form to the page component:\n\n```tsx title=\"src/MainPage.tsx\" auto-js\n\nconst MainPage = () => {\n  const { data: tasks, isLoading, error } = useQuery(getTasks)\n\n  return (\n    <div>\n      // highlight-next-line\n      <NewTaskForm />\n      {tasks && <TasksList tasks={tasks} />}\n      {isLoading && 'Loading...'}\n      {error && 'Error: ' + error}\n    </div>\n  )\n}\n\n// ... TaskList, TaskView, NewTaskForm ...\n```\n\nGreat work!\n\nYou now have a form for creating new tasks.\n\nTry creating a \"Build a Todo App in Wasp\" task and see it appear in the list below. The task is created on the server and saved in the database.\n\nTry refreshing the page or opening it in another browser. You'll see the tasks are still there!\n\n<img alt=\"Todo App - creating new task\" src={useBaseUrl('img/todo-app-new-task.png')} className=\"tutorial-image\" />\n\n<br />\n\n<br />\n\n:::note Automatic Query Invalidation\nWhen you create a new task, the list of tasks is automatically updated to display the new task, even though you haven't written any code that does that! Wasp handles these automatic updates under the hood.\n\nWhen you declared the `getTasks` and `createTask` operations, you specified that they both use the `Task` entity. So when `createTask` is called, Wasp knows that the data `getTasks` fetches may have changed and automatically updates it in the background. This means that **out of the box, Wasp keeps all your queries in sync with any changes made through Actions**.\n\nThis behavior is convenient as a default but can cause poor performance in large apps. While there is no mechanism for overriding this behavior yet, it is something that we plan to include in Wasp in the future. This feature is tracked [here](https://github.com/wasp-lang/wasp/issues/63).\n:::\n\n### A Second Action\n\nOur Todo app isn't finished if you can't mark a task as done.\n\nWe'll create a new Action to update a task's status and call it from React whenever a task's checkbox is toggled.\n\nSince we've already created one task together, try to create this one yourself. It should be an Action named `updateTask` that receives the task's `id` and its `isDone` status. You can see our implementation below.\n\n<Collapse title=\"Solution\">\n  Declaring the Action in `main.wasp`:\n\n  ```wasp title=\"main.wasp\"\n  // ...\n\n  action updateTask {\n    fn: import { updateTask } from \"@src/actions\",\n    entities: [Task]\n  }\n  ```\n\n  Implementing the Action on the server:\n\n  ```ts title=\"src/actions.ts\" auto-js\n  import type { CreateTask, UpdateTask } from 'wasp/server/operations'\n\n  // ...\n\n  type UpdateTaskPayload = Pick<Task, 'id' | 'isDone'>\n\n  export const updateTask: UpdateTask<UpdateTaskPayload, Task> = async (\n    { id, isDone },\n    context\n  ) => {\n    return context.entities.Task.update({\n      where: { id },\n      data: {\n        isDone: isDone,\n      },\n    })\n  }\n  ```\n</Collapse>\n\nYou can now call `updateTask` from the React component:\n\n```tsx title=\"src/MainPage.tsx\" auto-js\n\n  // highlight-next-line\n  updateTask,\n  createTask,\n  getTasks,\n  useQuery,\n} from 'wasp/client/operations'\n\n// ... MainPage ...\n\nconst TaskView = ({ task }: { task: Task }) => {\n  // highlight-start\n  const handleIsDoneChange = async (event: ChangeEvent<HTMLInputElement>) => {\n    try {\n      await updateTask({\n        id: task.id,\n        isDone: event.target.checked,\n      })\n    } catch (error: any) {\n      window.alert('Error while updating task: ' + error.message)\n    }\n  }\n  // highlight-end\n\n  return (\n    <div>\n      <input\n        type=\"checkbox\"\n        id={String(task.id)}\n        checked={task.isDone}\n        // highlight-next-line\n        onChange={handleIsDoneChange}\n      />\n      {task.description}\n    </div>\n  )\n}\n\n// ... TaskList, NewTaskForm ...\n```\n\nAwesome!\nYou can now mark this task as done.\n\nIt's time to make one final addition to your app: supporting multiple users.\n\n## 7. Adding Authentication\n\nMost modern apps need a way to create and authenticate users. Wasp makes this as easy as possible with its first-class auth support.\n\nTo add users to your app, you must:\n\n- [ ] Create a `User` Entity.\n- [ ] Tell Wasp to use the _Username and Password_ authentication.\n- [ ] Add login and signup pages.\n- [ ] Update the main page to require authentication.\n- [ ] Add a relation between `User` and `Task` entities.\n- [ ] Modify your Queries and Actions so users can only see and modify their tasks.\n- [ ] Add a logout button.\n\n### Creating a User Entity\n\nSince Wasp manages authentication, it will create [the auth related entities](../auth/entities) for you in the background. Nothing to do here!\n\nYou must only add the `User` Entity to keep track of who owns which tasks:\n\n```prisma title=\"schema.prisma\"\n// ...\n\nmodel User {\n  id Int @id @default(autoincrement())\n}\n```\n\n### Adding Auth to the Project\n\nNext, tell Wasp to use full-stack [authentication](../auth/overview):\n\n```wasp title=\"main.wasp\"\napp TodoApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"TodoApp\",\n  head: [\n    \"<link rel='icon' href='/favicon.ico' />\",\n  ],\n  // highlight-start\n  auth: {\n    // Tells Wasp which entity to use for storing users.\n    userEntity: User,\n    methods: {\n      // Enable username and password auth.\n      usernameAndPassword: {}\n    },\n    // We'll see how this is used in a bit.\n    onAuthFailedRedirectTo: \"/login\"\n  }\n  // highlight-end\n}\n\n// ...\n```\n\nDon't forget to update the database schema by running:\n\n```sh\nwasp db migrate-dev\n```\n\nBy doing this, Wasp will create:\n\n- [Auth UI](../auth/ui) with login and signup forms.\n- A `logout()` action.\n- A React hook `useAuth()`.\n- `context.user` for use in Queries and Actions.\n\n:::info\nWasp also supports authentication using [Google](../auth/social-auth/google), [GitHub](../auth/social-auth/github), and [email](../auth/email), with more on the way!\n:::\n\n### Adding Login and Signup Pages\n\nWasp creates the login and signup forms for us, but we still need to define the pages to display those forms on. We'll start by declaring the pages in the Wasp file:\n\n```wasp title=\"main.wasp\"\n// ...\n\nroute SignupRoute { path: \"/signup\", to: SignupPage }\npage SignupPage {\n  component: import { SignupPage } from \"@src/SignupPage\"\n}\n\nroute LoginRoute { path: \"/login\", to: LoginPage }\npage LoginPage {\n  component: import { LoginPage } from \"@src/LoginPage\"\n}\n```\n\nGreat, Wasp now knows these pages exist!\n\nHere's the React code for the pages you've just imported:\n\n```tsx title=\"src/LoginPage.tsx\" auto-js\n\nexport const LoginPage = () => {\n  return (\n    <div style={{ maxWidth: '400px', margin: '0 auto' }}>\n      <LoginForm />\n      <br />\n      <span>\n        I don't have an account yet (<Link to=\"/signup\">go to signup</Link>).\n      </span>\n    </div>\n  )\n}\n```\n\nThe signup page is very similar to the login page:\n\n```tsx title=\"src/SignupPage.tsx\" auto-js\n\nexport const SignupPage = () => {\n  return (\n    <div style={{ maxWidth: '400px', margin: '0 auto' }}>\n      <SignupForm />\n      <br />\n      <span>\n        I already have an account (<Link to=\"/login\">go to login</Link>).\n      </span>\n    </div>\n  )\n}\n```\n\n<ShowForTs>\n  :::tip Type-safe links\n  Since you are using Typescript, you can benefit from using Wasp's type-safe `Link` component and the `routes` object. Check out the [type-safe links docs](../advanced/links) for more details.\n  :::\n</ShowForTs>\n\n### Update the Main Page to Require Auth\n\nWe don't want users who are not logged in to access the main page, because they won't be able to create any tasks. So let's make the page private by requiring the user to be logged in:\n\n```wasp title=\"main.wasp\"\n// ...\n\npage MainPage {\n  // highlight-next-line\n  authRequired: true,\n  component: import { MainPage } from \"@src/MainPage\"\n}\n```\n\nNow that auth is required for this page, unauthenticated users will be redirected to `/login`, as we specified with `app.auth.onAuthFailedRedirectTo`.\n\nAdditionally, when `authRequired` is `true`, the page's React component will be provided a `user` object as prop.\n\n```tsx title=\"src/MainPage.tsx\" auto-js\n\n// highlight-next-line\nexport const MainPage = ({ user }: { user: AuthUser }) => {\n  // Do something with the user\n  // ...\n}\n```\n\nOk, time to test this out. Navigate to the main page (`/`) of the app. You'll get redirected to `/login`, where you'll be asked to authenticate.\n\nSince we just added users, you don't have an account yet. Go to the signup page and create one. You'll be sent back to the main page where you will now be able to see the TODO list!\n\nLet's check out what the database looks like. Start the Prisma Studio:\n\n```shell\nwasp db studio\n```\n\n<img alt=\"Database demonstration - password hashing\" src={useBaseUrl('img/wasp_user_in_db.gif')} className=\"tutorial-image\" />\n\nYou'll notice that we now have a `User` entity in the database alongside the `Task` entity.\n\nHowever, you will notice that if you try logging in as different users and creating some tasks, all users share the same tasks. That's because you haven't yet updated the queries and actions to have per-user tasks. Let's do that next.\n\n<small>\n  You might notice some extra Prisma models like `Auth`, `AuthIdentity` and `Session` that Wasp created for you. You don't need to care about these right now, but if you are curious, you can read more about them [here](../auth/entities).\n</small>\n\n### Defining a User-Task Relation\n\nFirst, let's define a one-to-many relation between users and tasks (check the [Prisma docs on relations](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/relations)):\n\n```prisma title=\"schema.prisma\"\n// ...\n\nmodel User {\n  id    Int    @id @default(autoincrement())\n  // highlight-next-line\n  tasks Task[]\n}\n\nmodel Task {\n  id          Int     @id @default(autoincrement())\n  description String\n  isDone      Boolean @default(false)\n  // highlight-next-line\n  user        User?   @relation(fields: [userId], references: [id])\n  // highlight-next-line\n  userId      Int?\n}\n```\n\nAs always, you must migrate the database after changing the Entities:\n\n```sh\nwasp db migrate-dev\n```\n\n:::note\nWe made `user` and `userId` in `Task` optional (via `?`) because that allows us to keep the existing tasks, which don't have a user assigned, in the database.\n\nThis isn't recommended because it allows an unwanted state in the database (what is the purpose of the task not belonging to anybody?) and normally we would not make these fields optional.\n\nInstead, we would do a data migration to take care of those tasks, even if it means just deleting them all. However, for this tutorial, for the sake of simplicity, we will stick with this.\n:::\n\n### Updating Operations to Check Authentication\n\nNext, let's update the queries and actions to forbid access to non-authenticated users and to operate only on the currently logged-in user's tasks:\n\n```ts title=\"src/queries.ts\" auto-js\n\n// highlight-next-line\n\nexport const getTasks: GetTasks<void, Task[]> = async (args, context) => {\n  // highlight-start\n  if (!context.user) {\n    throw new HttpError(401)\n  }\n  // highlight-end\n  return context.entities.Task.findMany({\n    // highlight-next-line\n    where: { user: { id: context.user.id } },\n    orderBy: { id: 'asc' },\n  })\n}\n```\n\n```ts title=\"src/actions.ts\" auto-js\n\n// highlight-next-line\n\ntype CreateTaskPayload = Pick<Task, 'description'>\n\nexport const createTask: CreateTask<CreateTaskPayload, Task> = async (\n  args,\n  context\n) => {\n  // highlight-start\n  if (!context.user) {\n    throw new HttpError(401)\n  }\n  // highlight-end\n  return context.entities.Task.create({\n    data: {\n      description: args.description,\n      // highlight-next-line\n      user: { connect: { id: context.user.id } },\n    },\n  })\n}\n\ntype UpdateTaskPayload = Pick<Task, 'id' | 'isDone'>\n\nexport const updateTask: UpdateTask<\n  UpdateTaskPayload,\n  { count: number }\n> = async (args, context) => {\n  // highlight-start\n  if (!context.user) {\n    throw new HttpError(401)\n  }\n  // highlight-end\n  return context.entities.Task.updateMany({\n    where: { id: args.id, user: { id: context.user.id } },\n    data: { isDone: args.isDone },\n  })\n}\n```\n\n:::note\nDue to how Prisma works, we had to convert `update` to `updateMany` in `updateTask` action to be able to specify the user id in `where`.\n:::\n\nWith these changes, each user should have a list of tasks that only they can see and edit.\n\nTry playing around, adding a few users and some tasks for each of them. Then open the DB stu",
        "namespace": "xtasker",
        "timestamp": 1754702855185
      },
      {
        "key": "waspfull_ab",
        "value": "dio:\n\n```sh\nwasp db studio\n```\n\n<img alt=\"Database demonstration\" src={useBaseUrl('img/wasp_db_demonstration.gif')} className=\"tutorial-image\" />\n\nYou will see that each user has their tasks, just as we specified in our code!\n\n### Logout Button\n\nLast, but not least, let's add the logout functionality:\n\n```tsx title=\"src/MainPage.tsx\" auto-js with-hole\n// ...\n// highlight-next-line\n\n//...\n\nconst MainPage = () => {\n  // ...\n  return (\n    <div>\n      {$HOLE$}\n      // highlight-next-line\n      <button onClick={logout}>Logout</button>\n    </div>\n  )\n}\n```\n\nThis is it, we have a working authentication system, and our Todo app is multi-user!\n\n### What's Next?\n\nWe did it 🎉 You've followed along with this tutorial to create a basic Todo app with Wasp.\n\n<ShowForJs>\n  You can find the complete code for the JS version of the tutorial [here](https://github.com/wasp-lang/wasp/tree/release/examples/tutorials/TodoApp).\n</ShowForJs>\n\n<ShowForTs>\n  You can find the complete code for the TS version of the tutorial [here](https://github.com/wasp-lang/wasp/tree/release/examples/tutorials/TodoAppTs).\n</ShowForTs>\n\nYou should be ready to learn about more complicated features and go more in-depth with the features already covered. Scroll through the sidebar on the left side of the page to see every feature Wasp has to offer. Or, let your imagination run wild and start building your app! ✨\n\nLooking for inspiration?\n\n- Get a jump start on your next project with [Starter Templates](../project/starter-templates).\n- Check out our [official examples](https://github.com/wasp-lang/wasp/tree/release/examples).\n- Make a real-time app with [Web Sockets](../advanced/web-sockets).\n\n:::note\nIf you notice that some of the features you'd like to have are missing, or have any other kind of feedback, please write to us on [Discord](https://discord.gg/rzdnErX) or create an issue on [Github](https://github.com/wasp-lang/wasp), so we can learn which features to add/improve next 🙏\n\nIf you would like to contribute or help to build a feature, let us know! You can find more details on contributing [here](contributing.md).\n:::\n\nOh, and do [**subscribe to our newsletter**](/#signup)! We usually send one per month, and Matija does his best to unleash his creativity to make them engaging and fun to read :D!\n\n------\n\n# Data Model\n\n## Entities\n\nEntities are the foundation of your app's data model. In short, an Entity defines a model in your database.\n\nWasp uses the excellent [Prisma ORM](https://www.prisma.io/) to implement all database functionality and occasionally enhances it with a thin abstraction layer. This means that you use the `schema.prisma` file to define your database models and relationships. Wasp understands the Prisma schema file and picks up all the models you define there. You can read more about this in the [Prisma Schema File](./prisma-file.md) section of the docs.\n\nIn your project, you'll find a `schema.prisma` file in the root directory:\n\n```\n.\n├── main.wasp\n...\n├── schema.prisma\n├── src\n├── tsconfig.json\n└── vite.config.ts\n```\n\nPrisma uses the _Prisma Schema Language_, a simple definition language explicitly created for defining models.\nThe language is declarative and very intuitive. We'll also go through an example later in the text, so there's no need to go and thoroughly learn it right away. Still, if you're curious, look no further than Prisma's official documentation:\n\n- [Basic intro and examples](https://www.prisma.io/docs/orm/prisma-schema/overview)\n- [A more exhaustive language specification](https://www.prisma.io/docs/orm/reference/prisma-schema-reference)\n\n### Defining an Entity\n\nA Prisma `model` declaration in the `schema.prisma` file represents a Wasp Entity.\n\n<details>\n  <summary>\n    Entity vs Model\n  </summary>\n\n  You might wonder why we distinguish between a **Wasp Entity** and a **Prisma model** if they're essentially the same thing right now.\n\n  While defining a Prisma model is currently the only way to create an Entity in Wasp, the Entity concept is a higher-level abstraction. We plan to expand on Entities in the future, both in terms of how you can define them and what you can do with them.\n\n  So, think of an Entity as a Wasp concept and a model as a Prisma concept. For now, all Prisma models are Entities and vice versa, but this relationship might evolve as Wasp grows.\n</details>\n\nHere's how you could define an Entity that represents a Task:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```prisma title=\"schema.prisma\"\n    model Task {\n      id          String  @id @default(uuid())\n      description String\n      isDone      Boolean @default(false)\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```prisma title=\"schema.prisma\"\n    model Task {\n      id          String  @id @default(uuid())\n      description String\n      isDone      Boolean @default(false)\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThe above Prisma `model` definition tells Wasp to create a table for storing Tasks where each task has three fields (i.e., the `tasks` table has three columns):\n\n- `id` - A string value serving as a primary key. The database automatically generates it by generating a random unique ID.\n- `description` - A string value for storing the task's description.\n- `isDone` - A boolean value indicating the task's completion status. If you don't set it when creating a new task, the database sets it to `false` by default.\n\n<ShowForTs>\n  Wasp also exposes a type for working with the created Entity. You can import and use it like this:\n\n  ```ts\n  import { Task } from 'wasp/entities'\n\n  const task: Task = { ... }\n\n  // You can also define functions for working with entities\n  function getInfoMessage(task: Task): string {\n    const isDoneText = task.isDone ? \"is done\" : \"is not done\"\n    return `Task '${task.description}' is ${isDoneText}.`\n  }\n  ```\n\n  Using the `Task` type in `getInfoMessageInfo`'s definition connects the argument's type with the `Task` entity.\n\n  This coupling removes duplication and ensures the function keeps the correct signature even if you change the entity. Of course, the function might throw type errors depending on how you change it, but that's precisely what you want!\n\n  Entity types are available everywhere, including the client code:\n\n  ```ts\n  import { Task } from \"wasp/entities\"\n\n  export function ExamplePage() {\n    const task: Task = {\n      id: 123,\n      description: \"Some random task\",\n      isDone: false,\n    }\n    return <div>{task.description}</div>\n  }\n  ```\n\n  The mentioned type safety mechanisms also apply here: changing the task entity in our `schema.prisma` file changes the imported type, which might throw a type error and warn us that our task definition is outdated.\n\n  You'll learn even more about Entity types when you start using [them with operations](#using-entities-in-operations).\n</ShowForTs>\n\n#### Working with Entities\n\nLet's see how you can define and work with Wasp Entities:\n\n1. Create/update some Entities in the `schema.prisma` file.\n2. Run `wasp db migrate-dev`. This command syncs the database model with the Entity definitions the `schema.prisma` file. It does this by creating migration scripts.\n3. Migration scripts are automatically placed in the `migrations/` folder. Make sure to commit this folder into version control.\n4. Use Wasp's JavasScript API to work with the database when implementing Operations (we'll cover this in detail when we talk about [operations](../data-model/operations/overview)).\n\n##### Using Entities in Operations\n\nMost of the time, you will be working with Entities within the context of [Operations (Queries & Actions)](../data-model/operations/overview). We'll see how that's done on the next page.\n\n##### Using Entities directly\n\nIf you need more control, you can directly interact with Entities by importing and using the [Prisma Client](https://www.prisma.io/docs/concepts/components/prisma-client/crud). We recommend sticking with conventional Wasp-provided mechanisms, only resorting to directly using the Prisma client only if you need a feature Wasp doesn't provide.\n\nYou can only use the Prisma Client in your Wasp server code. You can import it like this:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js\n    import { prisma } from 'wasp/server'\n\n    prisma.task.create({\n        description: \"Read the Entities doc\",\n        isDone: true // almost :)\n    })\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts\n    import { prisma } from 'wasp/server'\n\n    prisma.task.create({\n        description: \"Read the Entities doc\",\n        isDone: true // almost :)\n    })\n    ```\n  </TabItem>\n</Tabs>\n\n:::note Available Prisma features in the client\n\nWhile the Prisma Client is not available in your client code, you can still import Prisma there, for accessing\ntype definitions (notably, `enum`s).\n\nYou can see more information in the overview of [supported Prisma Schema features](./prisma-file.md#the-enum-blocks).\n\n:::\n\n#### Next steps\n\nNow that we've seen how to define Entities that represent Wasp's core data model, we'll see how to make the most of them in other parts of Wasp. Keep reading to learn all about Wasp Operations!\n\n## Operations Overview\n\nWhile Entities enable you to define your app's data model and relationships, Operations are all about working with this data.\n\nThere are two kinds of Operations: [Queries](../../data-model/operations/queries.md) and [Actions](../../data-model/operations/actions.md). As their names suggest,\nQueries are meant for reading data, and Actions are meant for changing it (either by updating existing entries or creating new ones).\n\nKeep reading to find out all there is to know about Operations in Wasp.\n\n## Queries\n\nWe'll explain what Queries are and how to use them. If you're looking for a detailed API specification, skip ahead to the [API Reference](#api-reference).\n\nYou can use Queries to fetch data from the server. They shouldn't modify the server's state.\nFetching all comments on a blog post, a list of users that liked a video, information about a single product based on its ID... All of these are perfect use cases for a Query.\n\n:::tip\nQueries are fairly similar to Actions in terms of their API.\nTherefore, if you're already familiar with Actions, you might find reading the entire guide repetitive.\n\nWe instead recommend skipping ahead and only reading [the differences between Queries and Actions](../../data-model/operations/actions#differences-between-queries-and-actions), and consulting the [API Reference](#api-reference) as needed.\n:::\n\n### Working with Queries\n\nYou declare queries in the `.wasp` file and implement them using NodeJS. Wasp not only runs these queries within the server's context but also creates code that enables you to call them from any part of your codebase, whether it's on the client or server side.\n\nThis means you don't have to build an HTTP API for your query, manage server-side request handling, or even deal with client-side response handling and caching.\nInstead, just concentrate on implementing the business logic inside your query, and let Wasp handle the rest!\n\nTo create a Query, you must:\n\n1. Declare the Query in Wasp using the `query` declaration.\n2. Define the Query's NodeJS implementation.\n\nAfter completing these two steps, you'll be able to use the Query from any point in your code.\n\n#### Declaring Queries\n\nTo create a Query in Wasp, we begin with a `query` declaration.\n\nLet's declare two Queries - one to fetch all tasks, and another to fetch tasks based on a filter, such as whether a task is done:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    query getAllTasks {\n      fn: import { getAllTasks } from \"@src/queries.js\"\n    }\n\n    query getFilteredTasks {\n      fn: import { getFilteredTasks } from \"@src/queries.js\"\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    query getAllTasks {\n      fn: import { getAllTasks } from \"@src/queries.js\"\n    }\n\n    query getFilteredTasks {\n      fn: import { getFilteredTasks } from \"@src/queries.js\"\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n<small>\n  If you want to know about all supported options for the `query` declaration, take a look at the [API Reference](#api-reference).\n</small>\n\nThe names of Wasp Queries and their implementations don't need to match, but we'll keep them the same to avoid confusion.\n\n:::info\nYou might have noticed that we told Wasp to import Query implementations that don't yet exist. Don't worry about that for now. We'll write the implementations imported from `queries.{js,ts}` in the next section.\n\nIt's a good idea to start with the high-level concept (the Query declaration in the Wasp file) and only then deal with the implementation details (the Query's implementation in JavaScript).\n:::\n\nAfter declaring a Wasp Query, two important things happen:\n\n- Wasp **generates a server-side NodeJS function** that shares its name with the Query.\n\n- Wasp **generates a client-side JavaScript function** that shares its name with the Query (e.g., `getFilteredTasks`).\n  This function takes a single optional argument - an object containing any serializable data you wish to use inside the Query.\n  Wasp will send this object over the network and pass it into the Query's implementation as its first positional argument (more on this when we look at the implementations).\n  Such an abstraction works thanks to an HTTP API route handler Wasp generates on the server, which calls the Query's NodeJS implementation under the hood.\n\nGenerating these two functions ensures a similar calling interface across the entire app (both client and server).\n\n#### Implementing Queries in Node\n\nNow that we've declared the Query, what remains is to implement it.\nWe've instructed Wasp to look for the Queries' implementations in the file `src/queries.{js,ts}`, so that's where we should export them from.\n\nHere's how you might implement the previously declared Queries `getAllTasks` and `getFilteredTasks`:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/queries.js\"\n    // our \"database\"\n    const tasks = [\n      { id: 1, description: 'Buy some eggs', isDone: true },\n      { id: 2, description: 'Make an omelette', isDone: false },\n      { id: 3, description: 'Eat breakfast', isDone: false },\n    ]\n\n    // You don't need to use the arguments if you don't need them\n    export const getAllTasks = () => {\n      return tasks\n    }\n\n    // The 'args' object is something sent by the caller (most often from the client)\n    export const getFilteredTasks = (args) => {\n      const { isDone } = args\n      return tasks.filter((task) => task.isDone === isDone)\n    }\n    ```\n\n    <SuperjsonNote />\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/queries.ts\"\n    import { type GetAllTasks, type GetFilteredTasks } from 'wasp/server/operations'\n\n    type Task = {\n      id: number\n      description: string\n      isDone: boolean\n    }\n\n    // our \"database\"\n    const tasks: Task[] = [\n      { id: 1, description: 'Buy some eggs', isDone: true },\n      { id: 2, description: 'Make an omelette', isDone: false },\n      { id: 3, description: 'Eat breakfast', isDone: false },\n    ]\n\n    // You don't need to use the arguments if you don't need them\n    export const getAllTasks: GetAllTasks<void, Task[]> = () => {\n      return tasks\n    }\n\n    // The 'args' object is something sent by the caller (most often from the client)\n    export const getFilteredTasks: GetFilteredTasks<\n      Pick<Task, 'isDone'>,\n      Task[]\n    > = (args) => {\n      const { isDone } = args\n      return tasks.filter((task) => task.isDone === isDone)\n    }\n    ```\n\n    <SuperjsonNote />\n\n    #### Type support for Queries\n\n    Wasp automatically generates the types `GetAllTasks` and `GetFilteredTasks` based on your Wasp file's declarations:\n\n    - `GetAllTasks` is a generic type automatically generated by Wasp, based on the Query declaration for `getAllTasks`.\n    - `GetFilteredTasks` is also a generic type automatically generated by Wasp, based on the Query declaration for `getFilteredTasks`.\n\n    Use these types to type the Query's implementation.\n    It's optional but very helpful since doing so properly types the Query's context.\n\n    In this case, TypeScript will know the `context.entities` object must include the `Task` entity.\n    TypeScript also knows whether the `context` object includes user information (it depends on whether your Query uses auth).\n\n    The generated types are generic and accept two optional type arguments: `Input` and `Output`.\n\n    1. `Input` - The argument (the payload) received by the Query function.\n    2. `Output` - The Query function's return type.\n\n    Use these type arguments to type the Query's inputs and outputs.\n\n    <details>\n      <summary>Explanation for the example above</summary>\n\n      The above code says that the Query `getAllTasks` doesn't expect any arguments (its input type is `void`), but it does return a list of tasks (its output type is `Task[]`).\n\n      On the other hand, the Query `getFilteredTasks` expects an object of type `{ isDone: boolean }`. This type is derived from the `Task` entity type.\n\n      If you don't care about typing the Query's inputs and outputs, you can omit both type arguments. TypeScript will then infer the most general types (`never` for the input and `unknown` for the output).\n\n      Specifying `Input` or `Output` is completely optional, but we highly recommended it. Doing so gives you:\n\n      - Type support for the arguments and the return value inside the implementation.\n      - **Full-stack type safety**. We'll explore what this means when we discuss calling the Query from the client.\n    </details>\n\n    Read more about type support for implementing Queries in the [API Reference](#implementing-queries).\n\n    :::tip Inferring the return type\n\n    If don't want to explicitly type the Query's return value, the `satisfies` keyword tells TypeScript to infer it automatically:\n\n    ```typescript\n    const getFoo = (async (_args, context) => {\n      const foos = await context.entities.Foo.findMany()\n      return {\n        foos,\n        message: 'Here are some foos!',\n        queriedAt: new Date(),\n      }\n    }) satisfies GetFoo\n    ```\n\n    From the snippet above, TypeScript knows:\n\n    1. The correct type for `context`.\n    2. The Query's return type is `{ foos: Foo[], message: string, queriedAt: Date }`.\n\n    If you don't need the context, you can skip specifying the Query's type (and arguments):\n\n    ```typescript\n    const getFoo = () => {{ name: 'Foo', date: new Date() }}\n    ```\n\n    :::\n  </TabItem>\n</Tabs>\n\n<small>\n  For a detailed explanation of the Query definition API (more precisely, its arguments and return values), check the [API Reference](#api-reference).\n</small>\n\n#### Using Queries\n\n##### Using Queries on the client\n\nTo call a Query on the client, you can import it from `wasp/client/operations` and call it directly.\n\nThe usage doesn't change depending on whether the Query is authenticated or not.\nWasp authenticates the logged-in user in the background.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js\n    import { getAllTasks, getFilteredTasks } from 'wasp/client/operations'\n\n    // ...\n\n    const allTasks = await getAllTasks()\n    const doneTasks = await getFilteredTasks({ isDone: true })\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts\n    import { getAllTasks, getFilteredTasks } from 'wasp/client/operations'\n\n    // TypeScript automatically infers the return values and type-checks\n    // the payloads.\n    const allTasks = await getAllTasks()\n    const doneTasks = await getFilteredTasks({ isDone: true })\n    ```\n\n    Wasp supports **automatic full-stack type safety**.\n    You only need to specify the Query's type in its server-side definition, and the client code will automatically know its API payload types.\n  </TabItem>\n</Tabs>\n\n##### Using Queries on the server\n\nCalling a Query on the server is similar to calling it on the client.\n\nHere's what you have to do differently:\n\n- Import Queries from `wasp/server/operations` instead of `wasp/client/operations`.\n- Make sure you pass in a context object with the user to authenticated Queries.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js\n    import { getAllTasks, getFilteredTasks } from 'wasp/server/operations'\n\n    const user = // Get an AuthUser object, e.g., from context.user in an operation.\n\n    // ...\n\n    const allTasks = await getAllTasks({ user })\n    const doneTasks = await getFilteredTasks({ isDone: true }, { user })\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts\n    import { getAllTasks, getFilteredTasks } from 'wasp/server/operations'\n\n    const user = // Get an AuthUser object, e.g., from context.user in an operation.\n\n    // TypeScript automatically infers the return values and type-checks\n    // the payloads.\n    const allTasks = await getAllTasks({ user })\n    const doneTasks = await getFilteredTasks({ isDone: true }, { user })\n    ```\n  </TabItem>\n</Tabs>\n\n##### The `useQuery` hook\n\nWhen using Queries on the client, you can make them reactive with the `useQuery` hook.\nThis hook comes bundled with Wasp and is a thin wrapper around the `useQuery` hook from [_react-query_](https://github.com/tannerlinsley/react-query). The only difference is that you don't need to supply the key - Wasp handles this for you automatically.\n\nHere's an example of calling the Queries using the `useQuery` hook:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/MainPage.jsx\"\n    import React from 'react'\n    import { useQuery, getAllTasks, getFilteredTasks } from 'wasp/client/operations'\n\n    const MainPage = () => {\n      const { data: allTasks, error: error1 } = useQuery(getAllTasks)\n      const { data: doneTasks, error: error2 } = useQuery(getFilteredTasks, {\n        isDone: true,\n      })\n\n      if (error1 !== null || error2 !== null) {\n        return <div>There was an error</div>\n      }\n\n      return (\n        <div>\n          <h2>All Tasks</h2>\n          {allTasks && allTasks.length > 0\n            ? allTasks.map((task) => <Task key={task.id} {...task} />)\n            : 'No tasks'}\n\n          <h2>Finished Tasks</h2>\n          {doneTasks && doneTasks.length > 0\n            ? doneTasks.map((task) => <Task key={task.id} {...task} />)\n            : 'No finished tasks'}\n        </div>\n      )\n    }\n\n    const Task = ({ description, isDone }: Task) => {\n      return (\n        <div>\n          <p>\n            <strong>Description: </strong>\n            {description}\n          </p>\n          <p>\n            <strong>Is done: </strong>\n            {isDone ? 'Yes' : 'No'}\n          </p>\n        </div>\n      )\n    }\n\n    export default MainPage\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/MainPage.tsx\"\n    import React from 'react'\n    import { type Task } from 'wasp/entities'\n    import { useQuery, getAllTasks, getFilteredTasks } from 'wasp/client/operations'\n\n    const MainPage = () => {\n      // TypeScript automatically infers return values and type-checks payload types.\n      const { data: allTasks, error: error1 } = useQuery(getAllTasks)\n      const { data: doneTasks, error: error2 } = useQuery(getFilteredTasks, {\n        isDone: true,\n      })\n\n      if (error1 !== null || error2 !== null) {\n        return <div>There was an error</div>\n      }\n\n      return (\n        <div>\n          <h2>All Tasks</h2>\n          {allTasks && allTasks.length > 0\n            ? allTasks.map((task) => <Task key={task.id} {...task} />)\n            : 'No tasks'}\n\n          <h2>Finished Tasks</h2>\n          {doneTasks && doneTasks.length > 0\n            ? doneTasks.map((task) => <Task key={task.id} {...task} />)\n            : 'No finished tasks'}\n        </div>\n      )\n    }\n\n    const Task = ({ description, isDone }: Task) => {\n      return (\n        <div>\n          <p>\n            <strong>Description: </strong>\n            {description}\n          </p>\n          <p>\n            <strong>Is done: </strong>\n            {isDone ? 'Yes' : 'No'}\n          </p>\n        </div>\n      )\n    }\n\n    export default MainPage\n    ```\n\n    Notice how you don't need to annotate the Query's return value type. Wasp automatically infers the from the Query's backend implementation. This is **full-stack type safety**: the types on the client always match the types on the server.\n  </TabItem>\n</Tabs>\n\n<small>\n  For a detailed specification of the `useQuery` hook, check the [API Reference](#api-reference).\n</small>\n\n#### Error Handling\n\nFor security reasons, all exceptions thrown in the Query's NodeJS implementation are sent to the client as responses with the HTTP status code `500`, with all other details removed.\nHiding error details by default helps against accidentally leaking possibly sensitive information over the network.\n\nIf you do want to pass additional error information to the client, you can construct and throw an appropriate `HttpError` in your implementation:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/queries.js\"\n    import { HttpError } from 'wasp/server'\n\n    export const getAllTasks = async (args, context) => {\n      throw new HttpError(\n        403, // status code\n        \"You can't do this!\", // message\n        { foo: 'bar' } // data\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/queries.ts\"\n    import { type GetAllTasks } from 'wasp/server/operations'\n    import { HttpError } from 'wasp/server'\n\n    export const getAllTasks: GetAllTasks = async (args, context) => {\n      throw new HttpError(\n        403, // status code\n        \"You can't do this!\", // message\n        { foo: 'bar' } // data\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nIf the status code is `4xx`, the client will receive a response object with the corresponding `message` and `data` fields, and it will rethrow the error (including these fields).\nTo prevent information leakage, the server won't forward these fields for any other HTTP status codes.\n\n#### Using Entities in Queries\n\nIn most cases, resources used in Queries will be [Entities](../../data-model/entities.md).\nTo use an Entity in your Query, add it to the `query` declaration in Wasp:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp {4,9} title=\"main.wasp\"\n\n    query getAllTasks {\n      fn: import { getAllTasks } from \"@src/queries.js\",\n      entities: [Task]\n    }\n\n    query getFilteredTasks {\n      fn: import { getFilteredTasks } from \"@src/queries.js\",\n      entities: [Task]\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp {4,9} title=\"main.wasp\"\n\n    query getAllTasks {\n      fn: import { getAllTasks } from \"@src/queries.js\",\n      entities: [Task]\n    }\n\n    query getFilteredTasks {\n      fn: import { getFilteredTasks } from \"@src/queries.js\",\n      entities: [Task]\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nWasp will inject the specified Entity into the Query's `context` argument, giving you access to the Entity's Prisma API:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/queries.js\"\n    export const getAllTasks = async (args, context) => {\n      return context.entities.Task.findMany({})\n    }\n\n    export const getFilteredTasks = async (args, context) => {\n      return context.entities.Task.findMany({\n        where: { isDone: args.isDone },\n      })\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/queries.ts\"\n    import { type Task } from 'wasp/entities'\n    import { type GetAllTasks, type GetFilteredTasks } from 'wasp/server/operations'\n\n    export const getAllTasks: GetAllTasks<void, Task[]> = async (args, context) => {\n      return context.entities.Task.findMany({})\n    }\n\n    export const getFilteredTasks: GetFilteredTasks<\n      Pick<Task, 'isDone'>,\n      Task[]\n    > = async (args, context) => {\n      return context.entities.Task.findMany({\n        where: { isDone: args.isDone },\n      })\n    }\n    ```\n\n    Again, annotating the Queries is optional, but greatly improves **full-stack type safety**.\n  </TabItem>\n</Tabs>\n\nThe object `context.entities.Task` exposes `prisma.task` from [Prisma's CRUD API](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud).\n\n### API Reference\n\n#### Declaring Queries\n\nThe `query` declaration supports the following fields:\n\n- `fn: ExtImport` Required!\n\n  The import statement of the Query's NodeJs implementation.\n\n- `entities: [Entity]`\n\n  A list of entities you wish to use inside your Query.\n  For instructions on using Entities in Queries, take a look at [the guide](#using-entities-in-queries).\n\n##### Example\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    Declaring the Query:\n\n    ```wasp\n    query getFoo {\n        fn: import { getFoo } from \"@src/queries.js\"\n        entities: [Foo]\n    }\n    ```\n\n    Enables you to import and use it anywhere in your code (on the server or the client):\n\n    ```js\n    // Use it on the client\n    import { getFoo } from 'wasp/client/operations'\n\n    // Use it on the server\n    import { getFoo } from 'wasp/server/operations'\n    ```\n\n    On the client, the Query expects\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    Declaring the Query:\n\n    ```wasp\n    query getFoo {\n        fn: import { getFoo } from \"@src/queries.js\"\n        entities: [Foo]\n    }\n    ```\n\n    Enables you to import and use it anywhere in your code (on the server or the client):\n\n    ```ts\n    // Use it on the client\n    import { getFoo } from 'wasp/client/operations'\n\n    // Use it on the server\n    import { getFoo } from 'wasp/server/operations'\n    ```\n\n    And also creates a type you can import on the server:\n\n    ```ts\n    import { type GetFoo } from 'wasp/server/operations'\n    ```\n  </TabItem>\n</Tabs>\n\n#### Implementing Queries\n\nThe Query's implementation is a NodeJS function that takes two arguments (it can be an `async` function if you need to use the `await` keyword).\nSince both arguments are positional, you can name the parameters however you want, but we'll stick with `args` and `context`:\n\n1. `args` (type depends on the Query)\n\n   An object containing the data **passed in when calling the query** (e.g., filtering conditions).\n   Check [the usage examples](#using-queries) to see how to pass this object to the Query.\n\n2. `context` (type depends on the Query)\n\n   An additional context object **passed into the Query by Wasp**. This object contains user session information, as well as information about entities. Check the [section about using entities in Queries](#using-entities-in-queries) to see how to use the entities field on the `context` object, or the [auth section](../../auth/overview#using-the-contextuser-object) to see how to use the `user` object.\n\n<ShowForTs>\n  After you [declare the query](#declaring-queries), Wasp generates a generic type you can use when defining its implementation.\n  For the Query declared as `getSomething`, the generated type is called `GetSomething`:\n\n  ```ts\n  import { type GetSomething } from 'wasp/server/operations'\n  ```\n\n  It expects two (optional) type arguments:\n\n  1. `Input`\n\n     The type of the `args` object (the Query's input payload). The default value is `never`.\n\n  2. `Output`\n\n     The type of the Query's return value (the Query's output payload). The default value is `unknown`.\n\n  The defaults were chosen to make the type signature as permissive as possible. If don't want your Query to take/return anything, use `void` as a type argument.\n</ShowForTs>\n\n##### Example\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    The following Query:\n\n    ```wasp\n    query getFoo {\n        fn: import { getFoo } from \"@src/queries.js\"\n        entities: [Foo]\n    }\n    ```\n\n    Expects to find a named export `getFoo` from the file `src/queries.js`\n\n    ```js title=\"queries.js\"\n    export const getFoo = (args, context) => {\n      // implementation\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    The following Query:\n\n    ```wasp\n    query getFoo {\n        fn: import { getFoo } from \"@src/queries.js\"\n        entities: [Foo]\n    }\n    ```\n\n    Expects to find a named export `getFoo` from the file `src/queries.js`\n\n    You can use the generated type `GetFoo` and specify the Query's inputs and outputs using its type arguments.\n\n    ```ts title=\"queries.ts\"\n    import { type GetFoo } from 'wasp/server/operations'\n\n    type Foo = // ...\n\n    export const getFoo: GetFoo<{ id: number }, Foo> = (args, context) => {\n      // implementation\n    };\n    ```\n\n    In this case, the Query expects to receive an object with an `id` field of type `number` (this is the type of `args`), and return a value of type `Foo` (this must match the type of the Query's return value).\n  </TabItem>\n</Tabs>\n\n#### The `useQuery` Hook\n\nWasp's `useQuery` hook is a thin wrapper around the `useQuery` hook from [_react-query_](https://github.com/tannerlinsley/react-query).\nOne key difference is that Wasp doesn't expect you to supply the cache key - it takes care of it under the hood.\n\nWasp's `useQuery` hook accepts three arguments:\n\n- `queryFn` Required!\n\n  The client-side query function generated by Wasp based on a `query` declaration in your `.wasp` file.\n\n- `queryFnArgs`\n\n  The arguments object (payload) you wish to pass into the Query. The Query's NodeJS implementation will receive this object as its first positional argument.\n\n- `options`\n\n  A _react-query_ `options` object. Use this to change\n  [the default\n  behavior](https://react-query.tanstack.com/guides/important-defaults) for\n  this particular Query. If you want to change the global defaults, you can do\n  so in the [client setup function](../../project/client-config.md#overriding-default-behaviour-for-queries).\n\nFor an example of usage, check [this section](#the-usequery-hook).\n\n## Actions\n\nWe'll explain what Actions are and how to use them. If you're looking for a detailed API specification, skip ahead to the [API Reference](#api-reference).\n\nActions are quite similar to [Queries](../../data-model/operations/queries.md), but with a key distinction: Actions are designed to modify and add data, while Queries are solely for reading data. Examples of Actions include adding a comment to a blog post, liking a video, or updating a product's price.\n\nActions and Queries work together to keep data caches up-to-date.\n\n:::tip\nActions are almost identical to Queries in terms of their API.\nTherefore, if you're already familiar with Queries, you might find reading the entire guide repetitive.\n\nWe instead recommend skipping ahead and only reading [the differences between Queries and Actions](#differences-between-queries-and-actions), and consulting the [API Reference](#api-reference) as needed.\n:::\n\n### Working with Actions\n\nActions are declared in Wasp and implemented in NodeJS. Wasp runs Actions within the server's context, but it also generates code that allows you to call them from anywhere in your code (either client or server) using the same interface.\n\nThis means you don't have to worry about building an HTTP API for the Action, managing server-side request handling, or even dealing with client-side response handling and caching.\nInstead, just focus on developing the business logic inside your Action, and let Wasp handle the rest!\n\nTo create an Action, you need to:\n\n1. Declare the Action in Wasp using the `action` declaration.\n2. Implement the Action's NodeJS functionality.\n\nOnce these two steps are completed, you can use the Action from anywhere in your code.\n\n#### Declaring Actions\n\nTo create an Action in Wasp, we begin with an `action` declaration. Let's declare two Actions - one for creating a task, and another for marking tasks as done:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    action createTask {\n      fn: import { createTask } from \"@src/actions.js\"\n    }\n\n    action markTaskAsDone {\n      fn: import { markTaskAsDone } from \"@src/actions.js\"\n    }\n\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    action createTask {\n      fn: import { createTask } from \"@src/actions.js\"\n    }\n\n    action markTaskAsDone {\n      fn: import { markTaskAsDone } from \"@src/actions.js\"\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n<small>\n  If you want to know about all supported options for the `action` declaration, take a look at the [API Reference](#api-reference).\n</small>\n\nThe names of Wasp Actions and their implementations don't necessarily have to match. However, to avoid confusion, we'll keep them the same.\n\n:::info\nYou might have noticed that we told Wasp to import Action implementations that don't yet exist. Don't worry about that for now. We'll write the implementations imported from `actions.{js,ts}` in the next section.\n\nIt's a good idea to start with the high-level concept (the Action declaration in the Wasp file) and only then deal with the implementation details (the Action's implementation in JavaScript).\n:::\n\nAfter declaring a Wasp Action, two important things happen:\n\n- Wasp **generates a server-side NodeJS function** that shares its name with the Action.\n\n- Wasp **generates a client-side JavaScript function** that shares its name with the Action (e.g., `markTaskAsDone`).\n  This function takes a single optional argument - an object containing any serializable data you wish to use inside the Action.\n  Wasp will send this object over the network and pass it into the Action's implementation as its first positional argument (more on this when we look at the implementations).\n  Such an abstraction works thanks to an HTTP API route handler Wasp generates on the server, which calls the Action's NodeJS implementation under the hood.\n\nGenerating these two functions ensures a similar calling interface across the entire app (both client and server).\n\n#### Implementing Actions in Node\n\nNow that we've declared the Action, what remains is to implement it. We've instructed Wasp to look for the Actions' implementations in the file `src/actions.{js,ts}`, so that's where we should export them from.\n\nHere's how you might implement the previously declared Actions `createTask` and `markTaskAsDone`:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/actions.js\"\n    // our \"database\"\n    let nextId = 4\n    const tasks = [\n      { id: 1, description: 'Buy some eggs', isDone: true },\n      { id: 2, description: 'Make an omelette', isDone: false },\n      { id: 3, description: 'Eat breakfast', isDone: false },\n    ]\n\n    // You don't need to use the arguments if you don't need them\n    export const createTask = (args) => {\n      const newTask = {\n        id: nextId,\n        isDone: false,\n        description: args.description,\n      }\n      nextId += 1\n      tasks.push(newTask)\n      return newTask\n    }\n\n    // The 'args' object is something sent by the caller (most often from the client)\n    export const markTaskAsDone = (args) => {\n      const task = tasks.find((task) => task.id === args.id)\n      if (!task) {\n        // We'll show how to properly handle such errors later\n        return\n      }\n      task.isDone = true\n    }\n    ```\n\n    <SuperjsonNote />\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/actions.ts\"\n    import { type CreateTask, type MarkTaskAsDone } from 'wasp/server/operations'\n\n    type Task = {\n      id: number\n      description: string\n      isDone: boolean\n    }\n\n    // our \"database\"\n    let nextId = 4\n    const tasks = [\n      { id: 1, description: 'Buy some eggs', isDone: true },\n      { id: 2, description: 'Make an omelette', isDone: false },\n      { id: 3, description: 'Eat breakfast', isDone: false },\n    ]\n\n    // You don't need to use the arguments if you don't need them\n    export const createTask: CreateTask<Pick<Task, 'description'>, Task> = (\n      args\n    ) => {\n      const newTask = {\n        id: nextId,\n        isDone: false,\n        description: args.description,\n      }\n      nextId += 1\n      tasks.push(newTask)\n      return newTask\n    }\n\n    // The 'args' object is something sent by the caller (most often from the client)\n    export const markTaskAsDone: MarkTaskAsDone<Pick<Task, 'id'>, void> = (\n      args\n    ) => {\n      const task = tasks.find((task) => task.id === args.id)\n      if (!task) {\n        // We'll show how to properly handle such errors later\n        return\n      }\n      task.isDone = true\n    }\n    ```\n\n    <SuperjsonNote />\n\n    #### Type support for Actions\n\n    Wasp automatically generates the types `CreateTask` and `MarkTaskAsDone` based on the declarations in your Wasp file:\n\n    - `CreateTask` is a generic type that Wasp automatically generated based on the Action declaration for `createTask`.\n    - `MarkTaskAsDone` is a generic type that Wasp automatically generated based on the Action declaration for `markTaskAsDone`.\n\n    Use these types to type the Action's implementation.\n    It's optional but very helpful since doing so properly types the Action's context.\n\n    In this case, TypeScript will know the `context.entities` object must include the `Task` entity.\n    TypeScript also knows whether the `context` object includes user information (it depends on whether your Action uses auth).\n\n    The generated types are generic and accept two optional type arguments: `Input` and `Output`.\n\n    1. `Input` - The argument (the payload) received by the Action function.\n    2. `Output` - The Action function's return type.\n\n    Use these type arguments to type the Action's inputs and outputs.\n\n    <details>\n      <summary>Explanation for the example above</summary>\n\n      The above code says that the Action `createTask` expects an object with the new task's description (its input type is `Pick<Task, 'description'>`) and returns the new task (its output type is `Task`).\n\n      On the other hand, the Action `markTaskAsDone` expects an object of type `Pick<Task, 'id'>`. This type is derived from the `Task` entity type.\n\n      If you don't care about typing the Action's inputs and outputs, you can omit both type arguments.\n      TypeScript will then infer the most general types (`never` for the input and `unknown` for the output).\n\n      Specifying `Input` or `Output` is completely optional, but we highly recommended it. Doing so gives you:\n\n      - Type support for the arguments and the return value inside the implementation.\n      - **Full-stack type safety**. We'll explore what this means when we discuss calling the Action from the client.\n    </details>\n\n    Read more about type support for implementing Actions in the [API Reference](#implementing-actions).\n\n    :::tip Inferring the return type\n\n    If don't want to explicitly type the Action's return value, the `satisfies` keyword tells TypeScript to infer it automatically:\n\n    ```typescript\n    const createFoo = (async (_args, context) => {\n      const foo = await context.entities.Foo.create()\n      return {\n        newFoo: foo,\n        message: \"Here's your foo!\",\n        returnedAt: new Date(),\n      }\n    }) satisfies GetFoo\n    ```\n\n    From the snippet above, TypeScript knows:\n\n    1. The correct type for `context`.\n    2. The Action's return type is `{ newFoo: Foo, message: string, returnedAt: Date }`.\n\n    If you don't need the context, you can skip specifying the Action's type (and arguments):\n\n    ```typescript\n    const createFoo = () => {{ name: 'Foo', date: new Date() }}\n    ```\n\n    :::\n  </TabItem>\n</Tabs>\n\n<small>\n  For a detailed explanation of the Action definition API (more precisely, its arguments and return values), check the [API Reference](#api-reference).\n</small>\n\n#### Using Actions\n\n##### Using Actions on the client\n\nTo call an Action on the client, you can import it from `wasp/client/operations` and call it directly.\n\nThe usage doesn't depend on whether the Action is authenticated or not.\nWasp authenticates the logged-in user in the background.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js\n    import { createTask, markTaskAsDone } from 'wasp/client/operations'\n\n    // ...\n\n    const newTask = await createTask({ description: 'Learn TypeScript' })\n    await markTaskAsDone({ id: 1 })\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts\n    import { createTask, markTaskAsDone } from 'wasp/client/operations'\n\n    // TypeScript automatically infers the return values and type-checks\n    // the payloads.\n    const newTask = await createTask({ description: 'Keep learning TypeScript' })\n    await markTaskAsDone({ id: 1 })\n    ```\n\n    Wasp supports **automatic full-stack type safety**.\n    You only need to specify the Action's type in its server-side definition, and the client code will automatically know its API payload types.\n  </TabItem>\n</Tabs>\n\nWhen using Actions on the client, you'll most likely want to use them inside a component:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/pages/Task.jsx\"\n    import React from 'react'\n    // highlight-next-line\n    import { useQuery, getTask, markTaskAsDone } from 'wasp/client/operations'\n\n    export const TaskPage = ({ id }) => {\n      const { data: task } = useQuery(getTask, { id })\n\n      if (!task) {\n        return <h1>\"Loading\"</h1>\n      }\n\n      const { description, isDone } = task\n      return (\n        <div>\n          <p>\n            <strong>Description: </strong>\n            {description}\n          </p>\n          <p>\n            <strong>Is done: </strong>\n            {isDone ? 'Yes' : 'No'}\n          </p>\n          {isDone || (\n            // highlight-next-line\n            <button onClick={() => markTaskAsDone({ id })}>Mark as done.</button>\n          )}\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/pages/Task.tsx\"\n    import React from 'react'\n    // highlight-next-line\n    import { useQuery, getTask, markTaskAsDone } from 'wasp/client/operations'\n\n    export const TaskPage = ({ id }: { id: number }) => {\n      const { data: task } = useQuery(getTask, { id })\n\n      if (!task) {\n        return <h1>\"Loading\"</h1>\n      }\n\n      const { description, isDone } = task\n      return (\n        <div>\n          <p>\n            <strong>Description: </strong>\n            {description}\n          </p>\n          <p>\n            <strong>Is done: </strong>\n            {isDone ? 'Yes' : 'No'}\n          </p>\n          {isDone || (\n            // highlight-next-line\n            <button onClick={() => markTaskAsDone({ id })}>Mark as done.</button>\n          )}\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nSince Actions don't require reactivity, they are safe to use inside components without a hook. Still, Wasp provides comes with the `useAction` hook you can use to enhance actions. Read all about it in the [API Reference](#api-reference).\n\n##### Using Actions on the server\n\nCalling an Action on the server is similar to calling it on the client.\n\nHere's what you have to do differently:\n\n- Import Actions from `wasp/server/operations` instead of `wasp/client/operations`.\n- Make sure you pass in a context object with the user to authenticated Actions.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js\n    import { createTask, markTaskAsDone } from 'wasp/server/operations'\n\n    const user = // Get an AuthUser object, e.g., from context.user\n\n    const newTask = await createTask(\n      { description: 'Learn TypeScript' },\n      { user },\n    )\n    await markTaskAsDone({ id: 1 }, { user })\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts\n    import { createTask, markTaskAsDone } from 'wasp/server/operations'\n\n    const user = // Get an AuthUser object, e.g., from context.user\n\n    // TypeScript automatically infers the return values and type-checks\n    // the payloads.\n    const newTask = await createTask(\n      { description: 'Keep learning TypeScript' },\n      { user },\n    )\n    await markTaskAsDone({ id: 1 }, { user })\n    ```\n  </TabItem>\n</Tabs>\n\n#### Error Handling\n\nFor security reasons, all exceptions thrown in the Action's NodeJS implementation are sent to the client as responses with the HTTP status code `500`, with all other details removed.\nHiding error details by default helps against accidentally leaking possibly sensitive information over the network.\n\nIf you do want to pass additional error information to the client, you can construct and throw an appropriate `HttpError` in your implementation:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/actions.js\"\n    import { HttpError } from 'wasp/server'\n\n    export const createTask = async (args, context) => {\n      throw new HttpError(\n        403, // status code\n        \"You can't do this!\", // message\n        { foo: 'bar' } // data\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/actions.ts\"\n    import { type CreateTask } from 'wasp/server/operations'\n    import { HttpError } from 'wasp/server'\n\n    export const createTask: CreateTask = async (args, context) => {\n      throw new HttpError(\n        403, // status code\n        \"You can't do this!\", // message\n        { foo: 'bar' } // data\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n#### Using Entities in Actions\n\nIn most cases, resources used in Actions will be [Entities](../../data-model/entities.md).\nTo use an Entity in your Action, add it to the `action` declaration in Wasp:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp {4,9} title=\"main.wasp\"\n\n    action createTask {\n      fn: import { createTask } from \"@src/actions.js\",\n      entities: [Task]\n    }\n\n    action markTaskAsDone {\n      fn: import { markTaskAsDone } from \"@src/actions.js\",\n      entities: [Task]\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp {4,9} title=\"main.wasp\"\n\n    action createTask {\n      fn: import { createTask } from \"@src/actions.js\",\n      entities: [Task]\n    }\n\n    action markTaskAsDone {\n      fn: import { markTaskAsDone } from \"@src/actions.js\",\n      entities: [Task]\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nWasp will inject the specified Entity into the Action's `context` argument, giving you access to the Entity's Prisma API.\nWasp invalidates frontend Query caches by looking at the Entities used by each Action/Query. Read more about Wasp's smart cache invalidation [here](#cache-invalidation).\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/actions.js\"\n    // The 'args' object is the payload sent by the caller (most often from the client)\n    export const createTask = async (args, context) => {\n      ",
        "namespace": "xtasker",
        "timestamp": 1754702859698
      },
      {
        "key": "waspfull_ac",
        "value": "const newTask = await context.entities.Task.create({\n        data: {\n          description: args.description,\n          isDone: false,\n        },\n      })\n      return newTask\n    }\n\n    export const markTaskAsDone = async (args, context) => {\n      await context.entities.Task.update({\n        where: { id: args.id },\n        data: { isDone: true },\n      })\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/actions.ts\"\n    import { type CreateTask, type MarkTaskAsDone } from 'wasp/server/operations'\n    import { type Task } from 'wasp/entities'\n\n    // The 'args' object is the payload sent by the caller (most often from the client)\n    export const createTask: CreateTask<Pick<Task, 'description'>, Task> = async (\n      args,\n      context\n    ) => {\n      const newTask = await context.entities.Task.create({\n        data: {\n          description: args.description,\n          isDone: false,\n        },\n      })\n      return newTask\n    }\n\n    export const markTaskAsDone: MarkTaskAsDone<Pick<Task, 'id'>, void> = async (\n      args,\n      context\n    ) => {\n      await context.entities.Task.update({\n        where: { id: args.id },\n        data: { isDone: true },\n      })\n    }\n    ```\n\n    Again, annotating the Actions is optional, but greatly improves **full-stack type safety**.\n  </TabItem>\n</Tabs>\n\nThe object `context.entities.Task` exposes `prisma.task` from [Prisma's CRUD API](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud).\n\n### Cache Invalidation\n\nOne of the trickiest parts of managing a web app's state is making sure the data returned by the Queries is up to date.\nSince Wasp uses _react-query_ for Query management, we must make sure to invalidate Queries (more specifically, their cached results managed by _react-query_) whenever they become stale.\n\nIt's possible to invalidate the caches manually through several mechanisms _react-query_ provides (e.g., refetch, direct invalidation).\nHowever, since manual cache invalidation quickly becomes complex and error-prone, Wasp offers a faster and a more effective solution to get you started: **automatic Entity-based Query cache invalidation**.\nBecause Actions can (and most often do) modify the state while Queries read it, Wasp invalidates a Query's cache whenever an Action that uses the same Entity is executed.\n\nFor example, if the Action `createTask` and Query `getTasks` both use the Entity `Task`, executing `createTask` may cause the cached result of `getTasks` to become outdated. In response, Wasp will invalidate it, causing `getTasks` to refetch data from the server and update it.\n\nIn practice, this means that Wasp keeps the Queries \"fresh\" without requiring you to think about cache invalidation.\n\nOn the other hand, this kind of automatic cache invalidation can become wasteful (some updates might not be necessary) and will only work for Entities. If that's an issue, you can use the mechanisms provided by _react-query_ for now, and expect more direct support in Wasp for handling those use cases in a nice, elegant way.\n\nIf you wish to optimistically set cache values after performing an Action, you can do so using [optimistic updates](https://stackoverflow.com/a/33009713). Configure them using Wasp's [useAction hook](#the-useaction-hook-and-optimistic-updates). This is currently the only manual cache invalidation mechanism Wasps supports natively. For everything else, you can always rely on _react-query_.\n\n### Differences Between Queries and Actions\n\nActions and Queries are two closely related concepts in Wasp. They might seem to perform similar tasks, but Wasp treats them differently, and each concept represents a different thing.\n\nHere are the key differences between Queries and Actions:\n\n1. Actions can (and often should) modify the server's state, while Queries are only permitted to read it. Wasp relies on you adhering to this convention when performing cache invalidations, so it's crucial to follow it.\n2. Actions don't need to be reactive, so you can call them directly. However, Wasp does provide a [`useAction` React hook](#the-useaction-hook-and-optimistic-updates) for adding extra behavior to the Action (like optimistic updates).\n3. `action` declarations in Wasp are mostly identical to `query` declarations. The only difference lies in the declaration's name.\n\n### API Reference\n\n#### Declaring Actions in Wasp\n\nThe `action` declaration supports the following fields:\n\n- `fn: ExtImport` Required!\n\n  The import statement of the Action's NodeJs implementation.\n\n- `entities: [Entity]`\n\n  A list of entities you wish to use inside your Action.\n  For instructions on using Entities in Actions, take a look at [the guide](#using-entities-in-actions).\n\n##### Example\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    Declaring the Action:\n\n    ```wasp\n    query createFoo {\n        fn: import { createFoo } from \"@src/actions.js\"\n        entities: [Foo]\n    }\n    ```\n\n    Enables you to import and use it anywhere in your code (on the server or the client):\n\n    ```js\n    // Use it on the client\n    import { createFoo } from 'wasp/client/operations'\n\n    // Use it on the server\n    import { createFoo } from 'wasp/server/operations'\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    Declaring the Action:\n\n    ```wasp\n    query createFoo {\n        fn: import { createFoo } from \"@src/actions.js\"\n        entities: [Foo]\n    }\n    ```\n\n    Enables you to import and use it anywhere in your code (on the server or the client):\n\n    ```ts\n    // Use it on the client\n    import { createFoo } from 'wasp/client/operations'\n\n    // Use it on the server\n    import { createFoo } from 'wasp/server/operations'\n    ```\n\n    As well as the following type import on the server:\n\n    ```ts\n    import { type CreateFoo } from 'wasp/server/operations'\n    ```\n  </TabItem>\n</Tabs>\n\n#### Implementing Actions\n\nThe Action's implementation is a NodeJS function that takes two arguments (it can be an `async` function if you need to use the `await` keyword).\nSince both arguments are positional, you can name the parameters however you want, but we'll stick with `args` and `context`:\n\n1. `args` (type depends on the Action)\n\n   An object containing the data **passed in when calling the Action** (e.g., filtering conditions).\n   Check [the usage examples](#using-actions) to see how to pass this object to the Action.\n\n2. `context` (type depends on the Action)\n\n   An additional context object **passed into the Action by Wasp**. This object contains user session information, as well as information about entities. Check the [section about using entities in Actions](#using-entities-in-actions) to see how to use the entities field on the `context` object, or the [auth section](../../auth/overview#using-the-contextuser-object) to see how to use the `user` object.\n\n<ShowForTs>\n  After you [declare the Action](#declaring-actions), Wasp generates a generic type you can use when defining its implementation.\n  For the Action declared as `createSomething`, the generated type is called `CreateSomething`:\n\n  ```ts\n  import { type CreateSomething } from 'wasp/server/operations'\n  ```\n\n  It expects two (optional) type arguments:\n\n  1. `Input`\n\n     The type of the `args` object (the Action's input payload). The default value is `never`.\n\n  2. `Output`\n\n     The type of the Action's return value (the Action's output payload). The default value is `unknown`.\n\n  The defaults were chosen to make the type signature as permissive as possible. If don't want your Action to take/return anything, use `void` as a type argument.\n</ShowForTs>\n\n##### Example\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    The following Action:\n\n    ```wasp\n    action createFoo {\n        fn: import { createFoo } from \"@src/actions.js\"\n        entities: [Foo]\n    }\n    ```\n\n    Expects to find a named export `createfoo` from the file `src/actions.js`\n\n    ```js title=\"actions.js\"\n    export const createFoo = (args, context) => {\n      // implementation\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    The following Action:\n\n    ```wasp\n    action createFoo {\n        fn: import { createFoo } from \"@src/actions.js\"\n        entities: [Foo]\n    }\n    ```\n\n    Expects to find a named export `createfoo` from the file `src/actions.js`\n\n    You can use the generated type `CreateFoo` and specify the Action's inputs and outputs using its type arguments.\n\n    ```ts title=\"actions.ts\"\n    import { type CreateFoo } from 'wasp/server/operations'\n\n    type Foo = // ...\n\n    export const createFoo: CreateFoo<{ bar: string }, Foo> = (args, context) => {\n      // implementation\n    };\n    ```\n\n    In this case, the Action expects to receive an object with a `bar` field of type `string` (this is the type of `args`), and return a value of type `Foo` (this must match the type of the Action's return value).\n  </TabItem>\n</Tabs>\n\n#### The `useAction` Hook and Optimistic Updates\n\nMake sure you understand how [Queries](../../data-model/operations/queries.md) and [Cache Invalidation](#cache-invalidation) work before reading this chapter.\n\nWhen using Actions in components, you can enhance them with the help of the `useAction` hook. This hook comes bundled with Wasp, and is used for decorating Wasp Actions.\nIn other words, the hook returns a function whose API matches the original Action while also doing something extra under the hood (depending on how you configure it).\n\nThe `useAction` hook accepts two arguments:\n\n- `actionFn` Required!\n\n  The Wasp Action (the client-side Action function generated by Wasp based on a Action declaration) you wish to enhance.\n\n- `actionOptions`\n\n  An object configuring the extra features you want to add to the given Action. While this argument is technically optional, there is no point in using the `useAction` hook without providing it (it would be the same as using the Action directly). The Action options object supports the following fields:\n\n  - `optimisticUpdates`\n\n    An array of objects where each object defines an [optimistic update](https://stackoverflow.com/a/33009713) to perform on the Query cache. To define an optimistic update, you must specify the following properties:\n\n    - `getQuerySpecifier` Required!\n\n    A function returning the Query specifier (a value used to address the Query you want to update). A Query specifier is an array specifying the query function and arguments. For example, to optimistically update the Query used with `useQuery(fetchFilteredTasks, {isDone: true }]`, your `getQuerySpecifier` function would have to return the array `[fetchFilteredTasks, { isDone: true}]`. Wasp will forward the argument you pass into the decorated Action to this function (you can use the properties of the added/changed item to address the Query).\n\n    - `updateQuery` Required!\n\n    The function used to perform the optimistic update. It should return the desired state of the cache. Wasp will call it with the following arguments:\n\n    - `item` - The argument you pass into the decorated Action.\n    - `oldData` - The currently cached value for the Query identified by the specifier.\n\n:::caution\nThe `updateQuery` function must be a pure function. It must return the desired cache value identified by the `getQuerySpecifier` function and _must not_ perform any side effects.\n\nAlso, make sure you only update the Query caches affected by your Action causing the optimistic update (Wasp cannot yet verify this).\n\nFinally, your implementation of the `updateQuery` function should work correctly regardless of the state of `oldData` (e.g., don't rely on array positioning). If you need to do something else during your optimistic update, you can directly use _react-query_'s lower-level API (read more about it [here](#advanced-usage)).\n:::\n\nHere's an example showing how to configure the Action `markTaskAsDone` that toggles a task's `isDone` status to perform an optimistic update:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/pages/Task.jsx\"\n    import React from 'react'\n    import {\n      useQuery,\n      useAction,\n      getTask,\n      markTaskAsDone,\n    } from 'wasp/client/operations'\n\n    const TaskPage = ({ id }) => {\n      const { data: task } = useQuery(getTask, { id })\n      // highlight-start\n      const markTaskAsDoneOptimistically = useAction(markTaskAsDone, {\n        optimisticUpdates: [\n          {\n            getQuerySpecifier: ({ id }) => [getTask, { id }],\n            updateQuery: (_payload, oldData) => ({ ...oldData, isDone: true }),\n          },\n        ],\n      })\n      // highlight-end\n\n      if (!task) {\n        return <h1>\"Loading\"</h1>\n      }\n\n      const { description, isDone } = task\n      return (\n        <div>\n          <p>\n            <strong>Description: </strong>\n            {description}\n          </p>\n          <p>\n            <strong>Is done: </strong>\n            {isDone ? 'Yes' : 'No'}\n          </p>\n          {isDone || (\n            <button onClick={() => markTaskAsDoneOptimistically({ id })}>\n              Mark as done.\n            </button>\n          )}\n        </div>\n      )\n    }\n\n    export default TaskPage\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/pages/Task.tsx\"\n    import React from 'react'\n    import {\n      useQuery,\n      useAction,\n      type OptimisticUpdateDefinition,\n      getTask,\n      markTaskAsDone,\n    } from 'wasp/client/operations'\n\n    type TaskPayload = Pick<Task, \"id\">;\n\n    const TaskPage = ({ id }: { id: number }) => {\n      const { data: task } = useQuery(getTask, { id });\n      // Typescript automatically type-checks the payload type.\n      // highlight-start\n      const markTaskAsDoneOptimistically = useAction(markTaskAsDone, {\n        optimisticUpdates: [\n          {\n            getQuerySpecifier: ({ id }) => [getTask, { id }],\n            updateQuery: (_payload, oldData) => ({ ...oldData, isDone: true }),\n          } as OptimisticUpdateDefinition<TaskPayload, Task>,\n        ],\n      });\n      // highlight-end\n\n      if (!task) {\n        return <h1>\"Loading\"</h1>;\n      }\n\n      const { description, isDone } = task;\n      return (\n        <div>\n          <p>\n            <strong>Description: </strong>\n            {description}\n          </p>\n          <p>\n            <strong>Is done: </strong>\n            {isDone ? \"Yes\" : \"No\"}\n          </p>\n          {isDone || (\n            <button onClick={() => markTaskAsDoneOptimistically({ id })}>\n              Mark as done.\n            </button>\n          )}\n        </div>\n      );\n    };\n\n    export default TaskPage;\n    ```\n  </TabItem>\n</Tabs>\n\n##### Advanced usage\n\nThe `useAction` hook currently only supports specifying optimistic updates. You can expect more features in future versions of Wasp.\n\nWasp's optimistic update API is deliberately small and focuses exclusively on updating Query caches (as that's the most common use case). You might need an API that offers more options or a higher level of control. If that's the case, instead of using Wasp's `useAction` hook, you can use _react-query_'s `useMutation` hook and directly work with [their low-level API](https://tanstack.com/query/v4/docs/framework/react/guides/optimistic-updates).\n\nIf you decide to use _react-query_'s API directly, you will need access to Query cache key. Wasp internally uses this key but abstracts it from the programmer. Still, you can easily obtain it by accessing the `queryCacheKey` property on any Query:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js\n    import { getTasks } from 'wasp/client/operations'\n\n    const queryKey = getTasks.queryCacheKey\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts\n    import { getTasks } from 'wasp/client/operations'\n\n    const queryKey = getTasks.queryCacheKey\n    ```\n  </TabItem>\n</Tabs>\n\n## Automatic CRUD\n\nIf you have a lot of experience writing full-stack apps, you probably ended up doing some of the same things many times: listing data, adding data, editing it, and deleting it.\n\nWasp makes handling these boring bits easy by offering a higher-level concept called Automatic CRUD.\n\nWith a single declaration, you can tell Wasp to automatically generate server-side logic (i.e., Queries and Actions) for creating, reading, updating and deleting [Entities](../data-model/entities). As you update definitions for your Entities, Wasp automatically regenerates the backend logic.\n\n:::caution Early preview\nThis feature is currently in early preview and we are actively working on it. Read more about [our plans](#future-of-crud-operations-in-wasp) for CRUD operations.\n:::\n\n### Overview\n\nImagine we have a `Task` entity and we want to enable CRUD operations for it:\n\n```prisma title=\"schema.prisma\"\nmodel Task {\n  id          Int     @id @default(autoincrement())\n  description String\n  isDone      Boolean\n}\n```\n\nWe can then define a new `crud` called `Tasks`.\n\nWe specify to use the `Task` entity and we enable the `getAll`, `get`, `create` and `update` operations (let's say we don't need the `delete` operation).\n\n```wasp title=\"main.wasp\"\ncrud Tasks {\n  entity: Task,\n  operations: {\n    getAll: {\n      isPublic: true, // by default only logged in users can perform operations\n    },\n    get: {},\n    create: {\n      overrideFn: import { createTask } from \"@src/tasks.js\",\n    },\n    update: {},\n  },\n}\n```\n\n1. It uses default implementation for `getAll`, `get`, and `update`,\n2. ... while specifying a custom implementation for `create`.\n3. `getAll` will be public (no auth needed), while the rest of the operations will be private.\n\nHere's what it looks like when visualized:\n\n<ImgWithCaption alt=\"Automatic CRUD with Wasp\" source=\"img/crud_diagram.png\" caption=\"Visualization of the Tasks crud declaration\" />\n\nWe can now use the CRUD queries and actions we just specified in our client code.\n\nKeep reading for an example of Automatic CRUD in action, or skip ahead for the [API Reference](#api-reference).\n\n### Example: A Simple TODO App\n\nLet's create a full-app example that uses automatic CRUD. We'll stick to using the `Task` entity from the previous example, but we'll add a `User` entity and enable [username and password](../auth/username-and-pass) based auth.\n\n<ImgWithCaption alt=\"Automatic CRUD with Wasp\" source=\"img/crud-guide.gif\" caption=\"We are building a simple tasks app with username based auth\" />\n\n#### Creating the App\n\nWe can start by running `wasp new tasksCrudApp` and then adding the following to the `main.wasp` file:\n\n```wasp title=\"main.wasp\"\napp tasksCrudApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"Tasks Crud App\",\n\n  // We enabled auth and set the auth method to username and password\n  auth: {\n    userEntity: User,\n    methods: {\n      usernameAndPassword: {},\n    },\n    onAuthFailedRedirectTo: \"/login\",\n  },\n}\n\n// Tasks app routes\nroute RootRoute { path: \"/\", to: MainPage }\npage MainPage {\n  component: import { MainPage } from \"@src/MainPage.jsx\",\n  authRequired: true,\n}\n\nroute LoginRoute { path: \"/login\", to: LoginPage }\npage LoginPage {\n  component: import { LoginPage } from \"@src/LoginPage.jsx\",\n}\n\nroute SignupRoute { path: \"/signup\", to: SignupPage }\npage SignupPage {\n  component: import { SignupPage } from \"@src/SignupPage.jsx\",\n}\n```\n\nAnd let's define our entities in the `schema.prisma` file:\n\n```prisma title=\"schema.prisma\"\nmodel User {\n  id    Int    @id @default(autoincrement())\n  tasks Task[]\n}\n\n// We defined a Task entity on which we'll enable CRUD later on\nmodel Task {\n  id          Int     @id @default(autoincrement())\n  description String\n  isDone      Boolean\n  userId      Int\n  user        User    @relation(fields: [userId], references: [id])\n}\n```\n\nWe can then run `wasp db migrate-dev` to create the database and run the migrations.\n\n#### Adding CRUD to the `Task` Entity ✨\n\nLet's add the following `crud` declaration to our `main.wasp` file:\n\n```wasp title=\"main.wasp\"\n// ...\n\ncrud Tasks {\n  entity: Task,\n  operations: {\n    getAll: {},\n    create: {\n      overrideFn: import { createTask } from \"@src/tasks.js\",\n    },\n  },\n}\n```\n\nYou'll notice that we enabled only `getAll` and `create` operations. This means that only these operations will be available.\n\nWe also overrode the `create` operation with a custom implementation. This means that the `create` operation will not be generated, but instead, the `createTask` function from `@src/tasks.{js,ts}` will be used.\n\n#### Our Custom `create` Operation\n\nWe need a custom `create` operation because we want to make sure that the task is connected to the user creating it.\nAutomatic CRUD doesn't yet support this by default.\nRead more about the default implementations [here](#declaring-a-crud-with-default-options).\n\nHere's the `src/tasks.{js,ts}` file:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/tasks.js\"\n    import { HttpError } from 'wasp/server'\n\n    export const createTask = async (args, context) => {\n      if (!context.user) {\n        throw new HttpError(401, 'User not authenticated.')\n      }\n\n      const { description, isDone } = args\n      const { Task } = context.entities\n\n      return await Task.create({\n        data: {\n          description,\n          isDone,\n          // highlight-start\n          // Connect the task to the user that is creating it\n          user: {\n            connect: {\n              id: context.user.id,\n            },\n          },\n          // highlight-end\n        },\n      })\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/tasks.ts\"\n    import { type Tasks } from 'wasp/server/crud'\n    import { type Task } from 'wasp/entities'\n    import { HttpError } from 'wasp/server'\n\n    type CreateTaskInput = { description: string; isDone: boolean }\n\n    export const createTask: Tasks.CreateAction<CreateTaskInput, Task> = async (\n      args,\n      context\n    ) => {\n      if (!context.user) {\n        throw new HttpError(401, 'User not authenticated.')\n      }\n\n      const { description, isDone } = args\n      const { Task } = context.entities\n\n      return await Task.create({\n        data: {\n          description,\n          isDone,\n          // highlight-start\n          // Connect the task to the user that is creating it\n          user: {\n            connect: {\n              id: context.user.id,\n            },\n          },\n          // highlight-end\n        },\n      })\n    }\n    ```\n\n    Wasp automatically generates the `Tasks.CreateAction` type based on the CRUD declaration in your Wasp file.\n    Use it to type the CRUD action's implementation.\n\n    The `Tasks.CreateAction` type works exactly like the types Wasp generates for [Queries](../data-model/operations/queries#type-support-for-queries) and [Actions](../data-model/operations/actions#type-support-for-actions).\n    In other words, annotating the action with `Tasks.CreateAction` tells TypeScript about the type of the Action's `context` object, while the two type arguments allow you to specify the Action's inputs and outputs.\n\n    Read more about type support for CRUD overrides in the [API reference](#defining-the-overrides).\n  </TabItem>\n</Tabs>\n\n#### Using the Generated CRUD Operations on the Client\n\nAnd let's use the generated operations in our client code:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/MainPage.jsx\"\n    // highlight-next-line\n    import { Tasks } from 'wasp/client/crud'\n    import { useState } from 'react'\n\n    export const MainPage = () => {\n      // highlight-next-line\n      const { data: tasks, isLoading, error } = Tasks.getAll.useQuery()\n      // highlight-next-line\n      const createTask = Tasks.create.useAction()\n      const [taskDescription, setTaskDescription] = useState('')\n\n      function handleCreateTask() {\n        createTask({ description: taskDescription, isDone: false })\n        setTaskDescription('')\n      }\n\n      if (isLoading) return <div>Loading...</div>\n      if (error) return <div>Error: {error.message}</div>\n      return (\n        <div\n          style={{\n            fontSize: '1.5rem',\n            display: 'grid',\n            placeContent: 'center',\n            height: '100vh',\n          }}\n        >\n          <div>\n            <input\n              value={taskDescription}\n              onChange={(e) => setTaskDescription(e.target.value)}\n            />\n            <button onClick={handleCreateTask}>Create task</button>\n          </div>\n          <ul>\n            {tasks.map((task) => (\n              <li key={task.id}>{task.description}</li>\n            ))}\n          </ul>\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/MainPage.tsx\"\n    // highlight-next-line\n    import { Tasks } from 'wasp/client/crud'\n    import { useState } from 'react'\n\n    export const MainPage = () => {\n      // highlight-next-line\n      // Thanks to full-stack type safety, all payload types are inferred\n      // highlight-next-line\n      // automatically\n      // highlight-next-line\n      const { data: tasks, isLoading, error } = Tasks.getAll.useQuery()\n      // highlight-next-line\n      const createTask = Tasks.create.useAction()\n      const [taskDescription, setTaskDescription] = useState('')\n\n      function handleCreateTask() {\n        createTask({ description: taskDescription, isDone: false })\n        setTaskDescription('')\n      }\n\n      if (isLoading) return <div>Loading...</div>\n      if (error) return <div>Error: {error.message}</div>\n      return (\n        <div\n          style={{\n            fontSize: '1.5rem',\n            display: 'grid',\n            placeContent: 'center',\n            height: '100vh',\n          }}\n        >\n          <div>\n            <input\n              value={taskDescription}\n              onChange={(e) => setTaskDescription(e.target.value)}\n            />\n            <button onClick={handleCreateTask}>Create task</button>\n          </div>\n          <ul>\n            {tasks.map((task) => (\n              <li key={task.id}>{task.description}</li>\n            ))}\n          </ul>\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nAnd here are the login and signup pages, where we are using Wasp's [Auth UI](../auth/ui) components:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/LoginPage.jsx\"\n    import { LoginForm } from 'wasp/client/auth'\n    import { Link } from 'react-router-dom'\n\n    export function LoginPage() {\n      return (\n        <div\n          style={{\n            display: 'grid',\n            placeContent: 'center',\n          }}\n        >\n          <LoginForm />\n          <div>\n            <Link to=\"/signup\">Create an account</Link>\n          </div>\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/LoginPage.tsx\"\n    import { LoginForm } from 'wasp/client/auth'\n    import { Link } from 'react-router-dom'\n\n    export function LoginPage() {\n      return (\n        <div\n          style={{\n            display: 'grid',\n            placeContent: 'center',\n          }}\n        >\n          <LoginForm />\n          <div>\n            <Link to=\"/signup\">Create an account</Link>\n          </div>\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/SignupPage.jsx\"\n    import { SignupForm } from 'wasp/client/auth'\n\n    export function SignupPage() {\n      return (\n        <div\n          style={{\n            display: 'grid',\n            placeContent: 'center',\n          }}\n        >\n          <SignupForm />\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/SignupPage.tsx\"\n    import { SignupForm } from 'wasp/client/auth'\n\n    export function SignupPage() {\n      return (\n        <div\n          style={{\n            display: 'grid',\n            placeContent: 'center',\n          }}\n        >\n          <SignupForm />\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThat's it. You can now run `wasp start` and see the app in action. ⚡️\n\nYou should see a login page and a signup page. After you log in, you should see a page with a list of tasks and a form to create new tasks.\n\n### Future of CRUD Operations in Wasp\n\nCRUD operations currently have a limited set of knowledge about the business logic they are implementing.\n\n- For example, they don't know that a task should be connected to the user that is creating it. This is why we had to override the `create` operation in the example above.\n- Another thing: they are not aware of the authorization rules. For example, they don't know that a user should not be able to create a task for another user. In the future, we will be adding role-based authorization to Wasp, and we plan to make CRUD operations aware of the authorization rules.\n- Another issue is input validation and sanitization. For example, we might want to make sure that the task description is not empty.\n\nCRUD operations are a mechanism for getting a backend up and running quickly, but it depends on the information it can get from the Wasp app. The more information that it can pick up from your app, the more powerful it will be out of the box.\n\nWe plan on supporting CRUD operations and growing them to become the easiest way to create your backend. Follow along on [this GitHub issue](https://github.com/wasp-lang/wasp/issues/1253) to see how we are doing.\n\n### API Reference\n\nCRUD declaration works on top of an existing entity declaration. We'll fully explore the API using two examples:\n\n1. A basic CRUD declaration that relies on default options.\n2. A more involved CRUD declaration that uses extra options and overrides.\n\n#### Declaring a CRUD With Default Options\n\nIf we create CRUD operations for an entity named `Task`, like this:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    crud Tasks { // crud name here is \"Tasks\"\n      entity: Task,\n      operations: {\n        get: {},\n        getAll: {},\n        create: {},\n        update: {},\n        delete: {},\n      },\n    }\n    ```\n\n    Wasp will give you the following default implementations:\n\n    **get** - returns one entity based on the `id` field\n\n    ```js\n    // ...\n    // Wasp uses the field marked with `@id` in Prisma schema as the id field.\n    return Task.findUnique({ where: { id: args.id } })\n    ```\n\n    **getAll** - returns all entities\n\n    ```js\n    // ...\n\n    // If the operation is not public, Wasp checks if an authenticated user\n    // is making the request.\n\n    return Task.findMany()\n    ```\n\n    **create** - creates a new entity\n\n    ```js\n    // ...\n    return Task.create({ data: args.data })\n    ```\n\n    **update** - updates an existing entity\n\n    ```js\n    // ...\n    // Wasp uses the field marked with `@id` in Prisma schema as the id field.\n    return Task.update({ where: { id: args.id }, data: args.data })\n    ```\n\n    **delete** - deletes an existing entity\n\n    ```js\n    // ...\n    // Wasp uses the field marked with `@id` in Prisma schema as the id field.\n    return Task.delete({ where: { id: args.id } })\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    crud Tasks { // crud name here is \"Tasks\"\n      entity: Task,\n      operations: {\n        get: {},\n        getAll: {},\n        create: {},\n        update: {},\n        delete: {},\n      },\n    }\n    ```\n\n    Wasp will give you the following default implementations:\n\n    **get** - returns one entity based on the `id` field\n\n    ```ts\n    // ...\n    // Wasp uses the field marked with `@id` in Prisma schema as the id field.\n    return Task.findUnique({ where: { id: args.id } })\n    ```\n\n    **getAll** - returns all entities\n\n    ```ts\n    // ...\n\n    // If the operation is not public, Wasp checks if an authenticated user\n    // is making the request.\n\n    return Task.findMany()\n    ```\n\n    **create** - creates a new entity\n\n    ```ts\n    // ...\n    return Task.create({ data: args.data })\n    ```\n\n    **update** - updates an existing entity\n\n    ```ts\n    // ...\n    // Wasp uses the field marked with `@id` in Prisma schema as the id field.\n    return Task.update({ where: { id: args.id }, data: args.data })\n    ```\n\n    **delete** - deletes an existing entity\n\n    ```ts\n    // ...\n    // Wasp uses the field marked with `@id` in Prisma schema as the id field.\n    return Task.delete({ where: { id: args.id } })\n    ```\n  </TabItem>\n</Tabs>\n\n:::info Current Limitations\nIn the default `create` and `update` implementations, we are saving all of the data that the client sends to the server. This is not always desirable, i.e. in the case when the client should not be able to modify all of the data in the entity.\n\n[In the future](#future-of-crud-operations-in-wasp), we are planning to add validation of action input, where only the data that the user is allowed to change will be saved.\n\nFor now, the solution is to provide an override function. You can override the default implementation by using the `overrideFn` option and implementing the validation logic yourself.\n\n:::\n\n#### Declaring a CRUD With All Available Options\n\nHere's an example of a more complex CRUD declaration:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    crud Tasks { // crud name here is \"Tasks\"\n      entity: Task,\n      operations: {\n        getAll: {\n          isPublic: true, // optional, defaults to false\n        },\n        get: {},\n        create: {\n          overrideFn: import { createTask } from \"@src/tasks.js\", // optional\n        },\n        update: {},\n      },\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    crud Tasks { // crud name here is \"Tasks\"\n      entity: Task,\n      operations: {\n        getAll: {\n          isPublic: true, // optional, defaults to false\n        },\n        get: {},\n        create: {\n          overrideFn: import { createTask } from \"@src/tasks.js\", // optional\n        },\n        update: {},\n      },\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThe CRUD declaration features the following fields:\n\n- `entity: Entity` Required!\n\n  The entity to which the CRUD operations will be applied.\n\n- `operations: { [operationName]: CrudOperationOptions }` Required!\n\n  The operations to be generated. The key is the name of the operation, and the value is the operation configuration.\n\n  - The possible values for `operationName` are:\n    - `getAll`\n    - `get`\n    - `create`\n    - `update`\n    - `delete`\n  - `CrudOperationOptions` can have the following fields:\n    - `isPublic: bool` - Whether the operation is public or not. If it is public, no auth is required to access it. If it is not public, it will be available only to authenticated users. Defaults to `false`.\n    - `overrideFn: ExtImport` - The import statement of the optional override implementation in Node.js.\n\n##### Defining the overrides\n\nLike with actions and queries, you can define the implementation in a Javascript/Typescript file. The overrides are functions that take the following arguments:\n\n- `args`\n\n  The arguments of the operation i.e. the data sent from the client.\n\n- `context`\n\n  Context contains the `user` making the request and the `entities` object with the entity that's being operated on.\n\n<ShowForTs>\n  You can also import types for each of the functions you want to override by importing the `{crud name}` from `wasp/server/crud`. The available types are:\n\n  - `{crud name}.GetAllQuery`\n  - `{crud name}.GetQuery`\n  - `{crud name}.CreateAction`\n  - `{crud name}.UpdateAction`\n  - `{crud name}.DeleteAction`\n\n  If you have a CRUD named `Tasks`, you would import the types like this:\n\n  ```ts\n  import { type Tasks } from 'wasp/server/crud'\n\n  // Each of the types is a generic type, so you can use it like this:\n  export const getAllOverride: Tasks.GetAllQuery<Input, Output> = async (\n    args,\n    context\n  ) => {\n    // ...\n  }\n  ```\n</ShowForTs>\n\nFor a usage example, check the [example guide](../data-model/crud#adding-crud-to-the-task-entity-).\n\n##### Using the CRUD operations in client code\n\nOn the client, you import the CRUD operations from `wasp/client/crud` by import the `{crud name}` object. For example, if you have a CRUD called `Tasks`, you would import the operations like this:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"SomePage.jsx\"\n    import { Tasks } from 'wasp/client/crud'\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"SomePage.tsx\"\n    import { Tasks } from 'wasp/client/crud'\n    ```\n  </TabItem>\n</Tabs>\n\nYou can then access the operations like this:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"SomePage.jsx\"\n    const { data } = Tasks.getAll.useQuery()\n    const { data } = Tasks.get.useQuery({ id: 1 })\n    const createAction = Tasks.create.useAction()\n    const updateAction = Tasks.update.useAction()\n    const deleteAction = Tasks.delete.useAction()\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"SomePage.tsx\"\n    const { data } = Tasks.getAll.useQuery()\n    const { data } = Tasks.get.useQuery({ id: 1 })\n    const createAction = Tasks.create.useAction()\n    const updateAction = Tasks.update.useAction()\n    const deleteAction = Tasks.delete.useAction()\n    ```\n  </TabItem>\n</Tabs>\n\nAll CRUD operations are implemented with [Queries and Actions](../data-model/operations/overview) under the hood, which means they come with all the features you'd expect (e.g., automatic SuperJSON serialization, full-stack type safety when using TypeScript)\n\n---\n\nJoin our **community** on [Discord](https://discord.com/invite/rzdnErX), where we chat about full-stack web stuff. Join us to see what we are up to, share your opinions or get help with CRUD operations.\n\n## Databases\n\n[Entities](../data-model/entities.md), [Operations](../data-model/operations/overview) and [Automatic CRUD](../data-model/crud.md) together make a high-level interface for working with your app's data. Still, all that data has to live somewhere, so let's see how Wasp deals with databases.\n\n### Supported Database Backends\n\nWasp supports multiple database backends. We'll list and explain each one.\n\n#### SQLite\n\nThe default database Wasp uses is [SQLite](https://www.sqlite.org/index.html).\n\nWhen you create a new Wasp project, the `schema.prisma` file will have SQLite as the default database provider:\n\n```prisma title=\"schema.prisma\"\ndatasource db {\n  provider = \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\n// ...\n```\n\n<small>\n  Read more about how Wasp uses the Prisma schema file in the [Prisma schema file](./prisma-file.md) section.\n</small>\n\nWhen you use the SQLite database, Wasp sets the `DATABASE_URL` environment variable for you.\n\nSQLite is a great way to get started with a new project because it doesn't require any configuration, but Wasp can only use it in development. Once you want to deploy your Wasp app to production, you'll need to switch to PostgreSQL and stick with it.\n\nFortunately, migrating from SQLite to PostgreSQL is pretty simple, and we have [a guide](#migrating-from-sqlite-to-postgresql) to help you.\n\n#### PostgreSQL\n\n[PostgreSQL](https://www.postgresql.org/) is the most advanced open-source database and one of the most popular databases overall.\nIt's been in active development for 20+ years.\nTherefore, if you're looking for a battle-tested database, look no further.\n\nTo use PostgreSQL with Wasp, set the provider to `\"postgresql\"` in the `schema.prisma` file:\n\n```prisma title=\"schema.prisma\"\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\n// ...\n```\n\n<small>\n  Read more about how Wasp uses the Prisma schema file in the [Prisma schema file](./prisma-file.md) section.\n</small>\n\nYou'll have to ensure a database instance is running during development to use PostgreSQL. Wasp needs access to your database for commands such as `wasp start` or `wasp db migrate-dev`.\n\nWe cover all supported ways of connecting to a database in [the next section](#connecting-to-a-database).\n\n### Connecting to a Database\n\n#### SQLite\n\nIf you are using SQLite, you don't need to do anything special to connect to the database. Wasp will take care of it for you.\n\n#### PostgreSQL\n\nIf you are using PostgreSQL, Wasp supports two ways of connecting to a database:\n\n1. For managed experience, let Wasp spin up a ready-to-go development database for you.\n2. For more control, you can specify a database URL and connect to an existing database that you provisioned yourself.\n\n##### Using the Dev Database provided by Wasp\n\nThe command `wasp start db` will start a default PostgreSQL dev database for you.\n\nYour Wasp app will automatically connect to it, just keep `wasp start db` running in the background.\nAlso, make sure that:\n\n- You have [Docker installed](https://www.docker.com/get-started/) and it's available in your `PATH`.\n- The port `5432` isn't taken.\n\n:::tip\nIn case you might want to connect to the dev database through the external tool like `psql` or [pgAdmin](https://www.pgadmin.org/), the credentials are printed in the console when you run `wasp db start`, at the very beginning.\n:::\n\n##### Connecting to an existing database\n\nIf you want to spin up your own dev database (or connect to an external one), you can tell Wasp about it using the `DATABASE_URL` environment variable. Wasp will use the value of `DATABASE_URL` as a connection string.\n\nThe easiest way to set the necessary `DATABASE_URL` environment variable is by adding it to the [.env.server](../project/env-vars) file in the root dir of your Wasp project (if that file doesn't yet exist, create it):\n\n```env title=\".env.server\"\nDATABASE_URL=postgresql://user:password@localhost:5432/mydb\n```\n\nAlternatively, you can set it inline when running `wasp` (this applies to all environment variables):\n\n```bash\nDATABASE_URL=<my-db-url> wasp ...\n```\n\nThis trick is useful for running a certain `wasp` command on a specific database.\nFor example, you could do:\n\n```bash\nDATABASE_URL=<production-db-url> wasp db seed myProductionSeed\n```\n\nThis command seeds the data for a fresh staging or production database. Read more about [seeding the database](#seeding-the-database).\n\n### Migrating from SQLite to PostgreSQL\n\nTo run your Wasp app in production, you'll need to switch from SQLite to PostgreSQL.\n\n1. Set the provider to `\"postgresql\"` in the `schema.prisma` file:\n\n   ```prisma title=\"schema.prisma\"\n   datasource db {\n     // highlight-next-line\n     provider = \"postgresql\"\n     url      = env(\"DATABASE_URL\")\n   }\n\n   // ...\n   ```\n\n2. Delete all the old migrations, since they are SQLite migrations and can't be used with PostgreSQL, as well as the SQLite database by running [`wasp clean`](../general/cli#project-commands):\n\n   ```bash\n   rm -r migrations/\n   wasp clean\n   ```\n\n3. Ensure your new database is running (check the [section on connecting to a database](#connecting-to-a-database) to see how). Leave it running, since we need it for the next step.\n\n4. In a different terminal, run `wasp db migrate-dev` to apply the changes and create a new initial migration.\n\n5. That is it, you are all done!\n\n### Seeding the Database\n\n**Database seeding** is a term used for populating the database with some initial data.\n\nSeeding is most commonly used for:\n\n1. Getting the development database into a state convenient for working and testing.\n2. Initializing any database (`dev`, `staging`, or `prod`) with essential data it requires to operate.\n   For example, populating the Currency table with default currencies, or the Country table with all available countries.\n\n#### Writing a Seed Function\n\nYou can define as many **seed functions** as you want in an array under the `app.db.seeds` field:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      // ...\n      db: {\n        seeds: [\n          import { devSeedSimple } from \"@src/dbSeeds.js\",\n          import { prodSeed } from \"@src/dbSeeds.js\"\n        ]\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      // ...\n      db: {\n        seeds: [\n          import { devSeedSimple } from \"@src/dbSeeds.js\",\n          import { prodSeed } from \"@src/dbSeeds.js\"\n        ]\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nEach seed function must be an async function that takes one argument, `prisma`, which is a [Prisma Client](https://www.prisma.io/docs/concepts/components/prisma-client/crud) instance used to interact with the database.\nThis is the same Prisma Client instance that Wasp uses internally.\n\nSince a seed function falls under server-side code, it can import other server-side functions. This is convenient because you might want to seed the database using Actions.\n\nHere's an example of a seed function that imports an Action:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js\n    import { createTask } from './actions.js'\n    import { sanitizeAndSerializeProviderData } from 'wasp/server/auth'\n\n    export const devSeedSimple = async (prisma) => {\n      const user = await createUser(prisma, {\n        username: 'RiuTheDog',\n        password: 'bark1234',\n      })\n\n      await createTask(\n        { description: 'Chase the cat' },\n        { user, entities: { Task: prisma.task } }\n      )\n    }\n\n    async function createUser(prisma, data) {\n      const newUser = await prisma.user.create({\n        data: {\n          auth: {\n            create: {\n              identities: {\n                create: {\n                  providerName: 'username',\n                  providerUserId: data.username,\n                  providerData: await sanitizeAndSerializeProviderData({\n                    hashedPassword: data.password\n                  }),\n                },\n              },\n            },\n          },\n        },\n      })\n\n      return newUser\n    }\n    ```\n\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts\n    import { createTask } from './actions.js'\n    import type { DbSeedFn } from 'wasp/server'\n    import { sanitizeAndSerializeProviderData } from 'wasp/server/auth'\n    import type { AuthUser } from 'wasp/auth'\n    import type { PrismaClient } from 'wasp/server'\n\n    export const devSeedSimple: DbSeedFn = async (prisma) => {\n      const user = await createUser(prisma, {\n        username: 'RiuTheDog',\n        password: 'bark1234',\n      })\n\n      await createTask(\n        { description: 'Chase the cat', isDone: false },\n        { user, entities: { Task: prisma.task } }\n      )\n    };\n\n    async function createUser(\n      prisma: PrismaClient,\n      data: { username: string, password: string }\n    ): Promise<AuthUser> {\n      const newUser = await prisma.user.create({\n        data: {\n          auth: {\n            create: {\n              identities: {\n                create: {\n                  providerName: 'username',\n                  providerUserId: data.username,\n                  providerData: await sanitizeAndSerializeProviderData<'username'>({\n                    hashedPassword: data.password\n                  }),\n                },\n              },\n            },\n          },\n        },\n      })\n\n      return newUser\n    }\n    ```\n\n    Wasp exports a type called `DbSeedFn` which you can use to easily type your seeding function.\n    Wasp defines `DbSeedFn` like this:\n\n    ```typescript\n    type DbSeedFn = (prisma: PrismaClient) => Promise<void>\n    ```\n\n    Annotating the function `devSeedSimple` with this type tells TypeScript:\n\n    - The seeding function's argument (`prisma`) is of type `PrismaClient`.\n    - The seeding function's return value is `Promise<void>`.\n\n  </TabItem>\n</Tabs>\n\n#### Running seed functions\n\nRun the command `wasp db seed` and Wasp will ask you which seed function you'd like to run (if you've defined more than one).\n\nAlternatively, run the command `wasp db seed <seed-name>` to choose a specific seed function right away, for example:\n\n```\nwasp db seed devSeedSimple\n```\n\nCheck the [API Reference](#cli-commands-for-seeding-the-database) for more details on these commands.\n\n:::tip\nYou'll often want to call `wasp db seed` right after you run `wasp db reset`, as it makes sense to fill the database with initial data after clearing it.\n:::\n\n### Customising the Prisma Client\n\nWasp interacts with the database using the [Prisma Client](https://www.prisma.io/docs/orm/prisma-client).\nTo customize the client, define a function in the `app.db.prismaSetupFn` field that returns a Prisma Client instance.\nThis allows you to configure features like [logging](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging) or [client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions):\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=main.wasp\n    app MyApp {\n      title: \"My app\",\n      // ...\n      db: {\n        prismaSetupFn: import { setUpPrisma } from \"@src/prisma\"\n      }\n    }\n    ```\n\n    ```js title=\"src/prisma.js\"\n    import { PrismaClient } from '@prisma/client'\n\n    export const setUpPrisma = () => {\n      const prisma = new PrismaClient({\n        log: ['query'],\n      }).$extends({\n        query: {\n          task: {\n            async findMany({ args, query }) {\n              args.where = {\n                ...args.where,\n                description: { not: { contains: 'hidden by setUpPrisma' } },\n              }\n              return query(args)\n            },\n          },\n        },\n      })\n\n      return prisma\n    }\n    ```\n\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=main.wasp\n    app MyApp {\n      title: \"My app\",\n      // ...\n      db: {\n        prismaSetupFn: import { setUpPrisma } from \"@src/prisma\"\n      }\n    }\n    ```\n\n    ```ts title=\"src/prisma.ts\"\n    import { PrismaClient } from '@prisma/client'\n\n    export const setUpPrisma = () => {\n      const prisma = new PrismaClient({\n        log: ['query'],\n      }).$extends({\n        query: {\n          task: {\n            async findMany({ args, query }) {\n              args.where = {\n                ...args.where,\n                description: { not: { contains: 'hidden by setUpPrisma' } },\n              }\n              return query(args)\n            },\n          },\n        },\n      })\n\n      return prisma\n    }\n    ```\n\n  </TabItem>\n</Tabs>\n\n### API Reference\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      db: {\n        seeds: [\n          import devSeed from \"@src/dbSeeds\"\n        ],\n        prismaSetupFn: import { setUpPrisma } from \"@src/prisma\"\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      db: {\n        seeds: [\n          import devS",
        "namespace": "xtasker",
        "timestamp": 1754702864141
      },
      {
        "key": "waspfull_ad",
        "value": "eed from \"@src/dbSeeds\"\n        ],\n        prismaSetupFn: import { setUpPrisma } from \"@src/prisma\"\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n`app.db` is a dictionary with the following fields (all fields are optional):\n\n- `seeds: [ExtImport]`\n\n  Defines the seed functions you can use with the `wasp db seed` command to seed your database with initial data.\n  Read the [Seeding section](#seeding-the-database) for more details.\n\n- `prismaSetupFn: ExtImport`\n\n  Defines a function that sets up the Prisma Client instance. Wasp expects it to return a Prisma Client instance.\n  You can use this function to set up [logging](https://www.prisma.io/docs/orm/prisma-client/observability-and-logging/logging) or [client extensions](https://www.prisma.io/docs/orm/prisma-client/client-extensions):\n\n  ```ts title=\"src/prisma.ts\"\n  import { PrismaClient } from '@prisma/client'\n\n  export const setUpPrisma = () => {\n    const prisma = new PrismaClient({\n      log: ['query', 'info', 'warn', 'error'],\n    })\n\n    return prisma\n  }\n  ```\n\n#### CLI Commands for Seeding the Database\n\nUse one of the following commands to run the seed functions:\n\n- `wasp db seed`\n\n  If you've only defined a single seed function, this command runs it. If you've defined multiple seed functions, it asks you to choose one interactively.\n\n- `wasp db seed <seed-name>`\n\n  This command runs the seed function with the specified name. The name is the identifier used in its `import` expression in the `app.db.seeds` list.\n  For example, to run the seed function `devSeedSimple` which was defined like this:\n\n  <Tabs groupId=\"js-ts\">\n    <TabItem value=\"js\" label=\"JavaScript\">\n      ```wasp title=\"main.wasp\"\n      app MyApp {\n        // ...\n        db: {\n          seeds: [\n            // ...\n            import { devSeedSimple } from \"@src/dbSeeds.js\",\n          ]\n        }\n      }\n      ```\n    </TabItem>\n\n    <TabItem value=\"ts\" label=\"TypeScript\">\n      ```wasp title=\"main.wasp\"\n      app MyApp {\n        // ...\n        db: {\n          seeds: [\n            // ...\n            import { devSeedSimple } from \"@src/dbSeeds.js\",\n          ]\n        }\n      }\n      ```\n    </TabItem>\n  </Tabs>\n\n  Use the following command:\n\n  ```\n  wasp db seed devSeedSimple\n  ```\n\n## Prisma Schema File\n\nWasp uses [Prisma](https://www.prisma.io/) to interact with the database. Prisma is a \"Next-generation Node.js and TypeScript ORM\" that provides a type-safe API for working with your database.\n\nWith Prisma, you define your application's data model in a `schema.prisma` file. Read more about how Wasp Entities relate to Prisma models on the [Entities](./entities.md) page.\n\nIn Wasp, the `schema.prisma` file is located in your project's root directory:\n\n```c\n.\n├── main.wasp\n...\n// highlight-next-line\n├── schema.prisma\n├── src\n├── tsconfig.json\n└── vite.config.ts\n```\n\nWasp uses the `schema.prisma` file to understand your app's data model and generate the necessary code to interact with the database.\n\n### Wasp file and Prisma schema file\n\nLet's see how Wasp and Prisma files work together to define your application.\n\nHere's an example `schema.prisma` file where we defined some database options and two models (User and Task) with a one-to-many relationship:\n\n```prisma title=\"schema.prisma\"\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id      Int        @id @default(autoincrement())\n  tasks   Task[]\n}\n\nmodel Task {\n  id          Int        @id @default(autoincrement())\n  description String\n  isDone      Boolean    @default(false)\n  user        User       @relation(fields: [userId], references: [id])\n  userId      Int\n}\n```\n\nWasp reads this `schema.prisma` file and extracts the info about your database models and database config.\n\nThe `datasource` block defines which database you want to use (PostgreSQL in this case) and some other options.\n\nThe `generator` block defines how to generate the Prisma Client code that you can use in your application to interact with the database.\n\n<ImgWithCaption alt=\"Relationship between Wasp file and Prisma file\" source=\"img/data-model/prisma_in_wasp.png\" caption=\"Relationship between Wasp file and Prisma file\" />\n\nFinally, Prisma models become Wasp Entities which can be then used in the `main.wasp` file:\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n}\n\n...\n\n// Using Wasp Entities in the Wasp file\n\nquery getTasks {\n  fn: import { getTasks } from \"@src/queries\",\n  // highlight-next-line\n  entities: [Task]\n}\n\njob myJob {\n  executor: PgBoss,\n  perform: {\n    fn: import { foo } from \"@src/workers/bar\"\n  },\n  // highlight-next-line\n  entities: [Task],\n}\n\napi fooBar {\n  fn: import { fooBar } from \"@src/apis\",\n  // highlight-next-line\n  entities: [Task],\n  httpRoute: (GET, \"/foo/bar/:email\")\n}\n\n```\n\nIn the implementation of the `getTasks` query, `Task` is a Wasp Entity that corresponds to the `Task` model defined in the `schema.prisma` file.\n\nThe same goes for the `myJob` job and `fooBar` API, where `Task` is used as an Entity.\n\nTo learn more about the relationship between Wasp Entities and Prisma models, check out the [Entities](./entities.md) page.\n\n### Wasp-specific Prisma configuration\n\nWasp mostly lets you use the Prisma schema file as you would in any other JS/TS project. However, there are some Wasp-specific rules you need to follow.\n\n#### The `datasource` block\n\n```prisma title=\"schema.prisma\"\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n```\n\nWasp takes the `datasource` you write and use it as-is.\n\nThere are some rules you need to follow:\n\n- You can only use `\"postgresql\"` or `\"sqlite\"` as the `provider` because Wasp only supports PostgreSQL and SQLite databases for now.\n- You must set the `url` field to `env(\"DATABASE_URL\")` so that Wasp can work properly with your database.\n\n#### The `generator` blocks\n\n```prisma title=\"schema.prisma\"\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n```\n\nWasp requires that there is a `generator` block with `provider = \"prisma-client-js\"` in the `schema.prisma` file.\n\nYou can add additional generators if you need them in your project.\n\n#### The `model` blocks\n\n```prisma title=\"schema.prisma\"\nmodel User {\n  id      Int        @id @default(autoincrement())\n  tasks   Task[]\n}\n\nmodel Task {\n  id          Int        @id @default(autoincrement())\n  description String\n  isDone      Boolean    @default(false)\n  user        User       @relation(fields: [userId], references: [id])\n  userId      Int\n}\n```\n\nYou can define your models in any way you like, if it's valid Prisma schema code, it will work with Wasp.\n\n#### The `enum` blocks\n\nAs our applications grow in complexity, we might want to use [Prisma `enum`s](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-enums) to closely define our app's domain. For example, if we had a `Task` model with a boolean `isDone`, and we wanted to start to track whether it is in progress, we could migrate the field to a more expressive type:\n\n```prisma title=\"schema.prisma\"\nenum TaskStatus {\n  NotStarted\n  Doing\n  Done\n}\n\nmodel Task {\n  ...\n  state TaskStatus @default(NotStarted)\n}\n```\n\nMake sure to check [Prisma's enum compatibility with your database](https://www.prisma.io/docs/orm/reference/database-features#misc).\nIf it works with Prisma, it will work with Wasp.\n\n##### How to use `enum`s in your code\n\nIf you need to access your `enum` cases and their values from your server, you can import them directly from `@prisma/client`:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/queries.js\"\n    import { TaskState } from \"@prisma/client\";\n    import { Task } from \"wasp/entities\";\n\n    export const getOpenTasks  = async (args, context) => {\n      return context.entities.Task.findMany({\n        orderBy: { id: \"asc\" },\n        where: { NOT: { state: TaskState.Done } },\n      });\n    };\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/queries.ts\"\n    import { TaskState } from \"@prisma/client\";\n    import { Task } from \"wasp/entities\";\n    import { type GetTasks } from \"wasp/server/operations\";\n\n    export const getOpenTasks: GetTasks<void, Task[]> = async (args, context) => {\n      return context.entities.Task.findMany({\n        orderBy: { id: \"asc\" },\n        where: { NOT: { state: TaskState.Done } },\n      });\n    };\n    ```\n  </TabItem>\n</Tabs>\n\nYou can also access them from your client code:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/views/TaskList.jsx\"\n    import { TaskState } from \"@prisma/client\";\n\n    const TaskRow = ({ task }) => {\n      return (\n        <div>\n          <input\n            type=\"checkbox\"\n            id={String(task.id)}\n            checked={task.state === TaskState.Done}\n          />\n          {task.description}\n        </div>\n      );\n    };\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/views/TaskList.tsx\"\n    import { TaskState } from \"@prisma/client\";\n    import { Task } from \"wasp/entities\";\n\n    const TaskRow = ({ task }: { task: Task }) => {\n      return (\n        <div>\n          <input\n            type=\"checkbox\"\n            id={String(task.id)}\n            checked={task.state === TaskState.Done}\n          />\n          {task.description}\n        </div>\n      );\n    };\n    ```\n  </TabItem>\n</Tabs>\n\n:::note Triple slash comments\nWasp doesn't yet fully support `/// comment` syntax in the `schema.prisma` file. We are tracking it [here](https://github.com/wasp-lang/wasp/issues/2132), let us know if this is something you need.\n\n:::\n\n### Prisma preview features\n\nPrisma is still in active development and some of its features are not yet stable. To enable various preview features in Prisma, you need to add the `previewFeatures` field to the `generator` block in the `schema.prisma` file.\n\nFor example, one useful Prisma preview feature is PostgreSQL extensions support, which allows you to use PostgreSQL extensions like `pg_vector` or `pg_trgm` in your database schema:\n\n```prisma title=\"schema.prisma\"\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pgvector(map: \"vector\")]\n}\n\ngenerator client {\n  provider        = \"prisma-client-js\"\n  previewFeatures = [\"postgresqlExtensions\"]\n}\n\n// ...\n```\n\nRead more about preview features in the Prisma docs [here](https://www.prisma.io/docs/orm/reference/preview-features/client-preview-features) or about using PostgreSQL extensions [here](https://www.prisma.io/docs/orm/prisma-schema/postgresql-extensions).\n\n------\n\n# Authentication\n\n## Authentication Overview\n\nAuth is an essential piece of any serious application. That's why Wasp provides authentication and authorization support out of the box.\n\nHere's a 1-minute tour of how full-stack auth works in Wasp:\n\n<div className=\"video-container\">\n  <iframe src=\"https://www.youtube.com/embed/Qiro77q-ulI?si=y8Rejsbjb1HJC6FA\" frameborder=\"1\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen />\n</div>\n\nEnabling auth for your app is optional and can be done by configuring the `auth` field of your `app` declaration:\n\n```wasp title=\"main.wasp\"\napp MyApp {\n  title: \"My app\",\n  //...\n  auth: {\n    userEntity: User,\n    methods: {\n      usernameAndPassword: {}, // use this or email, not both\n      email: {}, // use this or usernameAndPassword, not both\n      google: {},\n      gitHub: {},\n    },\n    onAuthFailedRedirectTo: \"/someRoute\"\n  }\n}\n\n//...\n```\n\n<small>\n  Read more about the `auth` field options in the [API Reference](#api-reference) section.\n</small>\n\nWe will provide a quick overview of auth in Wasp and link to more detailed documentation for each auth method.\n\n### Available auth methods\n\nWasp supports the following auth methods:\n\n<AuthMethodsGrid />\n\nLet's say we enabled the [Username & password](../auth/username-and-pass) authentication.\n\nWe get an auth backend with signup and login endpoints. We also get the `user` object in our [Operations](../data-model/operations/overview) and we can decide what to do based on whether the user is logged in or not.\n\nWe would also get the [Auth UI](../auth/ui) generated for us. We can set up our login and signup pages where our users can **create their account** and **login**. We can then protect certain pages by setting `authRequired: true` for them. This will make sure that only logged-in users can access them.\n\nWe will also have access to the `user` object in our frontend code, so we can show different UI to logged-in and logged-out users. For example, we can show the user's name in the header alongside a **logout button** or a login button if the user is not logged in.\n\n### Different ways to use auth\n\nWhen you have decided which auth methods you want to support, you can also choose how you want to present the authorization flows to your users.\n\n##### Generated components\n\nThis is the fastest way to ship, with Wasp generating ready-made components for your app.\nThey allow for some customization to make them consistent with your app.\nYou don't need to implement any UI or logic, and they just work.\n\n<LinkGrid\n  links={[\n    { title: 'Email', linkTo: './email' },\n    { title: 'Username and password', linkTo: './username-and-pass' },\n    { title: 'Social Auth', linkTo: './social-auth/overview' },\n  ]}\n/>\n\n##### Make your own UI {#custom-auth-ui}\n\nWasp is flexible enough to let you completely customize your login and signup interface.\nWe give you the auth related functions, and you decide how and when to call them.\nThis allows for total customization of the look-and-feel, and the interaction, but it needs a bit more work.\n\n<LinkGrid\n  links={[\n    { title: 'Email', linkTo: './email/create-your-own-ui' },\n    { title: 'Username and password', linkTo: './username-and-pass/create-your-own-ui' },\n    { title: 'Social Auth', linkTo: './social-auth/create-your-own-ui' },\n  ]}\n/>\n\n:::tip\n\nYou don't have to choose one _or_ the other! Mix-and-match, and use what you need in each moment.\nFor example, you can create a custom signup screen, but use Wasp's generated components for login.\n\n:::\n\n##### Custom login and signup actions\n\nThe previously discussed options should cover the vast majority of cases. But, for the few instances where it is not enough,\nyou can [create your own signup flows](./advanced/custom-auth-actions.md), with completely custom logic.\nThis is not recommended, and reserved for advanced use cases.\nPlease check first if other Wasp features (mainly [auth hooks](./auth-hooks.md)) can handle your requirements.\n\n### Protecting a page with `authRequired`\n\nWhen declaring a page, you can set the `authRequired` property.\n\nIf you set it to `true`, only authenticated users can access the page. Unauthenticated users are redirected to a route defined by the `app.auth.onAuthFailedRedirectTo` field.\n\n```wasp title=\"main.wasp\"\npage MainPage {\n  component: import Main from \"@src/pages/Main\",\n  authRequired: true\n}\n```\n\n:::caution Requires auth method\nYou can only use `authRequired` if your app uses one of the [available auth methods](#available-auth-methods).\n:::\n\nIf `authRequired` is set to `true`, the page's React component (specified by the `component` property) receives the `user` object as a prop. Read more about the `user` object in the [Accessing the logged-in user section](#accessing-the-logged-in-user).\n\n### Logout action\n\nWe provide an action for logging out the user. Here's how you can use it:\n\n```tsx title=\"src/components/LogoutButton.tsx\"\n\nconst LogoutButton = () => {\n  return <button onClick={logout}>Logout</button>\n}\n```\n\n### Accessing the logged-in user\n\nYou can get access to the `user` object both on the server and on the client. The `user` object contains the logged-in user's data.\n\nThe `user` object has all the fields that you defined in your `User` entity. In addition to that, it will also contain all the auth-related fields that Wasp stores. This includes things like the `username` or the email verification status. For example, if you have a user that signed up using an email and password, the `user` object might look like this:\n\n```ts\nconst user = {\n  // User data\n  id: 'cluqsex9500017cn7i2hwsg17',\n  address: 'Some address',\n\n  // Auth methods specific data\n  identities: {\n    email: {\n      id: 'user@app.com',\n      isEmailVerified: true,\n      emailVerificationSentAt: '2024-04-08T10:06:02.204Z',\n      passwordResetSentAt: null,\n    },\n  },\n}\n```\n\n<ReadMoreAboutAuthEntities />\n\n#### On the client\n\nThere are two ways to access the `user` object on the client:\n\n- the `user` prop\n- the `useAuth` hook\n\n##### Getting the `user` in authenticated routes\n\nIf the page's declaration sets `authRequired` to `true`, the page's React component receives the `user` object as a prop. This is the simplest way to access the user inside an authenticated page:\n\n```wasp title=\"main.wasp\"\n// ...\n\npage AccountPage {\n  component: import Account from \"@src/pages/Account\",\n  authRequired: true\n}\n```\n\n```tsx title=\"src/pages/Account.tsx\" auto-js\n\nconst AccountPage = ({ user }: { user: AuthUser }) => {\n  return (\n    <div>\n      <Button onClick={logout}>Logout</Button>\n      {JSON.stringify(user, null, 2)}\n    </div>\n  )\n}\n\nexport default AccountPage\n```\n\n##### Getting the `user` in non-authenticated routes\n\nWasp provides a React hook you can use in the client components - `useAuth`.\n\nThis hook is a thin wrapper over Wasp's `useQuery` hook and returns data in the same format.\n\n```tsx title=\"src/pages/MainPage.tsx\" auto-js\n\nexport function Main() {\n  const { data: user } = useAuth()\n\n  if (!user) {\n    return (\n      <span>\n        Please <Link to=\"/login\">login</Link> or{' '}\n        <Link to=\"/signup\">sign up</Link>.\n      </span>\n    )\n  } else {\n    return (\n      <>\n        <button onClick={logout}>Logout</button>\n        <Todo />\n      </>\n    )\n  }\n}\n```\n#### On the server\n\n##### Using the `context.user` object\n\nWhen authentication is enabled, all [queries and actions](../data-model/operations/overview) have access to the `user` object through the `context` argument. `context.user` contains all User entity's fields and the auth identities connected to the user. We strip out the `hashedPassword` field from the identities for security reasons.\n\n```ts title=\"src/actions.ts\" auto-js\n\ntype CreateTaskPayload = Pick<Task, 'description'>\n\nexport const createTask: CreateTask<CreateTaskPayload, Task> = async (\n  args,\n  context\n) => {\n  if (!context.user) {\n    throw new HttpError(403)\n  }\n\n  const Task = context.entities.Task\n  return Task.create({\n    data: {\n      description: args.description,\n      user: {\n        connect: { id: context.user.id },\n      },\n    },\n  })\n}\n```\n\nTo implement access control in your app, each operation must check `context.user` and decide what to do. For example, if `context.user` is `undefined` inside a private operation, the user's access should be denied.\n\nWhen using WebSockets, the `user` object is also available on the `socket.data` object. Read more in the [WebSockets section](../advanced/web-sockets#websocketfn-function).\n\n### Sessions\n\nWasp's auth uses sessions to keep track of the logged-in user. The session is stored in `localStorage` on the client and in the database on the server. Under the hood, Wasp uses the excellent [Lucia Auth v3](https://v3.lucia-auth.com/) library for session management.\n\nWhen users log in, Wasp creates a session for them and stores it in the database. The session is then sent to the client and stored in `localStorage`. When users log out, Wasp deletes the session from the database and from `localStorage`.\n\n### User Entity\n\n#### Password Hashing\n\nIf you are saving a user's password in the database, you should **never** save it as plain text. You can use Wasp's helper functions for serializing and deserializing provider data which will automatically hash the password for you:\n\n```wasp title=\"main.wasp\"\n// ...\n\naction updatePassword {\n  fn: import { updatePassword } from \"@src/auth\",\n}\n```\n\n```ts title=\"src/auth.ts\" auto-js\n\n  createProviderId,\n  findAuthIdentity,\n  updateAuthIdentityProviderData,\n  getProviderDataWithPassword,\n} from 'wasp/server/auth'\n\nexport const updatePassword: UpdatePassword<\n  { email: string; password: string },\n  void\n> = async (args, context) => {\n  const providerId = createProviderId('email', args.email)\n  const authIdentity = await findAuthIdentity(providerId)\n  if (!authIdentity) {\n    throw new HttpError(400, 'Unknown user')\n  }\n\n  const providerData = getProviderDataWithPassword<'email'>(\n    authIdentity.providerData\n  )\n\n  // Updates the password and hashes it automatically.\n  await updateAuthIdentityProviderData(providerId, providerData, {\n    hashedPassword: args.password,\n  })\n}\n```\n\n#### Default Validations\n\nWhen you are using the default authentication flow, Wasp validates the fields with some default validations. These validations run if you use Wasp's built-in [Auth UI](./ui.md) or if you use the provided auth actions.\n\nIf you decide to create your [custom auth actions](./advanced/custom-auth-actions.md), you'll need to run the validations yourself.\n\nDefault validations depend on the auth method you use.\n\n##### Username & Password\n\nIf you use [Username & password](./username-and-pass) authentication, the default validations are:\n\n- The `username` must not be empty\n- The `password` must not be empty, have at least 8 characters, and contain a number\n\nNote that `username`s are stored in a **case-insensitive** manner.\n\n##### Email\n\nIf you use [Email](./email.md) authentication, the default validations are:\n\n- The `email` must not be empty and a valid email address\n- The `password` must not be empty, have at least 8 characters, and contain a number\n\nNote that `email`s are stored in a **case-insensitive** manner.\n\n### Customizing the Signup Process\n\nSometimes you want to include **extra fields** in your signup process, like first name and last name and save them in the `User` entity.\n\nFor this to happen:\n\n- you need to define the fields that you want saved in the database,\n- you need to customize the `SignupForm` (in the case of [Email](./email.md) or [Username & Password](./username-and-pass.md) auth)\n\nOther times, you might need to just add some **extra UI** elements to the form, like a checkbox for terms of service. In this case, customizing only the UI components is enough.\n\nLet's see how to do both.\n\n#### 1. Defining Extra Fields\n\nIf we want to **save** some extra fields in our signup process, we need to tell our app they exist.\n\nWe do that by defining an object where the keys represent the field name, and the values are functions that receive the data sent from the client\\* and return the value of the field.\n\n<small>\n  \\* We exclude the `password` field from this object to prevent it from being saved as plain-text in the database. The `password` field is handled by Wasp's auth backend.\n</small>\n\nFirst, we add the `auth.methods.{authMethod}.userSignupFields` field in our `main.wasp` file. The `{authMethod}` depends on the auth method you are using.\n\nFor example, if you are using [Username & Password](./username-and-pass), you would add the `auth.methods.usernameAndPassword.userSignupFields` field:\n\n```wasp title=\"main.wasp\"\napp crudTesting {\n  // ...\n  auth: {\n    userEntity: User,\n    methods: {\n      usernameAndPassword: {\n        userSignupFields: import { userSignupFields } from \"@src/auth/signup\",\n      },\n    },\n    onAuthFailedRedirectTo: \"/login\",\n  },\n}\n```\n\n```prisma title=\"schema.prisma\"\nmodel User {\n  id      Int     @id @default(autoincrement())\n  address String?\n}\n```\n\nThen we'll define the `userSignupFields` object in the `src/auth/signup.{js,ts}` file:\n\n```ts title=\"src/auth/signup.ts\" auto-js\n\nexport const userSignupFields = defineUserSignupFields({\n  address: async (data) => {\n    const address = data.address\n    if (typeof address !== 'string') {\n      throw new Error('Address is required')\n    }\n    if (address.length < 5) {\n      throw new Error('Address must be at least 5 characters long')\n    }\n    return address\n  },\n})\n```\n\n<small>\n  Read more about the `userSignupFields` object in the [API Reference](#signup-fields-customization).\n</small>\n\nKeep in mind, that these field names need to exist on the `userEntity` you defined in your `main.wasp` file e.g. `address` needs to be a field on the `User` entity you defined in the `schema.prisma` file.\n\nThe field function will receive the data sent from the client and it needs to return the value that will be saved into the database. If the field is invalid, the function should throw an error.\n\n:::info Using Validation Libraries\n\nYou can use any validation library you want to validate the fields. For example, you can use `zod` like this:\n\n<details>\n  <summary>Click to see the code</summary>\n\n  ```ts title=\"src/auth/signup.ts\" auto-js\n  import { defineUserSignupFields } from 'wasp/server/auth'\n  import * as z from 'zod'\n\n  export const userSignupFields = defineUserSignupFields({\n    address: (data) => {\n      const AddressSchema = z\n        .string({\n          required_error: 'Address is required',\n          invalid_type_error: 'Address must be a string',\n        })\n        .min(10, 'Address must be at least 10 characters long')\n      const result = AddressSchema.safeParse(data.address)\n      if (result.success === false) {\n        throw new Error(result.error.issues[0].message)\n      }\n      return result.data\n    },\n  })\n  ```\n</details>\n\n:::\n\nNow that we defined the fields, Wasp knows how to:\n\n1. Validate the data sent from the client\n2. Save the data to the database\n\nNext, let's see how to customize [Auth UI](../auth/ui) to include those fields.\n\n#### 2. Customizing the Signup Component\n\n:::tip Using Custom Signup Component\n\nIf you are not using Wasp's Auth UI, you can skip this section. Just make sure to include the extra fields in your custom signup form.\n\nRead more about using the signup actions for:\n\n- [Email auth](./email/create-your-own-ui.md)\n- [Username & password auth](./username-and-pass/create-your-own-ui.md)\n  :::\n\nIf you are using Wasp's Auth UI, you can customize the `SignupForm` component by passing the `additionalFields` prop to it. It can be either a list of extra fields or a render function.\n\n##### Using a List of Extra Fields\n\nWhen you pass in a list of extra fields to the `SignupForm`, they are added to the form one by one, in the order you pass them in.\n\nInside the list, there can be either **objects** or **render functions** (you can combine them):\n\n1. Objects are a simple way to describe new fields you need, but a bit less flexible than render functions.\n2. Render functions can be used to render any UI you want, but they require a bit more code. The render functions receive the `react-hook-form` object and the form state object as arguments.\n\n```tsx title=\"src/SignupPage.tsx\" auto-js\n\n  SignupForm,\n  FormError,\n  FormInput,\n  FormItemGroup,\n  FormLabel,\n} from 'wasp/client/auth'\n\nexport const SignupPage = () => {\n  return (\n    <SignupForm\n      additionalFields={[\n        /* The address field is defined using an object */\n        {\n          name: 'address',\n          label: 'Address',\n          type: 'input',\n          validations: {\n            required: 'Address is required',\n          },\n        },\n        /* The phone number is defined using a render function */\n        (form, state) => {\n          return (\n            <FormItemGroup>\n              <FormLabel>Phone Number</FormLabel>\n              <FormInput\n                {...form.register('phoneNumber', {\n                  required: 'Phone number is required',\n                })}\n                disabled={state.isLoading}\n              />\n              {form.formState.errors.phoneNumber && (\n                <FormError>\n                  {form.formState.errors.phoneNumber.message}\n                </FormError>\n              )}\n            </FormItemGroup>\n          )\n        },\n      ]}\n    />\n  )\n}\n```\n\n<small>\n  Read more about the extra fields in the [API Reference](#signupform-customization).\n</small>\n\n##### Using a Single Render Function\n\nInstead of passing in a list of extra fields, you can pass in a render function which will receive the `react-hook-form` object and the form state object as arguments. What ever the render function returns, will be rendered below the default fields.\n\n```tsx title=\"src/SignupPage.tsx\" auto-js\n\nexport const SignupPage = () => {\n  return (\n    <SignupForm\n      additionalFields={(form, state) => {\n        const username = form.watch('username')\n        return (\n          username && (\n            <FormItemGroup>\n              Hello there <strong>{username}</strong> 👋\n            </FormItemGroup>\n          )\n        )\n      }}\n    />\n  )\n}\n```\n\n<small>\n  Read more about the render function in the [API Reference](#signupform-customization).\n</small>\n\n### API Reference\n\n#### Auth Fields\n\n```wasp title=\"main.wasp\"\napp MyApp {\n  title: \"My app\",\n  //...\n  auth: {\n    userEntity: User,\n    methods: {\n      usernameAndPassword: {}, // use this or email, not both\n      email: {}, // use this or usernameAndPassword, not both\n      google: {},\n      gitHub: {},\n    },\n    onAuthFailedRedirectTo: \"/someRoute\",\n  }\n}\n\n//...\n```\n\n`app.auth` is a dictionary with the following fields:\n\n##### `userEntity: entity` Required!\n\nThe entity representing the user connected to your business logic.\n\n<ReadMoreAboutAuthEntities />\n\n##### `methods: dict` Required!\n\nA dictionary of auth methods enabled for the app.\n\n<AuthMethodsGrid />\n\n##### `onAuthFailedRedirectTo: String` Required!\n\nThe route to which Wasp should redirect unauthenticated user when they try to access a private page (i.e., a page that has `authRequired: true`).\nCheck out these [essential docs on auth](../tutorial/auth#adding-auth-to-the-project) to see an example of usage.\n\n##### `onAuthSucceededRedirectTo: String`\n\nThe route to which Wasp will send a successfully authenticated after a successful login/signup.\nThe default value is `\"/\"`.\n\n:::note\nAutomatic redirect on successful login only works when using the Wasp-provided [Auth UI](../auth/ui).\n:::\n\n#### Signup Fields Customization\n\nIf you want to add extra fields to the signup process, the server needs to know how to save them to the database. You do that by defining the `auth.methods.{authMethod}.userSignupFields` field in your `main.wasp` file.\n\n```wasp title=\"main.wasp\"\napp crudTesting {\n  // ...\n  auth: {\n    userEntity: User,\n    methods: {\n      usernameAndPassword: {\n        // highlight-next-line\n        userSignupFields: import { userSignupFields } from \"@src/auth/signup\",\n      },\n    },\n    onAuthFailedRedirectTo: \"/login\",\n  },\n}\n```\n\nThen we'll export the `userSignupFields` object from the `src/auth/signup.{js,ts}` file:\n\n```ts title=\"src/auth/signup.ts\" auto-js\n\nexport const userSignupFields = defineUserSignupFields({\n  address: async (data) => {\n    const address = data.address\n    if (typeof address !== 'string') {\n      throw new Error('Address is required')\n    }\n    if (address.length < 5) {\n      throw new Error('Address must be at least 5 characters long')\n    }\n    return address\n  },\n})\n```\n\nThe `userSignupFields` object is an object where the keys represent the field name, and the values are functions that receive the data sent from the client\\* and return the value of the field.\n\nIf the value that the function received is invalid, the function should throw an error.\n\n<small>\n  \\* We exclude the `password` field from this object to prevent it from being saved as plain text in the database. The `password` field is handled by Wasp's auth backend.\n</small>\n\n#### `SignupForm` Customization\n\nTo customize the `SignupForm` component, you need to pass in the `additionalFields` prop. It can be either a list of extra fields or a render function.\n\n```tsx title=\"src/SignupPage.tsx\" auto-js\n\n  SignupForm,\n  FormError,\n  FormInput,\n  FormItemGroup,\n  FormLabel,\n} from 'wasp/client/auth'\n\nexport const SignupPage = () => {\n  return (\n    <SignupForm\n      additionalFields={[\n        {\n          name: 'address',\n          label: 'Address',\n          type: 'input',\n          validations: {\n            required: 'Address is required',\n          },\n        },\n        (form, state) => {\n          return (\n            <FormItemGroup>\n              <FormLabel>Phone Number</FormLabel>\n              <FormInput\n                {...form.register('phoneNumber', {\n                  required: 'Phone number is required',\n                })}\n                disabled={state.isLoading}\n              />\n              {form.formState.errors.phoneNumber && (\n                <FormError>\n                  {form.formState.errors.phoneNumber.message}\n                </FormError>\n              )}\n            </FormItemGroup>\n          )\n        },\n      ]}\n    />\n  )\n}\n```\n\nThe extra fields can be either **objects** or **render functions** (you can combine them):\n\n1. Objects are a simple way to describe new fields you need, but a bit less flexible than render functions.\n\n   The objects have the following properties:\n\n   - `name` Required!\n     - the name of the field\n\n   - `label` Required!\n\n     - the label of the field (used in the UI)\n\n   - `type` Required!\n\n     - the type of the field, which can be `input` or `textarea`\n\n   - `validations`\n     - an object with the validation rules for the field. The keys are the validation names, and the values are the validation error messages. Read more about the available validation rules in the [react-hook-form docs](https://react-hook-form.com/api/useform/register#register).\n\n2. Render functions receive the `react-hook-form` object and the form state as arguments, and they can use them to render arbitrary UI elements.\n\n   The render function has the following signature:\n\n   ```ts\n   type AdditionalSignupFieldRenderFn = (\n      hookForm: UseFormReturn,\n      formState: FormState\n    ) => React.ReactNode\n   ```\n\n   - `form` Required!\n\n     The `react-hook-form` object, read more about it in the [react-hook-form docs](https://react-hook-form.com/api/useform). You need to use the `form.register` function to register your fields\n\n   - `state` Required!\n\n     The form state object, which has the following properties:\n\n     - `isLoading: boolean`\n\n       Whether the form is currently submitting\n\n## Auth UI\n\nTo make using authentication in your app as easy as possible, Wasp generates the server-side code but also the client-side UI for you. It enables you to quickly get the login, signup, password reset and email verification flows in your app.\n\nBelow we cover all of the available UI components and how to use them.\n\n![Auth UI](/img/authui/all_screens.gif)\n\n:::note\n\nRemember that if you need a more custom approach, you can always [create your own UI](./overview.md#custom-auth-ui).\n\n:::\n\n### Overview\n\nAfter Wasp generates the UI components for your auth, you can use it as is, or customize it to your liking.\n\nBased on the authentication providers you enabled in your `main.wasp` file, the Auth UI will show the corresponding UI (form and buttons). For example, if you enabled e-mail authentication:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp {5} title=\"main.wasp\"\n    app MyApp {\n      //...\n      auth: {\n        methods: {\n          email: {},\n        },\n        // ...\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp {5} title=\"main.wasp\"\n    app MyApp {\n      //...\n      auth: {\n        methods: {\n          email: {},\n        },\n        // ...\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nYou'll get the following UI:\n\n![Auth UI](/img/authui/login.png)\n\nAnd then if you enable Google and Github:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\" {6-7}\n    app MyApp {\n      //...\n      auth: {\n        methods: {\n          email: {},\n          google: {},\n          github: {},\n        },\n        // ...\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\" {6-7}\n    app MyApp {\n      //...\n      auth: {\n        methods: {\n          email: {},\n          google: {},\n          github: {},\n        },\n        // ...\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThe form will automatically update to look like this:\n\n![Auth UI](/img/authui/multiple_providers.png)\n\nLet's go through all of the available components and how to use them.\n\n### Auth Components\n\nThe following components are available for you to use in your app:\n\n- [Login form](#login-form)\n- [Signup form](#signup-form)\n- [Forgot password form](#forgot-password-form)\n- [Reset password form](#reset-password-form)\n- [Verify email form](#verify-email-form)\n\n#### Login Form\n\nUsed with <UsernameAndPasswordPill />, <EmailPill />, <GithubPill />, <GooglePill />, <KeycloakPill />, <SlackPill /> and <DiscordPill /> authentication.\n\n![Login form](/img/authui/login.png)\n\nYou can use the `LoginForm` component to build your login page:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    route LoginRoute { path: \"/login\", to: LoginPage }\n    page LoginPage {\n      component: import { LoginPage } from \"@src/LoginPage.jsx\"\n    }\n    ```\n\n    ```tsx title=\"src/LoginPage.jsx\"\n    import { LoginForm } from 'wasp/client/auth'\n\n    // Use it like this\n    export function LoginPage() {\n      return <LoginForm />\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    route LoginRoute { path: \"/login\", to: LoginPage }\n    page LoginPage {\n      component: import { LoginPage } from \"@src/LoginPage.tsx\"\n    }\n    ```\n\n    ```tsx title=\"src/LoginPage.tsx\"\n    import { LoginForm } from 'wasp/client/auth'\n\n    // Use it like this\n    export function LoginPage() {\n      return <LoginForm />\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nIt will automatically show the correct authentication providers based on your `main.wasp` file.\n\n#### Signup Form\n\nUsed with <UsernameAndPasswordPill />, <EmailPill />, <GithubPill />, <GooglePill />, <KeycloakPill />, <SlackPill /> and <DiscordPill /> authentication.\n\n![Signup form](/img/authui/signup.png)\n\nYou can use the `SignupForm` component to build your signup page:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    route SignupRoute { path: \"/signup\", to: SignupPage }\n    page SignupPage {\n      component: import { SignupPage } from \"@src/SignupPage.jsx\"\n    }\n    ```\n\n    ```tsx title=\"src/SignupPage.jsx\"\n    import { SignupForm } from 'wasp/client/auth'\n\n    // Use it like this\n    export function SignupPage() {\n      return <SignupForm />\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    route SignupRoute { path: \"/signup\", to: SignupPage }\n    page SignupPage {\n      component: import { SignupPage } from \"@src/SignupPage.tsx\"\n    }\n    ```\n\n    ```tsx title=\"src/SignupPage.tsx\"\n    import { SignupForm } from 'wasp/client/auth'\n\n    // Use it like this\n    export function SignupPage() {\n      return <SignupForm />\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nIt will automatically show the correct authentication providers based on your `main.wasp` file.\n\nRead more about customizing the signup process like adding additional fields or extra UI in the [Auth Overview](../auth/overview#customizing-the-signup-process) section.\n\n#### Forgot Password Form\n\nUsed with <EmailPill /> authentication.\n\nIf users forget their password, they can use this form to reset it.\n\n![Forgot password form](/img/authui/forgot_password.png)\n\nYou can use the `ForgotPasswordForm` component to build your own forgot password page:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    route RequestPasswordResetRoute { path: \"/request-password-reset\", to: RequestPasswordResetPage }\n    page RequestPasswordResetPage {\n      component: import { ForgotPasswordPage } from \"@src/ForgotPasswordPage.jsx\"\n    }\n    ```\n\n    ```tsx title=\"src/ForgotPasswordPage.jsx\"\n    import { ForgotPasswordForm } from 'wasp/client/auth'\n\n    // Use it like this\n    export function ForgotPasswordPage() {\n      return <ForgotPasswordForm />\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    route RequestPasswordResetRoute { path: \"/request-password-reset\", to: RequestPasswordResetPage }\n    page RequestPasswordResetPage {\n      component: import { ForgotPasswordPage } from \"@src/ForgotPasswordPage.tsx\"\n    }\n    ```\n\n    ```tsx title=\"src/ForgotPasswordPage.tsx\"\n    import { ForgotPasswordForm } from 'wasp/client/auth'\n\n    // Use it like this\n    export function ForgotPasswordPage() {\n      return <ForgotPasswordForm />\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n#### Reset Password Form\n\nUsed with <EmailPill /> authentication.\n\nAfter users click on the link in the email they receive after submitting the forgot password form, they will be redirected to this form where they can reset their password.\n\n![Reset password form](/img/authui/reset_password.png)\n\nYou can use the `ResetPasswordForm` component to build your reset password page:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    route PasswordResetRoute { path: \"/password-reset\", to: PasswordResetPage }\n    page PasswordResetPage {\n      component: import { ResetPasswordPage } from \"@src/ResetPasswordPage.jsx\"\n    }\n    ```\n\n    ```tsx title=\"src/ResetPasswordPage.jsx\"\n    import { ResetPasswordForm } from 'wasp/client/auth'\n\n    // Use it like this\n    export function ResetPasswordPage() {\n      return <ResetPasswordForm />\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    route PasswordResetRoute { path: \"/password-reset\", to: PasswordResetPage }\n    page PasswordResetPage {\n      component: import { ResetPasswordPage } from \"@src/ResetPasswordPage.tsx\"\n    }\n    ```\n\n    ```tsx title=\"src/ResetPasswordPage.tsx\"\n    import { ResetPasswordForm } from 'wasp/client/auth'\n\n    // Use it like this\n    export function ResetPasswordPage() {\n      return <ResetPasswordForm />\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n#### Verify Email Form\n\nUsed with <EmailPill /> authentication.\n\nAfter users sign up, they will receive an email with a link to this form where they can verify their email.\n\n![Verify email form](/img/authui/email_verification.png)\n\nYou can use the `VerifyEmailForm` component to build your email verification page:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    route EmailVerificationRoute { path: \"/email-verification\", to: EmailVerificationPage }\n    page EmailVerificationPage {\n      component: import { VerifyEmailPage } from \"@src/VerifyEmailPage.jsx\"\n    }\n    ```\n\n    ```tsx title=\"src/VerifyEmailPage.jsx\"\n    import { VerifyEmailForm } from 'wasp/client/auth'\n\n    // Use it like this\n    export function VerifyEmailPage() {\n      return <VerifyEmailForm />\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    route EmailVerificationRoute { path: \"/email-verification\", to: EmailVerificationPage }\n    page EmailVerificationPage {\n      component: import { VerifyEmailPage } from \"@src/VerifyEmailPage.tsx\"\n    }\n    ```\n\n    ```tsx title=\"src/VerifyEmailPage.tsx\"\n    import { VerifyEmailForm } from 'wasp/client/auth'\n\n    // Use it like this\n    export function VerifyEmailPage() {\n      return <VerifyEmailForm />\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n### Customization 💅🏻\n\nYou customize all of the available forms by passing props to them.\n\nProps you can pass to all of the forms:\n\n1. `appearance` - customize the form colors (via design tokens)\n2. `logo` - path to your logo\n3. `socialLayout` - layout of the social buttons, which can be `vertical` or `horizontal`\n\n#### 1. Customizing the Colors\n\nWe use [Stitches](https://stitches.dev/) to style the Auth UI. You can customize the styles by overriding the default theme tokens.\n\n:::info List of all available tokens\n\nSee the [list of all available tokens](https://github.com/wasp-lang/wasp/blob/release/waspc/data/Generator/templates/react-app/src/stitches.config.js) which you can override.\n\n:::\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/appearance.js\"\n    export const authAppearance = {\n      colors: {\n        brand: '#5969b8', // blue\n        brandAccent: '#de5998', // pink\n        submitButtonText: 'white',\n      },\n    }\n    ```\n\n    ```jsx title=\"src/LoginPage.jsx\"\n    import { LoginForm } from 'wasp/client/auth'\n    import { authAppearance } from './appearance'\n\n    export function LoginPage() {\n      return (\n        <LoginForm\n          // Pass the appearance object to the form\n          appearance={authAppearance}\n        />\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/appearance.ts\"\n    import type { CustomizationOptions } from 'wasp/client/auth'\n\n    export const authAppearance: CustomizationOptions['appearance'] = {\n      colors: {\n        brand: '#5969b8', // blue\n        brandAccent: '#de5998', // pink\n        submitButtonText: 'white',\n      },\n    }\n    ```\n\n    ```tsx title=\"src/LoginPage.tsx\"\n    import { LoginForm } from 'wasp/client/auth'\n    import { authAppearance } from './appearance'\n\n    export function LoginPage() {\n      return (\n        <LoginForm\n          // Pass the appearance object to the form\n          appearance={authAppearance}\n        />\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nWe recommend defining your appearance in a separate file and importing it into your components.\n\n#### 2. Using Your Logo\n\nYou can add your logo to the Auth UI by passing the `logo` prop to any of the components.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```tsx title=\"src/LoginPage.jsx\"\n    import { LoginForm } from 'wasp/client/auth'\n    import Logo from './logo.png'\n\n    export function LoginPage() {\n      return (\n        <LoginForm\n          // Pass in the path to your logo\n          logo={Logo}\n        />\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/LoginPage.tsx\"\n    import { LoginForm } from 'wasp/client/auth'\n    import Logo from './logo.png'\n\n    export function LoginPage() {\n      return (\n        <LoginForm\n          // Pass in the path to your logo\n          logo={Logo}\n        />\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n#### 3. Social Buttons Layout\n\nYou can change the layout of the social buttons by passing the `socialLayout` prop to any of the components. It can be either `vertical` or `horizontal` (default).\n\nIf we pass in `vertical`:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```tsx title=\"src/LoginPage.jsx\"\n    import { LoginForm } from 'wasp/client/auth'\n\n    export function LoginPage() {\n      return (\n        <LoginForm\n          // Pass in the socialLayout prop\n          socialLayout=\"vertical\"\n        />\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/LoginPage.tsx\"\n    import { LoginForm } from 'wasp/client/auth'\n\n    export function LoginPage() {\n      return (\n        <LoginForm\n          // Pass in the socialLayout prop\n          socialLayout=\"vertical\"\n        />\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nWe get this:\n\n![Vertical social buttons](/img/authui/vertical_social_buttons.png)\n\n#### Let's Put Everything Together 🪄\n\nIf we provide the logo and custom colors:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```ts title=\"src/appearance.js\"\n    export const appearance = {\n      colors: {\n        brand: '#5969b8', // blue\n        brandAccent: '#de5998', // pink\n        submitButtonText: 'white',\n      },\n    }\n    ```\n\n    ```tsx title=\"src/LoginPage.jsx\"\n    import { LoginForm } from 'wasp/client/auth'\n\n    import { authAppearance } from './appearance'\n    import todoLogo from './todoLogo.png'\n\n    export function LoginPage() {\n      return <LoginForm appearance={appearance} logo={todoLogo} />\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/appearance.ts\"\n    import type { CustomizationOptions } from 'wasp/client/auth'\n\n    export const appearance: CustomizationOptions['appearance'] = {\n      colors: {\n        brand: '#5969b8', // blue\n        brandAccent: '#de5998', // pink\n        submitButtonText: 'white',\n      },\n    }\n    ```\n\n    ```tsx title=\"src/LoginPage.tsx\"\n    import { LoginForm } from 'wasp/client/auth'\n\n    import { authAppearance } from './appearance'\n    import todoLogo from './todoLogo.png'\n\n    export function LoginPage() {\n      return <LoginForm appearance={appearance} logo={todoLogo} />\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nWe get a form looking like this:\n\n<div style={{ textAlign: 'center' }}>\n  <img src=\"/img/authui/custom_login.gif\" alt=\"Custom login form\" />\n</div>\n\n## Username & Password Auth Overview\n\nWasp supports username & password authentication out of the box with login and signup flows. It provides you with the server-side implementation and the UI components for the client side.\n\n### Setting Up Username & Password Authentication\n\nTo set up username authentication we need to:\n\n1. Enable username authentication in the Wasp file\n2. Add the `User` entity\n3. Add the auth routes and pages\n4. Use Auth UI components in our pages\n\nStructure of the `main.wasp` file we will end up with:\n\n```wasp title=\"main.wasp\"\n// Configuring e-mail authentication\napp myApp {\n  auth: { ... }\n}\n\n// Defining routes and pages\nroute SignupRoute { ... }\npage SignupPage { ... }\n// ...\n```\n\n#### 1. Enable Username Authentication\n\nLet's start with adding the following to our `main.wasp` file:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\" {11}\n    app myApp {\n      wasp: {\n        version: \"{latestWaspVersion}\"\n      },\n      title: \"My App\",\n      auth: {\n        // 1. Specify the user entity (we'll define it next)\n        userEntity: User,\n        methods: {\n          // 2. Enable username authentication\n          usernameAndPassword: {},\n        },\n        onAuthFailedRedirectTo: \"/login\"\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"  {11}\n    app myApp {\n      wasp: {\n        version: \"{latestWaspVersion}\"\n      },\n      title: \"My App\",\n      auth: {\n        // 1. Specify the user entity (we'll define it next)\n        userEntity: User,\n        methods: {\n          // 2. Enable username authentication\n          usernameAndPassword: {},\n        },\n        onAuthFailedRedirectTo: \"/login\"\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nRead more about th",
        "namespace": "xtasker",
        "timestamp": 1754702868648
      },
      {
        "key": "waspfull_ae",
        "value": "e `usernameAndPassword` auth method options [here](#fields-in-the-usernameandpassword-dict).\n\n#### 2. Add the User Entity\n\nThe `User` entity can be as simple as including only the `id` field:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```prisma title=\"schema.prisma\"\n    // 3. Define the user entity\n    model User {\n      // highlight-next-line\n      id Int @id @default(autoincrement())\n      // Add your own fields below\n      // ...\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```prisma title=\"schema.prisma\"\n    // 3. Define the user entity\n    model User {\n      // highlight-next-line\n      id Int @id @default(autoincrement())\n      // Add your own fields below\n      // ...\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n<ReadMoreAboutAuthEntities />\n\n#### 3. Add the Routes and Pages\n\nNext, we need to define the routes and pages for the authentication pages.\n\nAdd the following to the `main.wasp` file:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n    route LoginRoute { path: \"/login\", to: LoginPage }\n    page LoginPage {\n      component: import { Login } from \"@src/pages/auth.jsx\"\n    }\n    route SignupRoute { path: \"/signup\", to: SignupPage }\n    page SignupPage {\n      component: import { Signup } from \"@src/pages/auth.jsx\"\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n    route LoginRoute { path: \"/login\", to: LoginPage }\n    page LoginPage {\n      component: import { Login } from \"@src/pages/auth.tsx\"\n    }\n    route SignupRoute { path: \"/signup\", to: SignupPage }\n    page SignupPage {\n      component: import { Signup } from \"@src/pages/auth.tsx\"\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nWe'll define the React components for these pages in the `src/pages/auth.{jsx,tsx}` file below.\n\n#### 4. Create the Client Pages\n\n:::info\nWe are using [Tailwind CSS](https://tailwindcss.com/) to style the pages. Read more about how to add it [here](../project/css-frameworks).\n:::\n\nLet's create a `auth.{jsx,tsx}` file in the `src/pages` folder and add the following to it:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```tsx title=\"src/pages/auth.jsx\"\n    import { LoginForm, SignupForm } from 'wasp/client/auth'\n    import { Link } from 'react-router-dom'\n\n    export function Login() {\n      return (\n        <Layout>\n          <LoginForm />\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            Don't have an account yet? <Link to=\"/signup\">go to signup</Link>.\n          </span>\n        </Layout>\n      )\n    }\n\n    export function Signup() {\n      return (\n        <Layout>\n          <SignupForm />\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            I already have an account (<Link to=\"/login\">go to login</Link>).\n          </span>\n        </Layout>\n      )\n    }\n\n    // A layout component to center the content\n    export function Layout({ children }) {\n      return (\n        <div className=\"h-full w-full bg-white\">\n          <div className=\"flex min-h-[75vh] min-w-full items-center justify-center\">\n            <div className=\"h-full w-full max-w-sm bg-white p-5\">\n              <div>{children}</div>\n            </div>\n          </div>\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/pages/auth.tsx\"\n    import { LoginForm, SignupForm } from 'wasp/client/auth'\n    import { Link } from 'react-router-dom'\n\n    export function Login() {\n      return (\n        <Layout>\n          <LoginForm />\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            Don't have an account yet? <Link to=\"/signup\">go to signup</Link>.\n          </span>\n        </Layout>\n      )\n    }\n\n    export function Signup() {\n      return (\n        <Layout>\n          <SignupForm />\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            I already have an account (<Link to=\"/login\">go to login</Link>).\n          </span>\n        </Layout>\n      )\n    }\n\n    // A layout component to center the content\n    export function Layout({ children }: { children: React.ReactNode }) {\n      return (\n        <div className=\"h-full w-full bg-white\">\n          <div className=\"flex min-h-[75vh] min-w-full items-center justify-center\">\n            <div className=\"h-full w-full max-w-sm bg-white p-5\">\n              <div>{children}</div>\n            </div>\n          </div>\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nWe imported the generated Auth UI components and used them in our pages. Read more about the Auth UI components [here](../auth/ui).\n\n#### Conclusion\n\nThat's it! We have set up username authentication in our app. 🎉\n\nRunning `wasp db migrate-dev` and then `wasp start` should give you a working app with username authentication. If you want to put some of the pages behind authentication, read the [auth overview docs](../auth/overview).\n\n<MultipleIdentitiesWarning />\n\n### Using Auth\n\nTo read more about how to set up the logout button and how to get access to the logged-in user in our client and server code, read the [auth overview docs](../auth/overview).\n\nWhen you receive the `user` object [on the client or the server](./overview.md#accessing-the-logged-in-user), you'll be able to access the user's username like this:\n\n<UsernameData />\n\n<AccessingUserDataNote />\n\n### API Reference\n\n#### `userEntity` fields\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      wasp: {\n        version: \"{latestWaspVersion}\"\n      },\n      title: \"My App\",\n      auth: {\n        userEntity: User,\n        methods: {\n          usernameAndPassword: {},\n        },\n        onAuthFailedRedirectTo: \"/login\"\n      }\n    }\n    ```\n\n    ```prisma title=\"schema.prisma\"\n    model User {\n      id Int @id @default(autoincrement())\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      wasp: {\n        version: \"{latestWaspVersion}\"\n      },\n      title: \"My App\",\n      auth: {\n        userEntity: User,\n        methods: {\n          usernameAndPassword: {},\n        },\n        onAuthFailedRedirectTo: \"/login\"\n      }\n    }\n    ```\n\n    ```prisma title=\"schema.prisma\"\n    model User {\n      id Int @id @default(autoincrement())\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n<UserFieldsExplainer />\n\n#### Fields in the `usernameAndPassword` dict\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      wasp: {\n        version: \"{latestWaspVersion}\"\n      },\n      title: \"My App\",\n      auth: {\n        userEntity: User,\n        methods: {\n          usernameAndPassword: {\n            userSignupFields: import { userSignupFields } from \"@src/auth/email.js\",\n          },\n        },\n        onAuthFailedRedirectTo: \"/login\"\n      }\n    }\n    // ...\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      wasp: {\n        version: \"{latestWaspVersion}\"\n      },\n      title: \"My App\",\n      auth: {\n        userEntity: User,\n        methods: {\n          usernameAndPassword: {\n            userSignupFields: import { userSignupFields } from \"@src/auth/email.js\",\n          },\n        },\n        onAuthFailedRedirectTo: \"/login\"\n      }\n    }\n    // ...\n    ```\n  </TabItem>\n</Tabs>\n\n##### `userSignupFields: ExtImport`\n\n<UserSignupFieldsExplainer />\n\nRead more about the `userSignupFields` function [here](./overview#1-defining-extra-fields).\n\n## Create your own UI for Username & Password Auth\n\nThe login and signup flows are pretty standard: they allow the user to sign up and then log in with their username and password. The signup flow validates the username and password and then creates a new user entity in the database.\n\n:::tip\nRead more about the default email and password validation rules in the [auth overview docs](../overview.md#default-validations).\n:::\n\nEven though Wasp offers premade [Auth UI](../ui.md) for your authentication flows, there are times where you might want more customization, so we also give you the option to create your own UI and call Wasp's auth actions on your own code, similar to how Auth UI does it under the hood.\n\n### Example code\n\nBelow you can find a starting point for making your own UI in the client code. You can customize any of its look and behaviour, just make sure to call the `signup()` or `login()` functions imported from `wasp/client/auth`.\n\n#### Sign-up\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/pages/auth.jsx\"\n    import { login, signup } from 'wasp/client/auth'\n\n    import { useState } from 'react'\n    import { useNavigate } from 'react-router-dom'\n\n    export function Signup() {\n      const [username, setUsername] = useState('')\n      const [password, setPassword] = useState('')\n      const [error, setError] = useState(null)\n      const navigate = useNavigate()\n\n      async function handleSubmit(event) {\n        event.preventDefault()\n        setError(null)\n        try {\n          await signup({ username, password })\n          await login({ username, password })\n          navigate('/')\n        } catch (error) {\n          setError(error)\n        }\n      }\n\n      return (\n        <form onSubmit={handleSubmit}>\n          {error && <p>Error: {error.message}</p>}\n\n          <input\n            type=\"text\"\n            autoComplete=\"username\"\n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n            placeholder=\"Username\"\n          />\n          <input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            placeholder=\"Password\"\n          />\n          <button type=\"submit\">Sign Up</button>\n        </form>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/pages/auth.tsx\"\n    import { login, signup } from 'wasp/client/auth'\n\n    import { useState } from 'react'\n    import { useNavigate } from 'react-router-dom'\n\n    export function Signup() {\n      const [username, setUsername] = useState('')\n      const [password, setPassword] = useState('')\n      const [error, setError] = useState<Error | null>(null)\n      const navigate = useNavigate()\n\n      async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {\n        event.preventDefault()\n        setError(null)\n        try {\n          await signup({ username, password })\n          await login({ username, password })\n          navigate('/')\n        } catch (error: unknown) {\n          setError(error as Error)\n        }\n      }\n\n      return (\n        <form onSubmit={handleSubmit}>\n          {error && <p>Error: {error.message}</p>}\n\n          <input\n            type=\"text\"\n            autoComplete=\"username\"\n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n            placeholder=\"Username\"\n          />\n          <input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            placeholder=\"Password\"\n          />\n          <button type=\"submit\">Sign Up</button>\n        </form>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n#### Login\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/pages/auth.jsx\"\n    import { login } from 'wasp/client/auth'\n\n    import { useState } from 'react'\n    import { useNavigate } from 'react-router-dom'\n\n    export function Login() {\n      const [username, setUsername] = useState('')\n      const [password, setPassword] = useState('')\n      const [error, setError] = useState(null)\n      const navigate = useNavigate()\n\n      async function handleSubmit(event) {\n        event.preventDefault()\n        setError(null)\n        try {\n          await login({ username, password })\n          navigate('/')\n        } catch (error) {\n          setError(error)\n        }\n      }\n\n      return (\n        <form onSubmit={handleSubmit}>\n          {error && <p>Error: {error.message}</p>}\n\n          <input\n            type=\"text\"\n            autoComplete=\"username\"\n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n            placeholder=\"Username\"\n          />\n          <input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            placeholder=\"Password\"\n          />\n          <button type=\"submit\">Sign Up</button>\n        </form>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/pages/auth.tsx\"\n    import { login } from 'wasp/client/auth'\n\n    import { useState } from 'react'\n    import { useNavigate } from 'react-router-dom'\n\n    export function Login() {\n      const [username, setUsername] = useState('')\n      const [password, setPassword] = useState('')\n      const [error, setError] = useState<Error | null>(null)\n      const navigate = useNavigate()\n\n      async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {\n        event.preventDefault()\n        setError(null)\n        try {\n          await login({ username, password })\n          navigate('/')\n        } catch (error: unknown) {\n          setError(error as Error)\n        }\n      }\n\n      return (\n        <form onSubmit={handleSubmit}>\n          {error && <p>Error: {error.message}</p>}\n\n          <input\n            type=\"text\"\n            autoComplete=\"username\"\n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n            placeholder=\"Username\"\n          />\n          <input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            placeholder=\"Password\"\n          />\n          <button type=\"submit\">Sign Up</button>\n        </form>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n### API Reference\n\nYou can import the following functions from `wasp/client/auth`:\n\n#### `login()`\n\nAn action for logging in the user.\n\nIt takes one argument:\n\n- `data: object` Required!\n\n  It has the following fields:\n\n  - `username: string` Required!\n\n  - `password: string` Required!\n\n:::note\nWhen using the exposed `login()` function, make sure to implement your redirect on success login logic (e.g. redirecting to home).\n:::\n\n#### `signup()`\n\nAn action for signing up the user. This action does not log in the user, you still need to call `login()`.\n\nIt takes one argument:\n\n- `data: object` Required!\n\n  It has the following fields:\n\n  - `username: string` Required!\n\n  - `password: string` Required!\n\n:::info\nBy default, Wasp will only save the `username` and `password` fields. If you want to add extra fields to your signup process, read about [defining extra signup fields](../overview.md#customizing-the-signup-process).\n:::\n\n## Email Auth Overview\n\nWasp supports e-mail authentication out of the box, along with email verification and \"forgot your password?\" flows. It provides you with the server-side implementation and email templates for all of these flows.\n\n![Auth UI](/img/authui/all_screens.gif)\n\n<MultipleIdentitiesWarning />\n\n### Setting Up Email Authentication\n\nWe'll need to take the following steps to set up email authentication:\n\n1. Enable email authentication in the Wasp file\n2. Add the `User` entity\n3. Add the auth routes and pages\n4. Use Auth UI components in our pages\n5. Set up the email sender\n\nStructure of the `main.wasp` file we will end up with:\n\n```wasp title=\"main.wasp\"\n// Configuring e-mail authentication\napp myApp {\n  auth: { ... },\n  emailSender: { ... }\n}\n\n// Defining routes and pages\nroute SignupRoute { ... }\npage SignupPage { ... }\n// ...\n```\n\n#### 1. Enable Email Authentication in `main.wasp`\n\nLet's start with adding the following to our `main.wasp` file:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      wasp: {\n        version: \"{latestWaspVersion}\"\n      },\n      title: \"My App\",\n      auth: {\n        // 1. Specify the user entity (we'll define it next)\n        userEntity: User,\n        methods: {\n          // 2. Enable email authentication\n          email: {\n            // 3. Specify the email from field\n            fromField: {\n              name: \"My App Postman\",\n              email: \"hello@itsme.com\"\n            },\n            // 4. Specify the email verification and password reset options (we'll talk about them later)\n            emailVerification: {\n              clientRoute: EmailVerificationRoute,\n            },\n            passwordReset: {\n              clientRoute: PasswordResetRoute,\n            },\n          },\n        },\n        onAuthFailedRedirectTo: \"/login\",\n        onAuthSucceededRedirectTo: \"/\"\n      },\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      wasp: {\n        version: \"{latestWaspVersion}\"\n      },\n      title: \"My App\",\n      auth: {\n        // 1. Specify the user entity (we'll define it next)\n        userEntity: User,\n        methods: {\n          // 2. Enable email authentication\n          email: {\n            // 3. Specify the email from field\n            fromField: {\n              name: \"My App Postman\",\n              email: \"hello@itsme.com\"\n            },\n            // 4. Specify the email verification and password reset options (we'll talk about them later)\n            emailVerification: {\n              clientRoute: EmailVerificationRoute,\n            },\n            passwordReset: {\n              clientRoute: PasswordResetRoute,\n            },\n          },\n        },\n        onAuthFailedRedirectTo: \"/login\",\n        onAuthSucceededRedirectTo: \"/\"\n      },\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nRead more about the `email` auth method options [here](#fields-in-the-email-dict).\n\n#### 2. Add the User Entity\n\nThe `User` entity can be as simple as including only the `id` field:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```prisma title=\"schema.prisma\"\n    // 5. Define the user entity\n    model User {\n      // highlight-next-line\n      id Int @id @default(autoincrement())\n      // Add your own fields below\n      // ...\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```prisma title=\"schema.prisma\"\n    // 5. Define the user entity\n    model User {\n      // highlight-next-line\n      id Int @id @default(autoincrement())\n      // Add your own fields below\n      // ...\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n<ReadMoreAboutAuthEntities />\n\n#### 3. Add the Routes and Pages\n\nNext, we need to define the routes and pages for the authentication pages.\n\nAdd the following to the `main.wasp` file:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    route LoginRoute { path: \"/login\", to: LoginPage }\n    page LoginPage {\n      component: import { Login } from \"@src/pages/auth.jsx\"\n    }\n\n    route SignupRoute { path: \"/signup\", to: SignupPage }\n    page SignupPage {\n      component: import { Signup } from \"@src/pages/auth.jsx\"\n    }\n\n    route RequestPasswordResetRoute { path: \"/request-password-reset\", to: RequestPasswordResetPage }\n    page RequestPasswordResetPage {\n      component: import { RequestPasswordReset } from \"@src/pages/auth.jsx\",\n    }\n\n    route PasswordResetRoute { path: \"/password-reset\", to: PasswordResetPage }\n    page PasswordResetPage {\n      component: import { PasswordReset } from \"@src/pages/auth.jsx\",\n    }\n\n    route EmailVerificationRoute { path: \"/email-verification\", to: EmailVerificationPage }\n    page EmailVerificationPage {\n      component: import { EmailVerification } from \"@src/pages/auth.jsx\",\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    route LoginRoute { path: \"/login\", to: LoginPage }\n    page LoginPage {\n      component: import { Login } from \"@src/pages/auth.tsx\"\n    }\n\n    route SignupRoute { path: \"/signup\", to: SignupPage }\n    page SignupPage {\n      component: import { Signup } from \"@src/pages/auth.tsx\"\n    }\n\n    route RequestPasswordResetRoute { path: \"/request-password-reset\", to: RequestPasswordResetPage }\n    page RequestPasswordResetPage {\n      component: import { RequestPasswordReset } from \"@src/pages/auth.tsx\",\n    }\n\n    route PasswordResetRoute { path: \"/password-reset\", to: PasswordResetPage }\n    page PasswordResetPage {\n      component: import { PasswordReset } from \"@src/pages/auth.tsx\",\n    }\n\n    route EmailVerificationRoute { path: \"/email-verification\", to: EmailVerificationPage }\n    page EmailVerificationPage {\n      component: import { EmailVerification } from \"@src/pages/auth.tsx\",\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nWe'll define the React components for these pages in the `src/pages/auth.{jsx,tsx}` file below.\n\n#### 4. Create the Client Pages\n\n:::info\nWe are using [Tailwind CSS](https://tailwindcss.com/) to style the pages. Read more about how to add it [here](../project/css-frameworks).\n:::\n\nLet's create a `auth.{jsx,tsx}` file in the `src/pages` folder and add the following to it:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```tsx title=\"src/pages/auth.jsx\"\n    import {\n      LoginForm,\n      SignupForm,\n      VerifyEmailForm,\n      ForgotPasswordForm,\n      ResetPasswordForm,\n    } from 'wasp/client/auth'\n    import { Link } from 'react-router-dom'\n\n    export function Login() {\n      return (\n        <Layout>\n          <LoginForm />\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            Don't have an account yet? <Link to=\"/signup\">go to signup</Link>.\n          </span>\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            Forgot your password? <Link to=\"/request-password-reset\">reset it</Link>.\n          </span>\n        </Layout>\n      )\n    }\n\n    export function Signup() {\n      return (\n        <Layout>\n          <SignupForm />\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            I already have an account (<Link to=\"/login\">go to login</Link>).\n          </span>\n        </Layout>\n      )\n    }\n\n    export function EmailVerification() {\n      return (\n        <Layout>\n          <VerifyEmailForm />\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            If everything is okay, <Link to=\"/login\">go to login</Link>\n          </span>\n        </Layout>\n      )\n    }\n\n    export function RequestPasswordReset() {\n      return (\n        <Layout>\n          <ForgotPasswordForm />\n        </Layout>\n      )\n    }\n\n    export function PasswordReset() {\n      return (\n        <Layout>\n          <ResetPasswordForm />\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            If everything is okay, <Link to=\"/login\">go to login</Link>\n          </span>\n        </Layout>\n      )\n    }\n\n    // A layout component to center the content\n    export function Layout({ children }) {\n      return (\n        <div className=\"h-full w-full bg-white\">\n          <div className=\"flex min-h-[75vh] min-w-full items-center justify-center\">\n            <div className=\"h-full w-full max-w-sm bg-white p-5\">\n              <div>{children}</div>\n            </div>\n          </div>\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/pages/auth.tsx\"\n    import {\n      LoginForm,\n      SignupForm,\n      VerifyEmailForm,\n      ForgotPasswordForm,\n      ResetPasswordForm,\n    } from 'wasp/client/auth'\n    import { Link } from 'react-router-dom'\n\n    export function Login() {\n      return (\n        <Layout>\n          <LoginForm />\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            Don't have an account yet? <Link to=\"/signup\">go to signup</Link>.\n          </span>\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            Forgot your password? <Link to=\"/request-password-reset\">reset it</Link>.\n          </span>\n        </Layout>\n      )\n    }\n\n    export function Signup() {\n      return (\n        <Layout>\n          <SignupForm />\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            I already have an account (<Link to=\"/login\">go to login</Link>).\n          </span>\n        </Layout>\n      )\n    }\n\n    export function EmailVerification() {\n      return (\n        <Layout>\n          <VerifyEmailForm />\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            If everything is okay, <Link to=\"/login\">go to login</Link>\n          </span>\n        </Layout>\n      )\n    }\n\n    export function RequestPasswordReset() {\n      return (\n        <Layout>\n          <ForgotPasswordForm />\n        </Layout>\n      )\n    }\n\n    export function PasswordReset() {\n      return (\n        <Layout>\n          <ResetPasswordForm />\n          <br />\n          <span className=\"text-sm font-medium text-gray-900\">\n            If everything is okay, <Link to=\"/login\">go to login</Link>\n          </span>\n        </Layout>\n      )\n    }\n\n    // A layout component to center the content\n    export function Layout({ children }: { children: React.ReactNode }) {\n      return (\n        <div className=\"h-full w-full bg-white\">\n          <div className=\"flex min-h-[75vh] min-w-full items-center justify-center\">\n            <div className=\"h-full w-full max-w-sm bg-white p-5\">\n              <div>{children}</div>\n            </div>\n          </div>\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nWe imported the generated Auth UI components and used them in our pages. Read more about the Auth UI components [here](../auth/ui).\n\n#### 5. Set up an Email Sender\n\nTo support e-mail verification and password reset flows, we need an e-mail sender. Luckily, Wasp supports several email providers out of the box.\n\nWe'll use the `Dummy` provider to speed up the setup. It just logs the emails to the console instead of sending them. You can use any of the [supported email providers](../advanced/email#providers).\n\nTo set up the `Dummy` provider to send emails, add the following to the `main.wasp` file:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      // ...\n      // 7. Set up the email sender\n      emailSender: {\n        provider: Dummy,\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      // ...\n      // 7. Set up the email sender\n      emailSender: {\n        provider: Dummy,\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n#### Conclusion\n\nThat's it! We have set up email authentication in our app. 🎉\n\nRunning `wasp db migrate-dev` and then `wasp start` should give you a working app with email authentication. If you want to put some of the pages behind authentication, read the [auth overview](../auth/overview).\n\n### Login and Signup Flows\n\n#### Login\n\n![Auth UI](/img/authui/login.png)\n\n#### Signup\n\n![Auth UI](/img/authui/signup.png)\n\nSome of the behavior you get out of the box:\n\n1. Rate limiting\n\nWe are limiting the rate of sign-up requests to **1 request per minute** per email address. This is done to prevent spamming.\n\n2. Preventing user email leaks\n\nIf somebody tries to signup with an email that already exists and it's verified, we _pretend_ that the account was created instead of saying it's an existing account. This is done to prevent leaking the user's email address.\n\n3. Allowing registration for unverified emails\n\nIf a user tries to register with an existing but **unverified** email, we'll allow them to do that. This is done to prevent bad actors from locking out other users from registering with their email address.\n\n4. Password validation\n\nRead more about the default password validation rules and how to override them in [auth overview docs](../auth/overview).\n\n### Email Verification Flow\n\n:::info Automatic email verification in development\n\nIn development mode, you can skip the email verification step by setting the `SKIP_EMAIL_VERIFICATION_IN_DEV` environment variable to `true` in your `.env.server` file:\n\n```env title=\".env.server\"\nSKIP_EMAIL_VERIFICATION_IN_DEV=true\n```\n\nThis is useful when you are developing your app and don't want to go through the email verification flow every time you sign up. It can be also useful when you are writing automated tests for your app.\n:::\n\nBy default, Wasp requires the e-mail to be verified before allowing the user to log in. This is done by sending a verification email to the user's email address and requiring the user to click on a link in the email to verify their email address.\n\nOur setup looks like this:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    emailVerification: {\n        clientRoute: EmailVerificationRoute,\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    emailVerification: {\n        clientRoute: EmailVerificationRoute,\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nWhen the user receives an e-mail, they receive a link that goes to the client route specified in the `clientRoute` field. In our case, this is the `EmailVerificationRoute` route we defined in the `main.wasp` file.\n\nThe content of the e-mail can be customized, read more about it [here](#emailverification-emailverificationconfig-).\n\n#### Email Verification Page\n\nWe defined our email verification page in the `auth.{jsx,tsx}` file.\n\n![Auth UI](/img/authui/email_verification.png)\n\n### Password Reset Flow\n\nUsers can request a password and then they'll receive an e-mail with a link to reset their password.\n\nSome of the behavior you get out of the box:\n\n1. Rate limiting\n\nWe are limiting the rate of sign-up requests to **1 request per minute** per email address. This is done to prevent spamming.\n\n2. Preventing user email leaks\n\nIf somebody requests a password reset with an unknown email address, we'll give back the same response as if the user requested a password reset successfully. This is done to prevent leaking information.\n\nOur setup in `main.wasp` looks like this:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    passwordReset: {\n        clientRoute: PasswordResetRoute,\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    passwordReset: {\n        clientRoute: PasswordResetRoute,\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n#### Request Password Reset Page\n\nUsers request their password to be reset by going to the `/request-password-reset` route. We defined our request password reset page in the `auth.{jsx,tsx}` file.\n\n![Request password reset page](/img/authui/forgot_password_after.png)\n\n#### Password Reset Page\n\nWhen the user receives an e-mail, they receive a link that goes to the client route specified in the `clientRoute` field. In our case, this is the `PasswordResetRoute` route we defined in the `main.wasp` file.\n\n![Request password reset page](/img/authui/reset_password_after.png)\n\nUsers can enter their new password there.\n\nThe content of the e-mail can be customized, read more about it [here](#passwordreset-passwordresetconfig-).\n\n##### Password\n\n- `ensurePasswordIsPresent(args)`\n\n  Checks if the password is present and throws an error if it's not.\n\n- `ensureValidPassword(args)`\n\n  Checks if the password is valid and throws an error if it's not. Read more about the validation rules [here](../auth/overview#default-validations).\n\n### Using Auth\n\nTo read more about how to set up the logout button and how to get access to the logged-in user in our client and server code, read the [auth overview docs](../auth/overview).\n\nWhen you receive the `user` object [on the client or the server](./overview.md#accessing-the-logged-in-user), you'll be able to access the user's email and other information like this:\n\n<EmailData />\n\n<AccessingUserDataNote />\n\n### API Reference\n\nLet's go over the options we can specify when using email authentication.\n\n#### `userEntity` fields\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      title: \"My app\",\n      // ...\n\n      auth: {\n        userEntity: User,\n        methods: {\n          email: {\n            // We'll explain these options below\n          },\n        },\n        onAuthFailedRedirectTo: \"/someRoute\"\n      },\n      // ...\n    }\n    ```\n\n    ```prisma title=\"schema.prisma\"\n    model User {\n      id Int @id @default(autoincrement())\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      title: \"My app\",\n      // ...\n\n      auth: {\n        userEntity: User,\n        methods: {\n          email: {\n            // We'll explain these options below\n          },\n        },\n        onAuthFailedRedirectTo: \"/someRoute\"\n      },\n      // ...\n    }\n    ```\n\n    ```prisma title=\"schema.prisma\"\n    model User {\n      id Int @id @default(autoincrement())\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n<UserFields />\n\n#### Fields in the `email` dict\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      title: \"My app\",\n      // ...\n\n      auth: {\n        userEntity: User,\n        methods: {\n          email: {\n            userSignupFields: import { userSignupFields } from \"@src/auth.js\",\n            fromField: {\n              name: \"My App\",\n              email: \"hello@itsme.com\"\n            },\n            emailVerification: {\n              clientRoute: EmailVerificationRoute,\n              getEmailContentFn: import { getVerificationEmailContent } from \"@src/auth/email.js\",\n            },\n            passwordReset: {\n              clientRoute: PasswordResetRoute,\n              getEmailContentFn: import { getPasswordResetEmailContent } from \"@src/auth/email.js\",\n            },\n          },\n        },\n        onAuthFailedRedirectTo: \"/someRoute\"\n      },\n      // ...\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      title: \"My app\",\n      // ...\n\n      auth: {\n        userEntity: User,\n        methods: {\n          email: {\n            userSignupFields: import { userSignupFields } from \"@src/auth.js\",\n            fromField: {\n              name: \"My App\",\n              email: \"hello@itsme.com\"\n            },\n            emailVerification: {\n              clientRoute: EmailVerificationRoute,\n              getEmailContentFn: import { getVerificationEmailContent } from \"@src/auth/email.js\",\n            },\n            passwordReset: {\n              clientRoute: PasswordResetRoute,\n              getEmailContentFn: import { getPasswordResetEmailContent } from \"@src/auth/email.js\",\n            },\n          },\n        },\n        onAuthFailedRedirectTo: \"/someRoute\"\n      },\n      // ...\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n##### `userSignupFields: ExtImport`\n\n<UserSignupFieldsExplainer />\n\nRead more about the `userSignupFields` function [here](./overview#1-defining-extra-fields).\n\n##### `fromField: EmailFromField` Required!\n\n`fromField` is a dict that specifies the name and e-mail address of the sender of the e-mails sent by your app.\n\nIt has the following fields:\n\n- `name`: name of the sender\n- `email`: e-mail address of the sender Required!\n\n##### `emailVerification: EmailVerificationConfig` Required!\n\n`emailVerification` is a dict that specifies the details of the e-mail verification process.\n\nIt has the following fields:\n\n- `clientRoute: Route`: a route that is used for the user to verify their e-mail address. Required!\n\n  Client route should handle the process of taking a token from the URL and sending it to the server to verify the e-mail address. You can use our `verifyEmail` action for that.\n\n  <Tabs groupId=\"js-ts\">\n    <TabItem value=\"js\" label=\"JavaScript\">\n      ```js title=\"src/pages/EmailVerificationPage.jsx\"\n      import { verifyEmail } from 'wasp/client/auth'\n      ...\n      await verifyEmail({ token });\n      ```\n    </TabItem>\n\n    <TabItem value=\"ts\" label=\"TypeScript\">\n      ```ts title=\"src/pages/EmailVerificationPage.tsx\"\n      import { verifyEmail } from 'wasp/client/auth'\n      ...\n      await verifyEmail({ token });\n      ```\n    </TabItem>\n  </Tabs>\n\n  :::note\n  We used Auth UI above to avoid doing this work of sending the token to the server manually.\n  :::\n\n- `getEmailContentFn: ExtImport`: a function that returns the content of the e-mail that is sent to the user.\n\n  Defining `getEmailContentFn` can be done by defining a file in the `src` directory.\n\n  <Tabs groupId=\"js-ts\">\n    <TabItem value=\"js\" label=\"JavaScript\">\n      ```ts title=\"src/email.js\"\n      export const getVerificationEmailContent = ({ verificationLink }) => ({\n        subject: 'Verify your email',\n        text: `Click the link below to verify your email: ${verificationLink}`,\n        html: `\n              <p>Click the link below to verify your email</p>\n              <a href=\"${verificationLink}\">Verify email</a>\n          `,\n      })\n      ```\n    </TabItem>\n\n    <TabItem value=\"ts\" label=\"TypeScript\">\n      ```ts title=\"src/email.ts\"\n      import { GetVerificationEmailContentFn } from 'wasp/server/auth'\n\n      export const getVerificationEmailContent: GetVerificationEmailContentFn = ({\n        verificationLink,\n      }) => ({\n        subject: 'Verify your email',\n        text: `Click the link below to verify your email: ${verificationLink}`,\n        html: `\n              <p>Click the link below to verify your email</p>\n              <a href=\"${verificationLink}\">Verify email</a>\n          `,\n      })\n      ```\n    </TabItem>\n  </Tabs>\n\n  <small>This is the default content of the e-mail, you can customize it to your liking.</small>\n\n##### `passwordReset: PasswordResetConfig` Required!\n\n`passwordReset` is a dict that specifies the password reset process.\n\nIt has the following fields:\n\n- `clientRoute: Route`: a route that is used for the user to reset their password. Required!\n\n  Client route should handle the process of taking a token from the URL and a new password from the user and sending it to the server. You can use our `requestPasswordReset` and `resetPassword` actions to do that.\n\n  <Tabs groupId=\"js-ts\">\n    <TabItem value=\"js\" label=\"JavaScript\">\n      ```js title=\"src/pages/ForgotPasswordPage.jsx\"\n      import { requestPasswordReset } from 'wasp/client/auth'\n      ...\n      await requestPasswordReset({ email });\n      ```\n\n      ```js title=\"src/pages/PasswordResetPage.jsx\"\n      import { resetPassword } from 'wasp/client/auth'\n      ...\n      await resetPassword({ password, token })\n      ```\n    </TabItem>\n\n    <TabItem value=\"ts\" label=\"TypeScript\">\n      ```ts title=\"src/pages/ForgotPasswordPage.tsx\"\n      import { requestPasswordReset } from 'wasp/client/auth'\n      ...\n      await requestPasswordReset({ email });\n      ```\n\n      ```ts title=\"src/pages/PasswordResetPage.tsx\"\n      import { resetPassword } from 'wasp/client/auth'\n      ...\n      await resetPassword({ password, token })\n      ```\n    </TabItem>\n  </Tabs>\n\n  :::note\n  We used Auth UI above to avoid doing this work of sending the password request and the new password to the server manually.\n  :::\n\n- `getEmailContentFn: ExtImport`: a function that returns the content of the e-mail that is sent to the user.\n\n  Defining `getEmailContentFn` is done by defining a function that looks like this:\n\n  <Tabs groupId=\"js-ts\">\n    <TabItem value=\"js\" label=\"JavaScript\">\n      ```ts title=\"src/email.js\"\n      export const getPasswordResetEmailContent = ({ passwordResetLink }) => ({\n        subject: 'Password reset',\n        text: `Click the link below to reset your password: ${passwordResetLink}`,\n        html: `\n              <p>Click the link below to reset your password</p>\n              <a href=\"${passwordResetLink}\">Reset password</a>\n          `,\n      })\n      ```\n    </TabItem>\n\n    <TabItem value=\"ts\" label=\"TypeScript\">\n      ```ts title=\"src/email.ts\"\n      import { GetPasswordResetEmailContentFn } from 'wasp/server/auth'\n\n      export const getPasswordResetEmailContent: GetPasswordResetEmailContentFn = ({\n        passwordResetLink,\n      }) => ({\n        subject: 'Password reset',\n        text: `Click the link below to reset your password: ${passwordResetLink}`,\n        html: `\n              <p>Click the link below to reset your password</p>\n              <a href=\"${passwordResetLink}\">Reset password</a>\n          `,\n      })\n      ```\n    </TabItem>\n  </Tabs>\n\n  <small>This is the default content of the e-mail, you can customize it to your liking.</small>\n\n## Create your own UI for Email Auth\n\nWhen using the email auth provider, users log in with their email address and a password. On signup, Wasp validates the data and sends a verification email. The user account is not active until the user clicks the link in the verification email. Also, the user can reset their password through a similar flow.\n\n:::tip\nRead more about the default email and password validation rules in the [auth overview docs](../overview.md#default-validations).\n:::\n\nEven though Wasp offers premade [Auth UI](../ui.md) for your authentication flows, there are times when you might want more customization, so we also give you the option to create your own UI and call Wasp's auth actions from your own code, similar to how Auth UI does it under the hood.\n\n### Example code\n\nBelow you can find a starting point for making your own UI in the client code. This example has all the necessary components to handle login, signup, email verification, and the password reset flow. You can customize any of its look and behaviour, just make sure to call the functions imported from `wasp/client/auth`.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/pages/auth.jsx\"\n    import {\n      login,\n      requestPasswordReset,\n      resetPassword,\n      signup,\n      verifyEmail,\n    } from 'wasp/client/auth'\n\n    import { useState } from 'react'\n    import { useNavigate } from 'react-router-dom'\n\n    // This will be shown when the user wants to log in\n    export function Login() {\n      const [email, setEmail] = useState('')\n      const [password, setPassword] = useState('')\n      const [error, setError] = useState(null)\n      const navigate = useNavigate()\n\n      async function handleSubmit(event) {\n        event.preventDefault()\n        setError(null)\n        try {\n          await login({ email, password })\n          navigate('/')\n        } catch (error) {\n          setError(error)\n        }\n      }\n\n      return (\n        <form onSubmit={handleSubmit}>\n          {error && <p>Error: {error.message}</p>}\n\n          <input\n            type=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            placeholder=\"Email\"\n          />\n          <input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            placeholder=\"Password\"\n          />\n          <button type=\"submit\">Log In</button>\n        </form>\n      )\n    }\n\n    // This will be shown when the user wants to sign up\n    export function Signup() {\n      const [email, setEmail] = useState('')\n      const [password, setPassword] = useState('')\n      const [error, setError] = useState(null)\n      const [needsConfirmation, setNeedsConfirmation] = useState(false)\n\n      async function handleSubmit(event) {\n        event.preventDefault()\n        setError(null)\n        try {\n          await signup({ email, password })\n          setNeedsConfirmation(true)\n        } catch (error) {\n          console.error('Error during signup:', error)\n          setError(error)\n        }\n      }\n\n      if (needsConfirmation) {\n        return (\n          <p>\n            Check your email for the confirmation link. If you don't see it, check\n            spam/junk folder.\n          </p>\n        )\n      }\n\n      return (\n        <form onSubmit={handleSubmit}>\n          {error && <p>Error: {error.message}</p>}\n\n          <input\n            type=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            placeholder=\"Email\"\n          />\n          <input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            placeholder=\"Password\"\n          />\n          <button type=\"submit\">Sign Up</button>\n        </form>\n      )\n    }\n\n    // This will be shown has clicked on the link in their\n    // email to verify their email address\n    export function EmailVerification() {\n      const [error, setError] = useState(null)\n      const navigate = useNavigate()\n\n      async function handleClick() {\n        setError(null)\n        try {\n          // The token is passed as a query parameter\n          const token = new URLSearchParams(window.location.search).get('token')\n          if (!token) throw new Error('Token not found in URL')\n          await verifyEmail({ token })\n          navigate('/')\n        } catch (error) {\n          console.error('Error during email verification:', error)\n          setError(error)\n        }\n      }\n\n      return (\n        <>\n          {error && <p>Error: {error.message}</p>}\n\n          <button onClick={handleClick}>Verify email</button>\n        </>\n      )\n    }\n\n    // This will be shown when the user wants to reset their password\n    export function RequestPasswordReset() {\n      const [email, setEmail] = useState('')\n      const [error, setError] = useState(null)\n      const [needsConfirmation, setNeedsConfirmation] = useState(false)\n\n      async function handleSubmit(event) {\n        event.preventDefault()\n        setError(null)\n        try {\n          await requestPasswordReset({ email })\n          setNeedsConfirmation(true)\n        } catch (error) {\n          console.error('Error during requesting reset:', error)\n          setError(error)\n        }\n      }\n\n      if (needsConfirmation) {\n        return (\n          <p>\n            Check your email for the confirmation link. If you don't see it, check\n            spam/junk folder.\n          </p>\n        )\n      }\n\n      return (\n        <form onSubmit={handleSubmit}>\n          {error && <p>Error: {error.message}</p>}\n\n          <input\n            type=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            placeholder=\"Email\"\n          />\n\n          <button type=\"submit\">Send password reset</button>\n        </form>\n      )\n    }\n\n    // This will be shown when the user clicks on the link in their\n    // email to reset their password\n    export function PasswordReset() {\n      const [error, setError] = useState(null)\n      const [newPassword, setNewPassword] = useState('')\n      const navigate = useNavigate()\n\n      async function handleSubmit(event) {\n        event.preventDefault()\n        setError(null)\n        try {\n          // The token is passed as a query parameter\n          const token = new URLSearchParams(window.location.search).get('token')\n          if (!token) throw new Error('Token not found in URL')\n          await resetPassword({ token, password: newPassword })\n          navigate('/')\n        } catch (error) {\n          console.error('Error during password reset:', error)\n          setError(error)\n        }\n      }\n\n      return (\n        <form onSubmit={handleSubmit}>\n          {error && <p>Error: {error.message}</p>}\n\n          <input\n            type=\"password\"\n            autoComplete=\"new-password\"\n            value={newPassword}\n            onChange={(e) => setNewPassword(e.target.value)}\n            placeholder=\"New password\"\n          />\n\n          <button type=\"submit\">Reset password</button>\n        </form>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/pages/auth.tsx\"\n    import {\n      login,\n      requestPasswordReset,\n      resetPassword,\n      signup,\n      verifyEmail,\n    } from 'wasp/client/auth'\n\n    import { useState } from 'react'\n    import { useNavigate } from 'react-router-dom'\n\n    // This will be shown when the user wants to log in\n    export function Login() {\n      const [email, setEmail] = useState('')\n      const [password, setPassword] = useState('')\n      const [error, setError] = useState<Error | null>(null)\n      const navigate = useNavigate()\n\n      async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {\n        event.preventDefault()\n        setError(null)\n        try {\n          await login({ email, password })\n          navigate('/')\n        } catch (error: unknown) {\n          setError(error as Error)\n        }\n      }\n\n      return (\n        <form onSubmit={handleSubmit}>\n          {error && <p>Error: {error.message}</p>}\n\n          <input\n            type=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            placeholder=\"Email\"\n          />\n          <input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            placeholder=\"Password\"\n          />\n          <button type=\"submit\">Log In</button>\n        </form>\n      )\n    }\n\n    // This will be shown when the user wants to sign up\n    export function Signup() {\n      const [email, setEmail] = useState('')\n      const [password, setPassword] = useState('')\n      const [error, setError] = useState<Error | null>(null)\n      const [needsConfirmation, setNeedsConfirmation] = useState(false)\n\n      async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {\n        event.preventDefault()\n        setError(null)\n        try {\n          await signup({ email, password })\n          setNeedsConfirmation(true)\n        } catch (error: unknown) {\n          console.error('Error during signup:', error)\n          setError(error as Error)\n        }\n      }\n\n      if (needsConfirmation) {\n        return (\n          <p>\n            Check your email for the confirmation link. If you don't see it, check\n            spam/junk folder.\n          </p>\n        )\n      }\n\n      return (\n        <form onSubmit={handleSubmit}>\n          {error && <p>Error: {error.message}</p>}\n\n          <input\n            type=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            placeholder=\"Email\"\n          />\n          <input\n            type=\"password\"\n            value={password}\n            onChange={(e) => setPassword(e.target.value)}\n            placeholder=\"Password\"\n          />\n          <button type=\"submit\">Sign Up</button>\n        </form>\n      )\n    }\n\n    // This will be shown has clicked on the link in their\n    // email to verify their email a",
        "namespace": "xtasker",
        "timestamp": 1754702873104
      },
      {
        "key": "waspfull_af",
        "value": "ddress\n    export function EmailVerification() {\n      const [error, setError] = useState<Error | null>(null)\n      const navigate = useNavigate()\n\n      async function handleClick() {\n        setError(null)\n        try {\n          // The token is passed as a query parameter\n          const token = new URLSearchParams(window.location.search).get('token')\n          if (!token) throw new Error('Token not found in URL')\n          await verifyEmail({ token })\n          navigate('/')\n        } catch (error: unknown) {\n          console.error('Error during email verification:', error)\n          setError(error as Error)\n        }\n      }\n\n      return (\n        <>\n          {error && <p>Error: {error.message}</p>}\n\n          <button onClick={handleClick}>Verify email</button>\n        </>\n      )\n    }\n\n    // This will be shown when the user wants to reset their password\n    export function RequestPasswordReset() {\n      const [email, setEmail] = useState('')\n      const [error, setError] = useState<Error | null>(null)\n      const [needsConfirmation, setNeedsConfirmation] = useState(false)\n\n      async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {\n        event.preventDefault()\n        setError(null)\n        try {\n          await requestPasswordReset({ email })\n          setNeedsConfirmation(true)\n        } catch (error: unknown) {\n          console.error('Error during requesting reset:', error)\n          setError(error as Error)\n        }\n      }\n\n      if (needsConfirmation) {\n        return (\n          <p>\n            Check your email for the confirmation link. If you don't see it, check\n            spam/junk folder.\n          </p>\n        )\n      }\n\n      return (\n        <form onSubmit={handleSubmit}>\n          {error && <p>Error: {error.message}</p>}\n\n          <input\n            type=\"email\"\n            value={email}\n            onChange={(e) => setEmail(e.target.value)}\n            placeholder=\"Email\"\n          />\n\n          <button type=\"submit\">Send password reset</button>\n        </form>\n      )\n    }\n\n    // This will be shown when the user clicks on the link in their\n    // email to reset their password\n    export function PasswordReset() {\n      const [error, setError] = useState<Error | null>(null)\n      const [newPassword, setNewPassword] = useState('')\n      const navigate = useNavigate()\n\n      async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {\n        event.preventDefault()\n        setError(null)\n        try {\n          // The token is passed as a query parameter\n          const token = new URLSearchParams(window.location.search).get('token')\n          if (!token) throw new Error('Token not found in URL')\n          await resetPassword({ token, password: newPassword })\n          navigate('/')\n        } catch (error: unknown) {\n          console.error('Error during password reset:', error)\n          setError(error as Error)\n        }\n      }\n\n      return (\n        <form onSubmit={handleSubmit}>\n          {error && <p>Error: {error.message}</p>}\n\n          <input\n            type=\"password\"\n            autoComplete=\"new-password\"\n            value={newPassword}\n            onChange={(e) => setNewPassword(e.target.value)}\n            placeholder=\"New password\"\n          />\n\n          <button type=\"submit\">Reset password</button>\n        </form>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n### API Reference\n\nYou can import the following functions from `wasp/client/auth`:\n\n#### `login()`\n\nAn action for logging in the user. Make sure to do a redirect on success (e.g. to the main page of the app).\n\nIt takes one argument:\n\n- `data: object` Required!\n\n  It has the following fields:\n\n  - `email: string` Required!\n\n  - `password: string` Required!\n\n#### `signup()`\n\nAn action for signing up the user and starting the email verification. The user will not be logged in after this, as they still need\nto verify their email.\n\nIt takes one argument:\n\n- `data: object` Required!\n\n  It has the following fields:\n\n  - `email: string` Required!\n\n  - `password: string` Required!\n\n:::info\nBy default, Wasp will only save the `email` and `password` fields. If you want to add extra fields to your signup process, read about [defining extra signup fields](../overview.md#customizing-the-signup-process).\n:::\n\n#### `verifyEmail()`\n\nAn action for marking the email as valid and the user account as active. Make sure to do a redirect on success (e.g. to the login page).\n\nIt takes one argument:\n\n- `data: object` Required!\n\n  It has the following fields:\n\n  - `token: string` Required!\n\n    The token that was created when signing up. It will be set as a URL Query Parameter named `token`.\n\n#### `requestPasswordReset()`\n\nAn action for asking for a password reset email. This doesn't immediately reset their password, just sends the email.\n\nIt takes one argument:\n\n- `data: object` Required!\n\n  It has the following fields:\n\n  - `email: string` Required!\n\n#### `resetPassword()`\n\nAn action for confirming a password reset and providing the new password. Make sure to do a redirect on success (e.g. to the login page).\n\nIt takes one argument:\n\n- `data: object` Required!\n\n  It has the following fields:\n\n  - `token: string` Required!\n\n    The token that was created when requesting the password reset. It will be set as a URL Query Parameter named `token`.\n\n  - `password: string` Required!\n\n    The new password for the user.\n\n## Social Auth Overview\n\nSocial login options (e.g., _Log in with Google_) are a great (maybe even the best) solution for handling user accounts.\nA famous old developer joke tells us _\"The best auth system is the one you never have to make.\"_\n\nWasp wants to make adding social login options to your app as painless as possible.\n\nUsing different social providers gives users a chance to sign into your app via their existing accounts on other platforms (Google, GitHub, etc.).\n\nThis page goes through the common behaviors between all supported social login providers and shows you how to customize them.\nIt also gives an overview of Wasp's UI helpers - the quickest possible way to get started with social auth.\n\n### Available Providers\n\nWasp currently supports the following social login providers:\n\n<SocialAuthGrid />\n\n### User Entity\n\nWasp requires you to declare a `userEntity` for all `auth` methods (social or otherwise).\nThis field tells Wasp which Entity represents the user.\n\nHere's what the full setup looks like:\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    // highlight-next-line\n    userEntity: User,\n    methods: {\n      google: {}\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n```prisma title=\"schema.prisma\"\n// highlight-next-line\nmodel User {\n  id Int @id @default(autoincrement())\n}\n```\n\n### Default Behavior\n\n<DefaultBehaviour />\n\n### Overrides\n\nBy default, Wasp doesn't store any information it receives from the social login provider. It only stores the user's ID specific to the provider.\n\nIf you wish to store more information about the user, you can override the default behavior. You can do this by defining the `userSignupFields` and `configFn` fields in `main.wasp` for each provider.\n\nYou can create custom signup setups, such as allowing users to define a custom username after they sign up with a social provider.\n\n#### Example: Allowing User to Set Their Username\n\nIf you want to modify the signup flow (e.g., let users choose their own usernames), you will need to go through three steps:\n\n1. The first step is adding a `isSignupComplete` property to your `User` Entity. This field will signal whether the user has completed the signup process.\n2. The second step is overriding the default signup behavior.\n3. The third step is implementing the rest of your signup flow and redirecting users where appropriate.\n\nLet's go through both steps in more detail.\n\n##### 1. Adding the `isSignupComplete` Field to the `User` Entity\n\n```prisma title=\"schema.prisma\"\nmodel User {\n  id               Int     @id @default(autoincrement())\n  username         String? @unique\n  // highlight-next-line\n  isSignupComplete Boolean @default(false)\n}\n```\n\n##### 2. Overriding the Default Behavior\n\nDeclare an import under `app.auth.methods.google.userSignupFields` (the example assumes you're using Google):\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      google: {\n        // highlight-next-line\n        userSignupFields: import { userSignupFields } from \"@src/auth/google\"\n      }\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n\n// ...\n```\n\nAnd implement the imported function:\n\n```ts title=\"src/auth/google.ts\" auto-js\n\nexport const userSignupFields = defineUserSignupFields({\n  isSignupComplete: () => false,\n})\n```\n\n<GetUserFieldsType />\n\n##### 3. Showing the Correct State on the Client\n\nYou can check the `isSignupComplete` flag on the `user` object.\nAuthenticated pages come with the [`user` prop](../../auth/overview#getting-the-user-in-authenticated-routes) which gives you access to the current user. If the `user` prop is out of reach, fetch the current user with the  [`useAuth()` hook](../../auth/overview#getting-the-user-in-non-authenticated-routes).\n\nDepending on the flag's value, you can redirect users to the appropriate signup step.\n\nFor example:\n\n1. When the user lands on the homepage, check the value of `user.isSignupComplete`.\n2. If it's `false`, it means the user has started the signup process but hasn't yet chosen their username. Therefore, you can redirect them to `EditUserDetailsPage` where they can edit the `username` property.\n\n```tsx title=\"src/HomePage.tsx\" auto-js\n\nexport function HomePage({ user }: { user: AuthUser }) {\n  if (user.isSignupComplete === false) {\n    return <Navigate to=\"/edit-user-details\" />\n  }\n\n  // ...\n}\n```\n\nThe same general principle applies to more complex signup procedures, just change the boolean `isSignupComplete` property to a property like `currentSignupStep` that can hold more values.\n\n#### Using the User's Provider Account Details\n\nAccount details are provider-specific.\nEach provider has their own rules for defining the `userSignupFields` and `configFn` fields:\n\n<SocialAuthGrid pagePart=\"#overrides\" />\n\n### API Reference\n\n#### Fields in the `app.auth` Dictionary and Overrides\n\nFor more information on:\n\n- Allowed fields in `app.auth`\n- `userSignupFields` and `configFn` functions\n\nCheck the provider-specific API References:\n\n<SocialAuthGrid pagePart=\"#api-reference\" />\n\n## GitHub\n\nWasp supports GitHub Authentication out of the box.\nGitHub is a great external auth choice when you're building apps for developers, as most of them already have a GitHub account.\n\nLetting your users log in using their GitHub accounts turns the signup process into a breeze.\n\nLet's walk through enabling GitHub Authentication, explain some of the default settings, and show how to override them.\n\n### Setting up GitHub Auth\n\nEnabling GitHub Authentication comes down to a series of steps:\n\n1. Enabling GitHub authentication in the Wasp file.\n2. Adding the `User` entity.\n3. Creating a GitHub OAuth app.\n4. Adding the necessary Routes and Pages\n5. Using Auth UI components in our Pages.\n\n<WaspFileStructureNote />\n\n#### 1. Adding GitHub Auth to Your Wasp File\n\nLet's start by properly configuring the Auth object:\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    // highlight-next-line\n    // 1. Specify the User entity  (we'll define it next)\n    // highlight-next-line\n    userEntity: User,\n    methods: {\n      // highlight-next-line\n      // 2. Enable GitHub Auth\n      // highlight-next-line\n      gitHub: {}\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n#### 2. Add the User Entity\n\nLet's now define the `app.auth.userEntity` entity in the `schema.prisma` file:\n\n```prisma title=\"schema.prisma\"\n// 3. Define the user entity\nmodel User {\n  // highlight-next-line\n  id Int @id @default(autoincrement())\n  // Add your own fields below\n  // ...\n}\n```\n\n#### 3. Creating a GitHub OAuth App\n\nTo use GitHub as an authentication method, you'll first need to create a GitHub OAuth App and provide Wasp with your client key and secret. Here's how you do it:\n\n1. Log into your GitHub account and navigate to: https://github.com/settings/developers.\n2. Select **New OAuth App**.\n3. Supply required information.\n\n<img alt=\"GitHub Applications Screenshot\" src={useBaseUrl('img/integrations-github-1.png')} width=\"400px\" />\n\n- For **Authorization callback URL**:\n  - For development, put: `http://localhost:3001/auth/github/callback`.\n  - Once you know on which URL your API server will be deployed, you can create a new app with that URL instead e.g. `https://your-server-url.com/auth/github/callback`.\n\n4. Hit **Register application**.\n5. Hit **Generate a new client secret** on the next page.\n6. Copy your Client ID and Client secret as you'll need them in the next step.\n\n#### 4. Adding Environment Variables\n\nAdd these environment variables to the `.env.server` file at the root of your project (take their values from the previous step):\n\n```bash title=\".env.server\"\nGITHUB_CLIENT_ID=your-github-client-id\nGITHUB_CLIENT_SECRET=your-github-client-secret\n```\n\n#### 5. Adding the Necessary Routes and Pages\n\nLet's define the necessary authentication Routes and Pages.\n\nAdd the following code to your `main.wasp` file:\n\n```wasp title=\"main.wasp\"\n// ...\n\nroute LoginRoute { path: \"/login\", to: LoginPage }\npage LoginPage {\n  component: import { Login } from \"@src/pages/auth\"\n}\n```\n\nWe'll define the React components for these pages in the `src/pages/auth.{jsx,tsx}` file below.\n\n#### 6. Creating the Client Pages\n\n:::info\nWe are using [Tailwind CSS](https://tailwindcss.com/) to style the pages. Read more about how to add it [here](../../project/css-frameworks).\n:::\n\nLet's create a `auth.{jsx,tsx}` file in the `src/pages` folder and add the following to it:\n\n```tsx title=\"src/pages/auth.tsx\" auto-js\n\nexport function Login() {\n  return (\n    <Layout>\n      <LoginForm />\n    </Layout>\n  )\n}\n\n// A layout component to center the content\nexport function Layout({ children }: { children: ReactNode }) {\n  return (\n    <div className=\"h-full w-full bg-white\">\n      <div className=\"flex min-h-[75vh] min-w-full items-center justify-center\">\n        <div className=\"h-full w-full max-w-sm bg-white p-5\">\n          <div>{children}</div>\n        </div>\n      </div>\n    </div>\n  )\n}\n```\n\nWe imported the generated Auth UI components and used them in our pages. Read more about the Auth UI components [here](../../auth/ui).\n\n#### Conclusion\n\nYay, we've successfully set up GitHub Auth! 🎉\n\n![GitHub Auth](/img/auth/github.png)\n\nRunning `wasp db migrate-dev` and `wasp start` should now give you a working app with authentication.\nTo see how to protect specific pages (i.e., hide them from non-authenticated users), read the docs on [using auth](../../auth/overview).\n\n### Default Behaviour\n\nAdd `gitHub: {}` to the `auth.methods` dictionary to use it with default settings.\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      // highlight-next-line\n      gitHub: {}\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n<DefaultBehaviour />\n\n### Overrides\n\n<OverrideIntro />\n\n#### Data Received From GitHub\n\nWe are using GitHub's API and its `/user` and `/user/emails` endpoints to get the user data.\n\n:::info We combine the data from the two endpoints\n\nYou'll find the emails in the `emails` property in the object that you receive in `userSignupFields`.\n\nThis is because we combine the data from the `/user` and `/user/emails` endpoints **if the `user` or `user:email` scope is requested.**\n\n:::\n\nThe data we receive from GitHub on the `/user` endpoint looks something this:\n\n```json\n{\n  \"login\": \"octocat\",\n  \"id\": 1,\n  \"name\": \"monalisa octocat\",\n  \"avatar_url\": \"https://github.com/images/error/octocat_happy.gif\",\n  \"gravatar_id\": \"\"\n  // ...\n}\n```\n\nAnd the data from the `/user/emails` endpoint looks something like this:\n\n```json\n[\n  {\n    \"email\": \"octocat@github.com\",\n    \"verified\": true,\n    \"primary\": true,\n    \"visibility\": \"public\"\n  }\n]\n```\n\nThe fields you receive will depend on the scopes you requested. By default we don't specify any scopes. If you want to get the emails, you need to specify the `user` or `user:email` scope in the `configFn` function.\n\n<small>\n  For an up to date info about the data received from GitHub, please refer to the [GitHub API documentation](https://docs.github.com/en/rest/users/users?apiVersion=2022-11-28#get-the-authenticated-user).\n</small>\n\n#### Using the Data Received From GitHub\n\n<OverrideExampleIntro />\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      gitHub: {\n        // highlight-next-line\n        configFn: import { getConfig } from \"@src/auth/github\",\n        // highlight-next-line\n        userSignupFields: import { userSignupFields } from \"@src/auth/github\"\n      }\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n```prisma title=\"schema.prisma\"\nmodel User {\n  id          Int    @id @default(autoincrement())\n  username    String @unique\n  displayName String\n}\n\n// ...\n```\n\n```ts title=\"src/auth/github.ts\" auto-js\n\nexport const userSignupFields = defineUserSignupFields({\n  username: () => 'hardcoded-username',\n  displayName: (data: any) => data.profile.name,\n})\n\nexport function getConfig() {\n  return {\n    scopes: ['user'],\n  }\n}\n```\n\n<GetUserFieldsType />\n\n### Using Auth\n\n<UsingAuthNote />\n\nWhen you receive the `user` object [on the client or the server](../overview.md#accessing-the-logged-in-user), you'll be able to access the user's GitHub ID like this:\n\n<GithubData />\n\n<AccessingUserDataNote />\n\n### API Reference\n\n<ApiReferenceIntro />\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      gitHub: {\n        // highlight-next-line\n        configFn: import { getConfig } from \"@src/auth/github\",\n        // highlight-next-line\n        userSignupFields: import { userSignupFields } from \"@src/auth/github\"\n      }\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\nThe `gitHub` dict has the following properties:\n\n- #### `configFn: ExtImport`\n\n  This function should return an object with the scopes for the OAuth provider.\n\n  ```ts title=\"src/auth/github.ts\" auto-js\n  export function getConfig() {\n    return {\n      scopes: [],\n    }\n  }\n  ```\n\n- #### `userSignupFields: ExtImport`\n\n  <UserSignupFieldsExplainer />\n\n  Read more about the `userSignupFields` function [here](../overview#1-defining-extra-fields).\n\n## Google\n\nWasp supports Google Authentication out of the box.\nGoogle Auth is arguably the best external auth option, as most users on the web already have Google accounts.\n\nEnabling it lets your users log in using their existing Google accounts, greatly simplifying the process and enhancing the user experience.\n\nLet's walk through enabling Google authentication, explain some of the default settings, and show how to override them.\n\n### Setting up Google Auth\n\nEnabling Google Authentication comes down to a series of steps:\n\n1. Enabling Google authentication in the Wasp file.\n2. Adding the `User` entity.\n3. Creating a Google OAuth app.\n4. Adding the necessary Routes and Pages\n5. Using Auth UI components in our Pages.\n\n<WaspFileStructureNote />\n\n#### 1. Adding Google Auth to Your Wasp File\n\nLet's start by properly configuring the Auth object:\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    // 1. Specify the User entity (we'll define it next)\n    // highlight-next-line\n    userEntity: User,\n    methods: {\n      // 2. Enable Google Auth\n      // highlight-next-line\n      google: {}\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n`userEntity` is explained in [the social auth overview](./overview.md#user-entity).\n\n#### 2. Adding the User Entity\n\nLet's now define the `app.auth.userEntity` entity in the `schema.prisma` file:\n\n```prisma title=\"schema.prisma\"\n// 3. Define the user entity\nmodel User {\n  // highlight-next-line\n  id Int @id @default(autoincrement())\n  // Add your own fields below\n  // ...\n}\n```\n\n#### 3. Creating a Google OAuth App\n\nTo use Google as an authentication method, you'll first need to create a Google project and provide Wasp with your client key and secret. Here's how you do it:\n\n1. Create a Google Cloud Platform account if you do not already have one: https://cloud.google.com/\n2. Create and configure a new Google project here: https://console.cloud.google.com/projectcreate\n\n    ![Google Console Screenshot 1](/img/integrations-google-v2-1.png)\n\n    ![Google Console Screenshot 2](/img/integrations-google-v2-2.png)\n\n3. Search for **Google Auth** in the top bar (1), click on **Google Auth Platform** (2). Then click on **Get Started** (3).\n\n    ![Google Console Screenshot 3](/img/integrations-google-v2-3.png)\n\n    ![Google Console Screenshot 4](/img/integrations-google-v2-4.png)\n\n4. Fill out you app information. For the **Audience** field, we will go with **External**. When you're done, click **Create**.\n\n    ![Google Console Screenshot 5](/img/integrations-google-v2-5.png)\n\n    ![Google Console Screenshot 6](/img/integrations-google-v2-6.png)\n\n5. You should now be in the **OAuth Overview** page. Click on **Create OAuth Client** (1).\n\n    ![Google Console Screenshot 7](/img/integrations-google-v2-7.png)\n\n6. Fill out the form. These are the values for a typical Wasp application:\n\n    | # | Field                    | Value                                        |\n    | - | ------------------------ | -------------------------------------------- |\n    | 1 | Application type         | Web application                              |\n    | 2 | Name                     | (your wasp app name)                         |\n    | 3 | Authorized redirect URIs | `http://localhost:3001/auth/google/callback` |\n\n    :::note\n    Once you know on which URL(s) your API server will be deployed, also add those URL(s) to the **Authorized redirect URIs**.\\\n    For example: `https://your-server-url.com/auth/google/callback`\n    :::\n\n    ![Google Console Screenshot 8](/img/integrations-google-v2-8.png)\n\n    Then click on **Create** (4).\n\n7. You will see a box saying **OAuth client created**. Click on **OK**.\n\n    ![Google Console Screenshot 9](/img/integrations-google-v2-9.png)\n\n8. Click on the name of your newly-created app.\n\n    ![Google Console Screenshot 10](/img/integrations-google-v2-10.png)\n\n9. On the right-hand side, you will see your **Client ID** (1) and **Client secret** (2). **Copy them somewhere safe, as you will need them for your app.**\n\n    ![Google Console Screenshot 11](/img/integrations-google-v2-11.png)\n\n    :::info\n    These are the credentials your app will use to authenticate with Google. Do not share them anywhere publicly, as anyone with these credentials can impersonate your app and access user data.\n    :::\n\n10. Click on **Data Access** (1) in the left-hand menu, then click on **Add or remove scopes** (2). You should select `userinfo.profile` (3), and optionally `userinfo.email` (4), or any other scopes you want to use. Remember to click **Update** and **Save** when done.\n\n    ![Google Console Screenshot 12](/img/integrations-google-v2-12.png)\n\n    ![Google Console Screenshot 13](/img/integrations-google-v2-13.png)\n\n11. Go to **Audience** (1) in the left-hand menu, and add any test users you want (2). This is useful for testing your app before going live. You can add any email addresses you want to test with.\n\n    ![Google Console Screenshot 14](/img/integrations-google-v2-14.png)\n\n12. Finally, you can go to **Branding** (1) in the left-hand menu, and customize your app's branding in the Google login page. _This is optional_, but recommended if you want to make your app look more professional.\n\n    ![Google Console Screenshot 15](/img/integrations-google-v2-15.png)\n\n#### 4. Adding Environment Variables\n\nAdd these environment variables to the `.env.server` file at the root of your project (take their values from the previous step):\n\n```bash title=\".env.server\"\nGOOGLE_CLIENT_ID=your-google-client-id\nGOOGLE_CLIENT_SECRET=your-google-client-secret\n```\n\n#### 5. Adding the Necessary Routes and Pages\n\nLet's define the necessary authentication Routes and Pages.\n\nAdd the following code to your `main.wasp` file:\n\n```wasp title=\"main.wasp\"\n// ...\n\nroute LoginRoute { path: \"/login\", to: LoginPage }\npage LoginPage {\n  component: import { Login } from \"@src/pages/auth\"\n}\n```\n\nWe'll define the React components for these pages in the `src/pages/auth.{jsx,tsx}` file below.\n\n#### 6. Create the Client Pages\n\n:::info\nWe are using [Tailwind CSS](https://tailwindcss.com/) to style the pages. Read more about how to add it [here](../../project/css-frameworks).\n:::\n\nLet's now create a `auth.{jsx,tsx}` file in the `src/pages`.\nIt should have the following code:\n\n```tsx title=\"src/pages/auth.tsx\" auto-js\n\nexport function Login() {\n  return (\n    <Layout>\n      <LoginForm />\n    </Layout>\n  )\n}\n\n// A layout component to center the content\nexport function Layout({ children }: { children: ReactNode }) {\n  return (\n    <div className=\"h-full w-full bg-white\">\n      <div className=\"flex min-h-[75vh] min-w-full items-center justify-center\">\n        <div className=\"h-full w-full max-w-sm bg-white p-5\">\n          <div>{children}</div>\n        </div>\n      </div>\n    </div>\n  )\n}\n```\n\n:::info Auth UI\nOur pages use an automatically-generated Auth UI component. Read more about Auth UI components [here](../../auth/ui).\n:::\n\n#### Conclusion\n\nYay, we've successfully set up Google Auth! 🎉\n\n![Google Auth](/img/auth/google.png)\n\nRunning `wasp db migrate-dev` and `wasp start` should now give you a working app with authentication.\nTo see how to protect specific pages (i.e., hide them from non-authenticated users), read the docs on [using auth](../../auth/overview).\n\n### Default Behaviour\n\nAdd `google: {}` to the `auth.methods` dictionary to use it with default settings:\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      // highlight-next-line\n      google: {}\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n<DefaultBehaviour />\n\n### Overrides\n\n<OverrideIntro />\n\n#### Data Received From Google\n\nWe are using Google's API and its `/userinfo` endpoint to fetch the user's data.\n\nThe data received from Google is an object which can contain the following fields:\n\n```json\n[\n  \"name\",\n  \"given_name\",\n  \"family_name\",\n  \"email\",\n  \"email_verified\",\n  \"aud\",\n  \"exp\",\n  \"iat\",\n  \"iss\",\n  \"locale\",\n  \"picture\",\n  \"sub\"\n]\n```\n\nThe fields you receive depend on the scopes you request. The default scope is set to `profile` only. If you want to get the user's email, you need to specify the `email` scope in the `configFn` function.\n\n<small>\n  For an up to date info about the data received from Google, please refer to the [Google API documentation](https://developers.google.com/identity/openid-connect/openid-connect#an-id-tokens-payload).\n</small>\n\n#### Using the Data Received From Google\n\n<OverrideExampleIntro />\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      google: {\n        // highlight-next-line\n        configFn: import { getConfig } from \"@src/auth/google\",\n        // highlight-next-line\n        userSignupFields: import { userSignupFields } from \"@src/auth/google\"\n      }\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n```prisma title=\"schema.prisma\"\nmodel User {\n  id          Int    @id @default(autoincrement())\n  username    String @unique\n  displayName String\n}\n\n// ...\n```\n\n```ts title=\"src/auth/google.ts\" auto-js\n\nexport const userSignupFields = defineUserSignupFields({\n  username: () => 'hardcoded-username',\n  displayName: (data: any) => data.profile.name,\n})\n\nexport function getConfig() {\n  return {\n    scopes: ['profile', 'email'],\n  }\n}\n```\n\n<GetUserFieldsType />\n\n### Using Auth\n\n<UsingAuthNote />\n\nWhen you receive the `user` object [on the client or the server](../overview.md#accessing-the-logged-in-user), you'll be able to access the user's Google ID like this:\n\n<GoogleData />\n\n<AccessingUserDataNote />\n\n### API Reference\n\n<ApiReferenceIntro />\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      google: {\n        // highlight-next-line\n        configFn: import { getConfig } from \"@src/auth/google\",\n        // highlight-next-line\n        userSignupFields: import { userSignupFields } from \"@src/auth/google\"\n      }\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\nThe `google` dict has the following properties:\n\n- #### `configFn: ExtImport`\n\n  This function must return an object with the scopes for the OAuth provider.\n\n  ```ts title=\"src/auth/google.ts\" auto-js\n  export function getConfig() {\n    return {\n      scopes: ['profile', 'email'],\n    }\n  }\n  ```\n\n- #### `userSignupFields: ExtImport`\n\n  <UserSignupFieldsExplainer />\n\n  Read more about the `userSignupFields` function [here](../overview#1-defining-extra-fields).\n\n## Keycloak\n\nWasp supports Keycloak Authentication out of the box.\n\n[Keycloak](https://www.keycloak.org/) is an open-source identity and access management solution for modern applications and services. Keycloak provides both SAML and OpenID protocol solutions. It also has a very flexible and powerful administration UI.\n\nLet's walk through enabling Keycloak authentication, explain some of the default settings, and show how to override them.\n\n### Setting up Keycloak Auth\n\nEnabling Keycloak Authentication comes down to a series of steps:\n\n1. Enabling Keycloak authentication in the Wasp file.\n2. Adding the `User` entity.\n3. Creating a Keycloak client.\n4. Adding the necessary Routes and Pages\n5. Using Auth UI components in our Pages.\n\n<WaspFileStructureNote />\n\n#### 1. Adding Keycloak Auth to Your Wasp File\n\nLet's start by properly configuring the Auth object:\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    // 1. Specify the User entity (we'll define it next)\n    // highlight-next-line\n    userEntity: User,\n    methods: {\n      // 2. Enable Keycloak Auth\n      // highlight-next-line\n      keycloak: {}\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n`userEntity` is explained in [the social auth overview](./overview.md#user-entity).\n\n#### 2. Adding the User Entity\n\nLet's now define the `app.auth.userEntity` entity in the `schema.prisma` file:\n\n```prisma title=\"schema.prisma\"\n// 3. Define the user entity\nmodel User {\n  // highlight-next-line\n  id Int @id @default(autoincrement())\n  // Add your own fields below\n  // ...\n}\n```\n\n#### 3. Creating a Keycloak Client\n\n1. Log into your Keycloak admin console.\n2. Under **Clients**, click on **Create Client**.\n\n![Keycloak Screenshot 1](/img/auth/keycloak/1-keycloak.png)\n\n1. Fill in the **Client ID** and choose a name for the client.\n\n![Keycloak Screenshot 2](/img/auth/keycloak/2-keycloak.png)\n\n1. In the next step, enable **Client Authentication**.\n\n![Keycloak Screenshot 3](/img/auth/keycloak/3-keycloak.png)\n\n1. Under **Valid Redirect URIs**, add `http://localhost:3001/auth/keycloak/callback` for local development.\n\n![Keycloak Screenshot 4](/img/auth/keycloak/4-keycloak.png)\n\n- Once you know on which URL(s) your API server will be deployed, also add those URL(s).\n- For example: `https://my-server-url.com/auth/keycloak/callback`.\n\n1. Click **Save**.\n2. In the **Credentials** tab, copy the **Client Secret** value, which we'll use in the next step.\n\n![Keycloak Screenshot 5](/img/auth/keycloak/5-keycloak.png)\n\n#### 4. Adding Environment Variables\n\nAdd these environment variables to the `.env.server` file at the root of your project (take their values from the previous step):\n\n```bash title=\".env.server\"\nKEYCLOAK_CLIENT_ID=your-keycloak-client-id\nKEYCLOAK_CLIENT_SECRET=your-keycloak-client-secret\nKEYCLOAK_REALM_URL=https://your-keycloak-url.com/realms/master\n```\n\nWe assumed in the `KEYCLOAK_REALM_URL` env variable that you are using the `master` realm. If you are using a different realm, replace `master` with your realm name.\n\n#### 5. Adding the Necessary Routes and Pages\n\nLet's define the necessary authentication Routes and Pages.\n\nAdd the following code to your `main.wasp` file:\n\n```wasp title=\"main.wasp\"\n// ...\n\nroute LoginRoute { path: \"/login\", to: LoginPage }\npage LoginPage {\n  component: import { Login } from \"@src/pages/auth\"\n}\n```\n\nWe'll define the React components for these pages in the `src/pages/auth.{jsx,tsx}` file below.\n\n#### 6. Create the Client Pages\n\n:::info\nWe are using [Tailwind CSS](https://tailwindcss.com/) to style the pages. Read more about how to add it [here](../../project/css-frameworks).\n:::\n\nLet's now create an `auth.{jsx,tsx}` file in the `src/pages`.\nIt should have the following code:\n\n```tsx title=\"src/pages/auth.tsx\" auto-js\n\nexport function Login() {\n  return (\n    <Layout>\n      <LoginForm />\n    </Layout>\n  )\n}\n\n// A layout component to center the content\nexport function Layout({ children }: { children: ReactNode }) {\n  return (\n    <div className=\"h-full w-full bg-white\">\n      <div className=\"flex min-h-[75vh] min-w-full items-center justify-center\">\n        <div className=\"h-full w-full max-w-sm bg-white p-5\">\n          <div>{children}</div>\n        </div>\n      </div>\n    </div>\n  )\n}\n```\n\n:::info Auth UI\nOur pages use an automatically generated Auth UI component. Read more about Auth UI components [here](../../auth/ui).\n:::\n\n#### Conclusion\n\nYay, we've successfully set up Keycloak Auth!\n\nRunning `wasp db migrate-dev` and `wasp start` should now give you a working app with authentication.\nTo see how to protect specific pages (i.e., hide them from non-authenticated users), read the docs on [using auth](../../auth/overview).\n\n### Default Behaviour\n\nAdd `keycloak: {}` to the `auth.methods` dictionary to use it with default settings:\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      // highlight-next-line\n      keycloak: {}\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n<DefaultBehaviour />\n\n### Overrides\n\n<OverrideIntro />\n\n#### Data Received From Keycloak\n\nWe are using Keycloak's API and its `/userinfo` endpoint to fetch the user's data.\n\n```ts title=\"Keycloak user data\"\n{\n  sub: '5adba8fc-3ea6-445a-a379-13f0bb0b6969',\n  email_verified: true,\n  name: 'Test User',\n  preferred_username: 'test',\n  given_name: 'Test',\n  family_name: 'User',\n  email: 'test@example.com'\n}\n```\n\nThe fields you receive will depend on the scopes you requested. The default scope is set to `profile` only. If you want to get the user's email, you need to specify the `email` scope in the `configFn` function.\n\n<small>\n  For up-to-date info about the data received from Keycloak, please refer to the [Keycloak API documentation](https://www.keycloak.org/docs-api/23.0.7/javadocs/org/keycloak/representations/UserInfo.html).\n</small>\n\n#### Using the Data Received From Keycloak\n\n<OverrideExampleIntro />\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      keycloak: {\n        // highlight-next-line\n        configFn: import { getConfig } from \"@src/auth/keycloak\",\n        // highlight-next-line\n        userSignupFields: import { userSignupFields } from \"@src/auth/keycloak\"\n      }\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n```prisma title=\"schema.prisma\"\nmodel User {\n  id          Int    @id @default(autoincrement())\n  username    String @unique\n  displayName String\n}\n\n// ...\n```\n\n```ts title=\"src/auth/keycloak.ts\" auto-js\n\nexport const userSignupFields = defineUserSignupFields({\n  username: () => 'hardcoded-username',\n  displayName: (data: any) => data.profile.name,\n})\n\nexport function getConfig() {\n  return {\n    scopes: ['profile', 'email'],\n  }\n}\n```\n\n<GetUserFieldsType />\n\n### Using Auth\n\n<UsingAuthNote />\n\nWhen you receive the `user` object [on the client or the server](../overview.md#accessing-the-logged-in-user), you'll be able to access the user's Keycloak ID like this:\n\n<KeycloakData />\n\n<AccessingUserDataNote />\n\n### API Reference\n\n<ApiReferenceIntro />\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      keycloak: {\n        // highlight-next-line\n        configFn: import { getConfig } from \"@src/auth/keycloak\",\n        // highlight-next-line\n        userSignupFields: import { userSignupFields } from \"@src/auth/keycloak\"\n      }\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\nThe `keycloak` dict has the following properties:\n\n- #### `configFn: ExtImport`\n\n  This function must return an object with the scopes for the OAuth provider.\n\n  ```ts title=\"src/auth/keycloak.ts\" auto-js\n  export function getConfig() {\n    return {\n      scopes: ['profile', 'email'],\n    }\n  }\n  ```\n\n- #### `userSignupFields: ExtImport`\n\n  <UserSignupFieldsExplainer />\n\n  Read more about the `userSignupFields` function [here](../overview#1-defining-extra-fields).\n\n## Slack\n\nWasp supports Slack Authentication out of the box.\n\nUsing Slack Authentication is perfect when you build a control panel for a Slack app.\n\nLet's walk through enabling Slack Authentication, explain some quirks, explore default settings and show how to override them.\n\n### Setting up Slack Auth\n\nEnabling Slack Authentication comes down to a series of steps:\n\n1. Enabling Slack authentication in the Wasp file.\n2. Adding the `User` entity.\n3. Creating Slack App.\n4. Adding the necessary Routes and Pages\n5. Using Auth UI components in our Pages.\n\n<WaspFileStructureNote />\n\n#### 1. Enabling Slack authentication in the Wasp file.\n\nNow let's properly configure the Auth object:\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    // highlight-next-line\n    // 1. Specify the User entity  (we'll define it next)\n    // highlight-next-line\n    userEntity: User,\n    methods: {\n      // highlight-next-line\n      // 2. Enable Slack Auth\n      // highlight-next-line\n      slack: {}\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n#### 2. Add the User Entity\n\nLet's now define the `app.auth.userEntity` entity in the `schema.prisma` file:\n\n```prisma title=\"schema.prisma\"\n// 3. Define the user entity\nmodel User {\n  // highlight-next-line\n  id Int @id @default(autoincrement())\n  // Add your own fields below\n  // ...\n}\n```\n\n#### 3. Creating a Slack App\n\nTo use Slack as an authentication method, you'll first need to create a Slack App and provide Wasp with your client key and secret. Here's how you do it:\n\n1. Log into your Slack account and navigate to: https://api.slack.com/apps.\n2. Select **Create New App**.\n3. Click \"From scratch\"\n3. Enter App Name and select workspace that should host your app.\n\n<img alt=\"Slack Applications Screenshot\" src={useBaseUrl('img/integrations-slack-1.png')} width=\"400px\" />\n\n4. Go to the **OAuth & Permissions** tab on the sidebar and click **Add New Redirect URL**. \n    - Enter the value `https://<subdomain>.local.lt/auth/slack/callback`, where `<subdomain>` is your selected localtunnel subdomain.\n    - Slack requires us to use HTTPS even when developing, [read below](#slack-https) how to set it up.\n\n4. Hit **Save URLs**.\n5. Go to **Basic Information** tab\n6. Hit **Show** next to **Client Secret**\n6. Copy your Client ID and Client Secret as you'll need them in the next step.\n\n:::tip\n\nBe precise with your redirect URL. Slack’s redirect URLs are case-sensitive and sensitive to trailing slashes.\nFor example, `https://your-app.loca.lt/auth/slack/callback` and `https://your-app.loca.lt/auth/slack/callback/` are **not** the same.\n:::\n\n#### 4. Adding Environment Variables\n\nAdd these environment variables to the `.env.server` file at the root of your project (take their values from the previous step):\n\n```bash title=\".env.server\"\nSLACK_CLIENT_ID=your-slack-client-id\nSLACK_CLIENT_SECRET=your-slack-client-secret\n```\n\n#### 5. Adding the Necessary Routes and Pages\n\nLet's define the necessary authentication Routes and Pages.\n\nAdd the following code to your `main.wasp` file:\n\n```wasp title=\"main.wasp\"\n// ...\n\nroute LoginRoute { path: \"/login\", to: LoginPage }\npage LoginPage {\n  component: import { Login } from \"@src/pages/auth\"\n}\n```\n\nWe'll define the React components for these pages in the `src/pages/auth.{jsx,tsx}` file below.\n\n#### 6. Creating the Client Pages\n\n:::info\nWe are using [Tailwind CSS](https://tailwindcss.com/) to style the pages. Read more about how to add it [here](../../project/css-frameworks).\n:::\n\nLet's create a `auth.{jsx,tsx}` file in the `src/pages` folder and add the following to it:\n\n```tsx title=\"src/pages/auth.tsx\" auto-js\n\nexport function Login() {\n  return (\n    <Layout>\n      <LoginForm />\n    </Layout>\n  )\n}\n\n// A layout component to center the content\nexport function Layout({ children }: { children: ReactNode }) {\n  return (\n    <div className=\"h-full w-full bg-white\">\n      <div className=\"flex min-h-[75vh] min-w-full items-center justify-center\">\n        <div className=\"h-full w-full max-w-sm bg-white p-5\">\n          <div>{children}</div>\n        </div>\n      </div>\n    </div>\n  )\n}\n```\n\nWe imported the generated Auth UI components and used them in our pages. Read more about the Auth UI components [here](../../auth/ui).\n\n#### Conclusion\n\nYay, we've successfully set up Slack Auth! 🎉\n\n![Slack Auth](/img/auth/slack.png)\n\nRunning `wasp db migrate-dev` and `wasp start` should now give you a working app with authentication.\nTo see how to protect specific pages (i.e., hide them from non-authenticated users), read the docs on [using auth](../../auth/overview).\n\n### Developing with Slack auth and HTTPS {#slack-https}\n\nUnlike most OAuth providers, Slack **requires HTTPS and publicly accessible URL for the OAuth redirect URL**.\nThis means that we can't simply use `localhost:3001` as a base host for redirect urls. Instead, we need to configure\nWasp server to be publicly available under HTTPS, even in the local development environment.\n\nFortunately, there are quite a few free and convenient tools available to simplify the process, such as\n[localtunnel.me](https://localtunnel.me/) (free) and [ngrok.com](https://ngrok.com) (lots of features,\nbut free tier is limited).\n\n<Collapse title=\"Using localtunnel\">\n\nInstall localtunnel globally with `npm install -g localtunnel`. \n\nStart a tunnel with `lt --port 3001 -s <subdomain>`, where `<subdomain>` is a unique subdomain you would like to have.\n\n:::info Subdomain option\n\nUsually localtunnel will assign you a random subdomain on each start, but you can specify it with the `-s` flag.\nDoing it this way will make it easier to remember the URL and will also make it easier to set up the redirect URL\nin Slack app settings.\n\n:::\n\nAfter starting the tunnel, you will see your tunnel URL in the terminal. Go to that URL to unlock the tunnel by entering your IP address\nin a field that appears on the page the first time you open it in the browser. This is a basic anti-abuse mechanism. If you're not sure\nwhat your IP is, you can find it by running `curl ifconfig.me` or going to [ifconfig.me](https://ifconfig.me).\n\nNow that your server is exposed to the public, we need to configure Wasp to use the new public domain. This needs to be done in two places:\nserver and client configuration.\n\nTo configure client, add this line to your `.env.client` file (create it if doesn't exist):\n```bash title=\".env.client\"\nREACT_APP_API_URL=https://<subdomain>.loca.lt\n```\n\nSimilarly, to configure the server, add this line to your `.env.server`:\n```bash title=\".env.server\"\nWASP_SERVER_URL=https://<subdomain>.loca.lt\n```\n\n</Collapse>\n\n### Default Behaviour\n\nAdd `slack: {}` to the `auth.methods` dictionary to use it with default settings.\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      // highlight-next-line\n      slack: {}\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n<DefaultBehaviour />\n\n### Overrides\n\n<OverrideIntro />\n\n#### Data Received From Slack\n\nWe are using Slack's API and its `/openid.connect.userInfo` endpoint to get the user data.\n\nThe data we receive from Slack on the `/openid.connect.userInfo` endpoint looks something like this:\n\n```json\n{\n    \"ok\": true,\n    \"sub\": \"U0R7JM\",\n    \"https://slack.com/user_id\": \"U0R7JM\",\n    \"https://slack.com/team_id\": \"T0R7GR\",\n    \"email\": \"krane@slack-corp.com\",\n    \"email_verified\": true,\n    \"date_email_verified\": 1622128723,\n    \"name\": \"krane\",\n    \"picture\": \"https://secure.gravatar.com/....png\",\n    \"given_name\": \"Bront\",\n    \"family_name\": \"Labradoodle\",\n    \"locale\": \"en-US\",\n    \"https://slack.com/team_name\": \"kraneflannel\",\n    \"https://slack.com/team_domain\": \"kraneflannel\",\n    \"https://slack.com/user_image_24\": \"...\",\n    \"https://slack.com/user_image_32\": \"...\",\n    \"https://slack.com/user_image_48\": \"...\",\n    \"https://slack.com/user_image_72\": \"...\",\n    \"https://slack.com/user_image_192\": \"...\",\n    \"https://slack.com/user_image_512\": \"...\",\n    \"https://slack.com/team_image_34\": \"...\",\n    \"https://slack.com/team_image_44\": \"...\",\n    \"https://slack.com/team_image_68\": \"...\",\n    \"https://slack.com/team_image_88\": \"...\",\n    \"https://slack.com/team_image_102\": \"...\",\n    \"https://slack.com/team_image_132\": \"...\",\n    \"https://slack.com/team_image_230\": \"...\",\n    \"https://slack.com/team_image_default\": true\n}\n```\n\nThe fields you receive depend on the scopes you request. In the example above, the scope includes `email`, `profile` and `openid`. By default, only `openid` is requested. See below for instructions on how to request additional scopes.\n\n<small>\n  For an up to date info about the data received from Slack, please refer to the [Slack API documentation](https://api.slack.com/methods/openid.connect.userInfo).\n</small>\n\n#### Using the Data Received From Slack\n\n<OverrideExampleIntro />\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      slack: {\n        // highlight-next-line\n        configFn: import { config } from \"@src/auth/slack\",\n        // highlight-next-line\n        userSignupFields: import { userSignupFields } from \"@src/auth/slack\"\n      }\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n```prisma title=\"schema.prisma\"\nmodel User {\n  id          Int    @id @default(autoincrement())\n  username    String @unique\n  avatarUrl   String\n}\n\n// ...\n```\n\n```ts title=\"src/auth/slack.ts\" auto-js\n\nexport function config() {\n  console.log('Inside user-supplied Slack config')\n  return {\n    scopes: [\"openid\", \"email\", \"profile\"],\n  }\n}\n\nexport const userSignupFields = defineUserSignupFields({\n  username: (data: any) => data.profile.name,\n  avatarUrl: (data: any) => data.profile.picture,\n})\n```\n\n<GetUserFieldsType />\n\n### Using Auth\n\n<UsingAuthNote />\n\nWhen you receive the `user` object [on the client or the server](../overview.md#accessing-the-logged-in-user), you'll be able to access the user's Slack ID like this:\n\n<SlackData />\n\n<AccessingUserDataNote />\n\n### API Reference\n\n<ApiReferenceIntro />\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      slack: {\n        // highlight-next-line\n        configFn: import { config } from \"@src/auth/slack\",\n        // highlight-next-line\n        userSignupFields: import { userSignupFields } from \"@src/auth/slack\"\n      }\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\nThe `slack` dict has the following properties:\n\n- #### `configFn: ExtImport`\n\n  This function should return an object with the scopes for the OAuth provider.\n\n  ```ts title=\"src/auth/slack.ts\" auto-js\n  export function getConfig() {\n    return {\n      scopes: [\"openid\", \"email\", \"profile\"],\n    }\n  }\n  ```\n\n- #### `userSignupFields: ExtImport`\n\n  <UserSignupFieldsExplainer />\n\n  Read more about the `userSignupFields` function [here](../overview#1-defining-extra-fields).\n\n## Discord\n\nWasp supports Discord Authentication out of the box.\n\nLetting your users log in using their Discord accounts turns the signup process into a breeze.\n\nLet's walk through enabling Discord Authentication, explain some of the default settings, and show how to override them.\n\n### Setting up Discord Auth\n\nEnabling Discord Authentication comes down to a series of steps:\n\n1. Enabling Discord authentication in the Wasp file.\n2. Adding the `User` entity.\n3. Creating a Discord App.\n4. Adding the necessary Routes and Pages\n5. Using Auth UI components in our Pages.\n\n<WaspFileStructureNote />\n\n#### 1. Adding Discord Auth to Your Wasp File\n\nLet's start by properly configuring the Auth object:\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    // highlight-next-line\n    // 1. Specify the User entity  (we'll define it next)\n    // highlight-next-line\n    userEntity: User,\n    methods: {\n      // highlight-next-line\n      // 2. Enable Discord Auth\n      // highlight-next-line\n      discord: {}\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n#### 2. Add the User Entity\n\nLet's now define the `app.auth.userEntity` entity in the `schema.prisma` file:\n\n```prisma title=\"schema.prisma\"\n// 3. Define the user entity\nmodel User {\n  // highlight-next-line\n  id Int @id @default(autoincrement())\n  // Add your own fields below\n  // ...\n}\n```\n\n#### 3. Creating a Discord App\n\nTo use Discord as an authentication method, you'll first need to create a Discord App and provide Wasp with your client key and secret. Here's how you do it:\n\n1. Log into your Discord account and navigate to: https://discord.com/developers/applications.\n2. Select **New Application**.\n3. Supply required information.\n\n<img alt=\"Discord Applications Screenshot\" src={useBaseUrl('img/integrations-discord-1.png')} width=\"400px\" />\n\n4. Go to the **OAuth2** tab on the sidebar and click **Add Redirect**\n\n- For development, put: `http://localhost:3001/auth/discord/callback`.\n- Once you know on which URL your API server will be deployed, you can create a new app with that URL instead e.g. `https://your-server-url.com/auth/discord/callback`.\n\n4. Hit **Save Changes**.\n5. Hit **Reset Secret**.\n6. Copy your Client ID and Client secret as you'll need them in the",
        "namespace": "xtasker",
        "timestamp": 1754702877608
      },
      {
        "key": "waspfull_ag",
        "value": " next step.\n\n#### 4. Adding Environment Variables\n\nAdd these environment variables to the `.env.server` file at the root of your project (take their values from the previous step):\n\n```bash title=\".env.server\"\nDISCORD_CLIENT_ID=your-discord-client-id\nDISCORD_CLIENT_SECRET=your-discord-client-secret\n```\n\n#### 5. Adding the Necessary Routes and Pages\n\nLet's define the necessary authentication Routes and Pages.\n\nAdd the following code to your `main.wasp` file:\n\n```wasp title=\"main.wasp\"\n// ...\n\nroute LoginRoute { path: \"/login\", to: LoginPage }\npage LoginPage {\n  component: import { Login } from \"@src/pages/auth\"\n}\n```\n\nWe'll define the React components for these pages in the `src/pages/auth.{jsx,tsx}` file below.\n\n#### 6. Creating the Client Pages\n\n:::info\nWe are using [Tailwind CSS](https://tailwindcss.com/) to style the pages. Read more about how to add it [here](../../project/css-frameworks).\n:::\n\nLet's create a `auth.{jsx,tsx}` file in the `src/pages` folder and add the following to it:\n\n```tsx title=\"src/pages/auth.tsx\" auto-js\n\nexport function Login() {\n  return (\n    <Layout>\n      <LoginForm />\n    </Layout>\n  )\n}\n\n// A layout component to center the content\nexport function Layout({ children }: { children: ReactNode }) {\n  return (\n    <div className=\"h-full w-full bg-white\">\n      <div className=\"flex min-h-[75vh] min-w-full items-center justify-center\">\n        <div className=\"h-full w-full max-w-sm bg-white p-5\">\n          <div>{children}</div>\n        </div>\n      </div>\n    </div>\n  )\n}\n```\n\nWe imported the generated Auth UI components and used them in our pages. Read more about the Auth UI components [here](../../auth/ui).\n\n#### Conclusion\n\nYay, we've successfully set up Discord Auth! 🎉\n\n![Discord Auth](/img/auth/discord.png)\n\nRunning `wasp db migrate-dev` and `wasp start` should now give you a working app with authentication.\nTo see how to protect specific pages (i.e., hide them from non-authenticated users), read the docs on [using auth](../../auth/overview).\n\n### Default Behaviour\n\nAdd `discord: {}` to the `auth.methods` dictionary to use it with default settings.\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      // highlight-next-line\n      discord: {}\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n<DefaultBehaviour />\n\n### Overrides\n\n<OverrideIntro />\n\n#### Data Received From Discord\n\nWe are using Discord's API and its `/users/@me` endpoint to get the user data.\n\nThe data we receive from Discord on the `/users/@me` endpoint looks something like this:\n\n```json\n{\n  \"id\": \"80351110224678912\",\n  \"username\": \"Nelly\",\n  \"discriminator\": \"1337\",\n  \"avatar\": \"8342729096ea3675442027381ff50dfe\",\n  \"verified\": true,\n  \"flags\": 64,\n  \"banner\": \"06c16474723fe537c283b8efa61a30c8\",\n  \"accent_color\": 16711680,\n  \"premium_type\": 1,\n  \"public_flags\": 64,\n  \"avatar_decoration_data\": {\n    \"sku_id\": \"1144058844004233369\",\n    \"asset\": \"a_fed43ab12698df65902ba06727e20c0e\"\n  }\n}\n```\n\nThe fields you receive will depend on the scopes you requested. The default scope is set to `identify` only. If you want to get the email, you need to specify the `email` scope in the `configFn` function.\n\n<small>\n  For an up to date info about the data received from Discord, please refer to the [Discord API documentation](https://discord.com/developers/docs/resources/user#user-object-user-structure).\n</small>\n\n#### Using the Data Received From Discord\n\n<OverrideExampleIntro />\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      discord: {\n        // highlight-next-line\n        configFn: import { getConfig } from \"@src/auth/discord\",\n        // highlight-next-line\n        userSignupFields: import { userSignupFields } from \"@src/auth/discord\"\n      }\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\n```prisma title=\"schema.prisma\"\nmodel User {\n  id          Int    @id @default(autoincrement())\n  username    String @unique\n  displayName String\n}\n\n// ...\n```\n\n```ts title=\"src/auth/discord.ts\" auto-js\n\nexport const userSignupFields = defineUserSignupFields({\n  username: (data: any) => data.profile.global_name,\n  avatarUrl: (data: any) => data.profile.avatar,\n})\n\nexport function getConfig() {\n  return {\n    scopes: ['identify'],\n  }\n}\n```\n\n<GetUserFieldsType />\n\n### Using Auth\n\n<UsingAuthNote />\n\nWhen you receive the `user` object [on the client or the server](../overview.md#accessing-the-logged-in-user), you'll be able to access the user's Discord ID like this:\n\n<DiscordData />\n\n<AccessingUserDataNote />\n\n### API Reference\n\n<ApiReferenceIntro />\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      discord: {\n        // highlight-next-line\n        configFn: import { getConfig } from \"@src/auth/discord\",\n        // highlight-next-line\n        userSignupFields: import { userSignupFields } from \"@src/auth/discord\"\n      }\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n```\n\nThe `discord` dict has the following properties:\n\n- #### `configFn: ExtImport`\n\n  This function should return an object with the scopes for the OAuth provider.\n\n  ```ts title=\"src/auth/discord.ts\" auto-js\n  export function getConfig() {\n    return {\n      scopes: [],\n    }\n  }\n  ```\n\n- #### `userSignupFields: ExtImport`\n\n  <UserSignupFieldsExplainer />\n\n  Read more about the `userSignupFields` function [here](../overview#1-defining-extra-fields).\n\n## Create your own UI for Social Auth\n\n[Auth UI](../ui.md) is a common name for all high-level auth forms that come with Wasp.\n\nThese include fully functional auto-generated login and signup forms with working social login buttons.\nIf you're looking for the fastest way to get your auth up and running, that's where you should look.\n\nThe UI helpers described below are lower-level and are useful for creating your custom login links.\n\nWasp provides sign-in buttons and URLs for each of the supported social login providers.\n\n```tsx title=\"src/LoginPage.tsx\" auto-js\n\n  GoogleSignInButton,\n  googleSignInUrl,\n  GitHubSignInButton,\n  githubSignInUrl,\n} from \"wasp/client/auth\";\n\nexport const LoginPage = () => {\n  return (\n    <>\n      <GoogleSignInButton />\n      <GitHubSignInButton />\n      {/* or */}\n      <a href={googleSignInUrl}>Sign in with Google</a>\n      <a href={githubSignInUrl}>Sign in with GitHub</a>\n    </>\n  );\n};\n```\n\n## Accessing User Data\n\nFirst, we'll check out the most practical info: **how to access the user's data in your app**.\n\nThen, we'll dive into the details of the **auth entities** that Wasp creates behind the scenes to store the user's data. For auth each method, Wasp needs to store different information about the user. For example, username for [Username & password](./username-and-pass) auth, email verification status for [Email](./email) auth, and so on.\n\nWe'll also show you how you can use these entities to create a custom signup action.\n\n### Accessing the Auth Fields\n\nWhen you receive the `user` object [on the client or the server](../overview.md#accessing-the-logged-in-user), it will contain all the user fields you defined in the `User` entity in the `schema.prisma` file. In addition to that, it will also contain all the auth-related fields that Wasp stores. This includes things like the `username` or the email verification status. In Wasp, this data is called the `AuthUser` object.\n\n#### `AuthUser` Object Fields\n\nAll the `User` fields you defined will be present at the top level of the `AuthUser` object. The auth-related fields will be on the `identities` object. For each auth method you enable, there will be a separate data object in the `identities` object.\n\nThe `AuthUser` object will change depending on which auth method you have enabled in the Wasp file. For example, if you enabled the email auth and Google auth, it would look something like this:\n\n<Tabs>\n  <TabItem value=\"google\" label=\"User Signed Up with Google\">\n    If the user has only the Google identity, the `AuthUser` object will look like this:\n\n    ```ts\n    const user = {\n      // User data\n      id: 'cluqs9qyh00007cn73apj4hp7',\n      address: 'Some address',\n\n      // Auth methods specific data\n      identities: {\n        email: null,\n        google: {\n          id: '1117XXXX1301972049448',\n        },\n      },\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"email\" label=\"User Signed Up with Email\">\n    If the user has only the email identity, the `AuthUser` object will look like this:\n\n    ```ts\n    const user = {\n      // User data\n      id: 'cluqsex9500017cn7i2hwsg17',\n      address: 'Some address',\n\n      // Auth methods specific data\n      identities: {\n        email: {\n          id: 'user@app.com',\n          isEmailVerified: true,\n          emailVerificationSentAt: '2024-04-08T10:06:02.204Z',\n          passwordResetSentAt: null,\n        },\n        google: null,\n      },\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nIn the examples above, you can see the `identities` object contains the `email` and `google` objects. The `email` object contains the email-related data and the `google` object contains the Google-related data.\n\n:::info Make sure to check if the data exists\n\nBefore accessing some auth method's data, you'll need to check if that data exists for the user and then access it:\n\n```ts\nif (user.identities.google !== null) {\n  const userId = user.identities.google.id\n  // ...\n}\n```\n\nYou need to do this because if a user didn't sign up with some auth method, the data for that auth method will be `null`.\n:::\n\nLet's look at the data for each of the available auth methods:\n\n- [Username & password](../username-and-pass.md) data\n\n  <UsernameData />\n\n- [Email](../email.md) data\n\n  <EmailData />\n\n- [Google](../social-auth/google.md) data\n\n  <GoogleData />\n\n- [GitHub](../social-auth/github.md) data\n\n  <GithubData />\n\n- [Keycloak](../social-auth/keycloak.md) data\n\n  <KeycloakData />\n\n- [Discord](../social-auth/discord.md) data\n\n  <DiscordData />\n\nIf you support multiple auth methods, you'll need to find which identity exists for the user and then access its data:\n\n```ts\nif (user.identities.email !== null) {\n  const email = user.identities.email.id\n  // ...\n} else if (user.identities.google !== null) {\n  const googleId = user.identities.google.id\n  // ...\n}\n```\n\n#### `getFirstProviderUserId` Helper\n\nThe `getFirstProviderUserId` method returns the first user ID that it finds for the user. For example if the user has signed up with email, it will return the email. If the user has signed up with Google, it will return the Google ID.\n\nThis can be useful if you support multiple authentication methods and you need _any_ ID that identifies the user in your app.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/MainPage.jsx\"\n    const MainPage = ({ user }) => {\n      const userId = user.getFirstProviderUserId()\n      // ...\n    }\n    ```\n\n    ```js title=\"src/tasks.js\"\n    export const createTask = async (args, context) => {\n      const userId = context.user.getFirstProviderUserId()\n      // ...\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/MainPage.tsx\"\n    import { type AuthUser } from 'wasp/auth'\n\n    const MainPage = ({ user }: { user: AuthUser }) => {\n      const userId = user.getFirstProviderUserId()\n      // ...\n    }\n    ```\n\n    ```ts title=\"src/tasks.ts\"\n    export const createTask: CreateTask<...>  = async (args, context) => {\n      const userId = context.user.getFirstProviderUserId()\n      // ...\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n<small>\n  \\* Multiple identities per user will be possible in the future and then the `getFirstProviderUserId` method will return the ID of the first identity that it finds without any guarantees about which one it will be.\n</small>\n\n### Including the User with Other Entities\n\nSometimes, you might want to include the user's data when fetching other entities. For example, you might want to include the user's data with the tasks they have created.\n\nWe'll mention the `auth` and the `identities` relations which we will explain in more detail later in the [Entities Explained](#entities-explained) section.\n\n:::caution Be careful about sensitive data\n\nYou'll need to include the `auth` and the `identities` relations to get the full auth data about the user. However, you should keep in mind that the `providerData` field in the `identities` can contain sensitive data like the user's hashed password (in case of email or username auth), so you will likely want to exclude it if you are returning those values to the client.\n\n:::\n\nYou can include the full user's data with other entities using the `include` option in the Prisma queries:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/tasks.js\"\n    export const getAllTasks = async (args, context) => {\n      return context.entities.Task.findMany({\n        orderBy: { id: 'desc' },\n        select: {\n          id: true,\n          title: true,\n          // highlight-next-line\n          user: {\n            include: {\n              // highlight-next-line\n              auth: {\n                include: {\n                  // highlight-next-line\n                  identities: {\n                    // Including only the `providerName` and `providerUserId` fields\n                    select: {\n                      providerName: true,\n                      providerUserId: true,\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      })\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/tasks.ts\"\n    export const getAllTasks = (async (args, context) => {\n      return context.entities.Task.findMany({\n        orderBy: { id: 'desc' },\n        select: {\n          id: true,\n          title: true,\n          // highlight-next-line\n          user: {\n            include: {\n              // highlight-next-line\n              auth: {\n                include: {\n                  // highlight-next-line\n                  identities: {\n                    // Including only the `providerName` and `providerUserId` fields\n                    select: {\n                      providerName: true,\n                      providerUserId: true,\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      })\n    }) satisfies tasks.GetAllQuery<{}, {}>\n    ```\n  </TabItem>\n</Tabs>\n\nIf you have some **piece of the auth data that you want to access frequently** (for example the `username`), it's best to store it at the top level of the `User` entity.\n\nFor example, save the `username` or `email` as a property on the `User` and you'll be able to access it without including the `auth` and `identities` fields. We show an example in the [Defining Extra Fields on the User Entity](../overview.md#1-defining-extra-fields) section of the docs.\n\n#### Getting Auth Data from the User Object\n\nWhen you have the `user` object with the `auth` and `identities` fields, it can be a bit tedious to obtain the auth data (like username or Google ID) from it:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/MainPage.jsx\"\n    function MainPage() {\n      // ...\n      return (\n        <div className=\"tasks\">\n          {tasks.map((task) => (\n            <div key={task.id} className=\"task\">\n              {task.title} by {task.user.auth?.identities[0].providerUserId}\n            </div>\n          ))}\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/MainPage.tsx\"\n    function MainPage() {\n      // ...\n      return (\n        <div className=\"tasks\">\n          {tasks.map((task) => (\n            <div key={task.id} className=\"task\">\n              {task.title} by {task.user.auth?.identities[0].providerUserId}\n            </div>\n          ))}\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nWasp offers a few helper methods to access the user's auth data when you retrieve the `user` like this. They are `getUsername`, `getEmail` and `getFirstProviderUserId`. They can be used both on the client and the server.\n\n##### `getUsername`\n\nIt accepts the `user` object and if the user signed up with the [Username & password](./username-and-pass) auth method, it returns the username or `null` otherwise. The `user` object needs to have the `auth` and the `identities` relations included.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/MainPage.jsx\"\n    import { getUsername } from 'wasp/auth'\n\n    function MainPage() {\n      // ...\n      return (\n        <div className=\"tasks\">\n          {tasks.map((task) => (\n            <div key={task.id} className=\"task\">\n              {task.title} by {getUsername(task.user)}\n            </div>\n          ))}\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/MainPage.tsx\"\n    import { getUsername } from 'wasp/auth'\n\n    function MainPage() {\n      // ...\n      return (\n        <div className=\"tasks\">\n          {tasks.map((task) => (\n            <div key={task.id} className=\"task\">\n              {task.title} by {getUsername(task.user)}\n            </div>\n          ))}\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n##### `getEmail`\n\nIt accepts the `user` object and if the user signed up with the [Email](./email) auth method, it returns the email or `null` otherwise. The `user` object needs to have the `auth` and the `identities` relations included.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/MainPage.jsx\"\n    import { getEmail } from 'wasp/auth'\n\n    function MainPage() {\n      // ...\n      return (\n        <div className=\"tasks\">\n          {tasks.map((task) => (\n            <div key={task.id} className=\"task\">\n              {task.title} by {getEmail(task.user)}\n            </div>\n          ))}\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/MainPage.tsx\"\n    import { getEmail } from 'wasp/auth'\n\n    function MainPage() {\n      // ...\n      return (\n        <div className=\"tasks\">\n          {tasks.map((task) => (\n            <div key={task.id} className=\"task\">\n              {task.title} by {getEmail(task.user)}\n            </div>\n          ))}\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n##### `getFirstProviderUserId`\n\nIt returns the first user ID that it finds for the user. For example if the user has signed up with email, it will return the email. If the user has signed up with Google, it will return the Google ID. The `user` object needs to have the `auth` and the `identities` relations included.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/MainPage.jsx\"\n    import { getFirstProviderUserId } from 'wasp/auth'\n\n    function MainPage() {\n      // ...\n      return (\n        <div className=\"tasks\">\n          {tasks.map((task) => (\n            <div key={task.id} className=\"task\">\n              {task.title} by {getFirstProviderUserId(task.user)}\n            </div>\n          ))}\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/MainPage.tsx\"\n    import { getFirstProviderUserId } from 'wasp/auth'\n\n    function MainPage() {\n      // ...\n      return (\n        <div className=\"tasks\">\n          {tasks.map((task) => (\n            <div key={task.id} className=\"task\">\n              {task.title} by {getFirstProviderUserId(task.user)}\n            </div>\n          ))}\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n### Entities Explained\n\nTo store user's auth information, Wasp does a few things behind the scenes. Wasp takes your `schema.prisma` file and combines it with additional entities to create the final `schema.prisma` file that is used in your app.\n\nIn this section, we will explain which entities are created and how they are connected.\n\n#### User Entity\n\nWhen you want to add authentication to your app, you need to specify the `userEntity` field.\n\nFor example, you might set it to `User`:\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  auth: {\n    // highlight-next-line\n    userEntity: User,\n    // ...\n  },\n}\n```\n\nAnd define the `User` in the `schema.prisma` file:\n\n```prisma title=\"schema.prisma\"\nmodel User {\n  id Int @id @default(autoincrement())\n  // Any other fields you want to store about the user\n}\n```\n\nThe `User` entity is a \"business logic user\" which represents a user of your app.\n\nYou can use this entity to store any information about the user that you want to store. For example, you might want to store the user's name or address.\n\nYou can also use the user entity to define the relations between users and other entities in your app. For example, you might want to define a relation between a user and the tasks that they have created.\n\nYou **own** the user entity and you can modify it as you wish. You can add new fields to it, remove fields from it, or change the type of the fields. You can also add new relations to it or remove existing relations from it.\n\n<ImgWithCaption alt=\"Auth Entities in a Wasp App\" source=\"img/auth-entities/model.png\" caption=\"Auth Entities in a Wasp App\" />\n\nOn the other hand, the `Auth`, `AuthIdentity` and `Session` entities are created behind the scenes and are used to store the user's login credentials. You as the developer don't need to care about this entity most of the time. Wasp **owns** these entities.\n\nIn the case you want to create a custom signup action, you will need to use the `Auth` and `AuthIdentity` entities directly.\n\n#### Example App Model\n\nLet's imagine we created a simple tasks management app:\n\n- The app has email and Google-based auth.\n- Users can create tasks and see the tasks that they have created.\n\nLet's look at how would that look in the database:\n\n<ImgWithCaption alt=\"Example of Auth Entities\" source=\"img/auth-entities/model-example.png\" caption=\"Example of Auth Entities\" />\n\nIf we take a look at an example user in the database, we can see:\n\n- The business logic user, `User` is connected to multiple `Task` entities.\n  - In this example, \"Example User\" has two tasks.\n- The `User` is connected to exactly one `Auth` entity.\n- Each `Auth` entity can have multiple `AuthIdentity` entities.\n  - In this example, the `Auth` entity has two `AuthIdentity` entities: one for the email-based auth and one for the Google-based auth.\n- Each `Auth` entity can have multiple `Session` entities.\n  - In this example, the `Auth` entity has one `Session` entity.\n\n<MultipleIdentitiesWarning />\n\n#### `Auth` Entity Internal!\n\nWasp's internal `Auth` entity is used to connect the business logic user, `User` with the user's login credentials.\n\n```prisma\nmodel Auth {\n  id         String         @id @default(uuid())\n  userId     Int?           @unique\n  // Wasp injects this relation on the User entity as well\n  user       User?          @relation(fields: [userId], references: [id], onDelete: Cascade)\n  identities AuthIdentity[]\n  sessions   Session[]\n}\n```\n\nThe `Auth` fields:\n\n- `id` is a unique identifier of the `Auth` entity.\n- `userId` is a foreign key to the `User` entity.\n  - It is used to connect the `Auth` entity with the business logic user.\n- `user` is a relation to the `User` entity.\n  - This relation is injected on the `User` entity as well.\n- `identities` is a relation to the `AuthIdentity` entity.\n- `sessions` is a relation to the `Session` entity.\n\n#### `AuthIdentity` Entity Internal!\n\nThe `AuthIdentity` entity is used to store the user's login credentials for various authentication methods.\n\n```prisma\nmodel AuthIdentity {\n  providerName   String\n  providerUserId String\n  providerData   String @default(\"{}\")\n  authId         String\n  auth           Auth   @relation(fields: [authId], references: [id], onDelete: Cascade)\n\n  @@id([providerName, providerUserId])\n}\n```\n\nThe `AuthIdentity` fields:\n\n- `providerName` is the name of the authentication provider.\n  - For example, `email` or `google`.\n- `providerUserId` is the user's ID in the authentication provider.\n  - For example, the user's email or Google ID.\n- `providerData` is a JSON string that contains additional data about the user from the authentication provider.\n  - For example, for password based auth, this field contains the user's hashed password.\n  - This field is a `String` and not a `Json` type because [Prisma doesn't support the `Json` type for SQLite](https://github.com/prisma/prisma/issues/3786).\n- `authId` is a foreign key to the `Auth` entity.\n  - It is used to connect the `AuthIdentity` entity with the `Auth` entity.\n- `auth` is a relation to the `Auth` entity.\n\n#### `Session` Entity Internal!\n\nThe `Session` entity is used to store the user's session information. It is used to keep the user logged in between page refreshes.\n\n```prisma\nmodel Session {\n  id        String   @id @unique\n  expiresAt DateTime\n  userId    String\n  auth      Auth     @relation(references: [id], fields: [userId], onDelete: Cascade)\n\n  @@index([userId])\n}\n```\n\nThe `Session` fields:\n\n- `id` is a unique identifier of the `Session` entity.\n- `expiresAt` is the date when the session expires.\n- `userId` is a foreign key to the `Auth` entity.\n  - It is used to connect the `Session` entity with the `Auth` entity.\n- `auth` is a relation to the `Auth` entity.\n\n### Custom Signup Action\n\nLet's take a look at how you can use the `Auth` and `AuthIdentity` entities to create custom login and signup actions. For example, you might want to create a custom signup action that creates a user in your app and also creates a user in a third-party service.\n\n:::info Custom Signup Examples\n\nIn the Advanced section you can see an example for [Email](../advanced/custom-auth-actions.md#email) or [Username and password](../advanced/custom-auth-actions.md#username-and-password) authentication.\n\n:::\n\nBelow is a simplified version of a custom signup action which you probably wouldn't use in your app but it shows you how you can use the `Auth` and `AuthIdentity` entities to create a custom signup action.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    action customSignup {\n      fn: import { signup } from \"@src/auth/signup.js\",\n      entities: [User]\n    }\n    ```\n\n    ```js title=\"src/auth/signup.js\"\n    import {\n      createProviderId,\n      sanitizeAndSerializeProviderData,\n      createUser,\n    } from 'wasp/server/auth'\n\n    export const signup = async (args, { entities: { User } }) => {\n      try {\n        // Provider ID is a combination of the provider name and the provider user ID\n        // And it is used to uniquely identify the user in your app\n        const providerId = createProviderId('username', args.username)\n        // sanitizeAndSerializeProviderData hashes the password and returns a JSON string\n        const providerData = await sanitizeAndSerializeProviderData({\n          hashedPassword: args.password,\n        })\n\n        await createUser(\n          providerId,\n          providerData,\n          // Any additional data you want to store on the User entity\n          {}\n        )\n\n        // This is equivalent to:\n        // await User.create({\n        //   data: {\n        //     auth: {\n        //       create: {\n        //         identities: {\n        //             create: {\n        //                 providerName: 'username',\n        //                 providerUserId: args.username\n        //                 providerData,\n        //             },\n        //         },\n        //       }\n        //     },\n        //   }\n        // })\n      } catch (e) {\n        return {\n          success: false,\n          message: e.message,\n        }\n      }\n\n      // Your custom code after sign-up.\n      // ...\n\n      return {\n        success: true,\n        message: 'User created successfully',\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    action customSignup {\n      fn: import { signup } from \"@src/auth/signup.js\",\n      entities: [User]\n    }\n    ```\n\n    ```ts title=\"src/auth/signup.ts\"\n    import {\n      createProviderId,\n      sanitizeAndSerializeProviderData,\n      createUser,\n    } from 'wasp/server/auth'\n    import type { CustomSignup } from 'wasp/server/operations'\n\n    type CustomSignupInput = {\n      username: string\n      password: string\n    }\n    type CustomSignupOutput = {\n      success: boolean\n      message: string\n    }\n\n    export const signup: CustomSignup<\n      CustomSignupInput,\n      CustomSignupOutput\n    > = async (args, { entities: { User } }) => {\n      try {\n        // Provider ID is a combination of the provider name and the provider user ID\n        // And it is used to uniquely identify the user in your app\n        const providerId = createProviderId('username', args.username)\n        // sanitizeAndSerializeProviderData hashes the password and returns a JSON string\n        const providerData = await sanitizeAndSerializeProviderData<'username'>({\n          hashedPassword: args.password,\n        })\n\n        await createUser(\n          providerId,\n          providerData,\n          // Any additional data you want to store on the User entity\n          {}\n        )\n\n        // This is equivalent to:\n        // await User.create({\n        //   data: {\n        //     auth: {\n        //       create: {\n        //         identities: {\n        //             create: {\n        //                 providerName: 'username',\n        //                 providerUserId: args.username\n        //                 providerData,\n        //             },\n        //         },\n        //       }\n        //     },\n        //   }\n        // })\n      } catch (e) {\n        return {\n          success: false,\n          message: e.message,\n        }\n      }\n\n      // Your custom code after sign-up.\n      // ...\n\n      return {\n        success: true,\n        message: 'User created successfully',\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nYou can use whichever method suits your needs better: either the `createUser` function or Prisma's `User.create` method. The `createUser` function is a bit more convenient to use because it hides some of the complexity. On the other hand, the `User.create` method gives you more control over the data that is stored in the `Auth` and `AuthIdentity` entities.\n\n## Auth Hooks\n\nAuth hooks allow you to \"hook into\" the auth process at various stages and run your custom code. For example, if you want to forbid certain emails from signing up, or if you wish to send a welcome email to the user after they sign up, auth hooks are the way to go.\n\n### Supported hooks\n\nThe following auth hooks are available in Wasp:\n\n- [`onBeforeSignup`](#executing-code-before-the-user-signs-up)\n- [`onAfterSignup`](#executing-code-after-the-user-signs-up)\n- [`onAfterEmailVerified`](#executing-code-after-a-user-verifies-their-email)\n- [`onBeforeOAuthRedirect`](#executing-code-before-the-oauth-redirect)\n- [`onBeforeLogin`](#executing-code-before-the-user-logs-in)\n- [`onAfterLogin`](#executing-code-after-the-user-logs-in)\n\nWe'll go through each of these hooks in detail. But first, let's see how the hooks fit into the auth flows:\n\n<ImgWithCaption source=\"/img/auth-hooks/signup_flow_with_hooks.png\" alt=\"Signup Flow with Hooks\" caption=\"Signup Flow with Hooks\" />\n\n<ImgWithCaption source=\"/img/auth-hooks/login_flow_with_hooks.png\" alt=\"Login Flow with Hooks\" caption=\"Login Flow with Hooks *\" />\n\n<small>\n  \\* When using the OAuth auth providers, the login hooks are both called before the session is created but the session is created quickly afterward, so it shouldn't make any difference in practice.\n</small>\n\nUsers registering with [email](./email.md) must verify it before they can log in. This verification triggers the Email verification flow:\n\n<ImgWithCaption\n  source=\"/img/auth-hooks/email_verification_flow_with_hooks.png\"\n  alt=\"Email Verification Flow with Hooks\"\n  caption=\"Email Verification Flow with Hooks\"\n/>\n\nUsers signing in with [OAuth](./social-auth/overview.md) must authorize access before completing login. This authorization triggers the OAuth consent flow:\n\n<ImgWithCaption source=\"/img/auth-hooks/oauth_flow_with_hooks.png\" alt=\"OAuth Flow with Hooks\" caption=\"OAuth Flow with Hooks\" />\n\n### Using hooks\n\nTo use auth hooks, you must first declare them in the Wasp file:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp\n    app myApp {\n      wasp: {\n        version: \"{latestWaspVersion}\"\n      },\n      auth: {\n        userEntity: User,\n        methods: {\n          ...\n        },\n        onBeforeSignup: import { onBeforeSignup } from \"@src/auth/hooks\",\n        onAfterSignup: import { onAfterSignup } from \"@src/auth/hooks\",\n        onAfterEmailVerified: import { onAfterEmailVerified } from \"@src/auth/hooks\",\n        onBeforeOAuthRedirect: import { onBeforeOAuthRedirect } from \"@src/auth/hooks\",\n        onBeforeLogin: import { onBeforeLogin } from \"@src/auth/hooks\",\n        onAfterLogin: import { onAfterLogin } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp\n    app myApp {\n      wasp: {\n        version: \"{latestWaspVersion}\"\n      },\n      auth: {\n        userEntity: User,\n        methods: {\n          ...\n        },\n        onBeforeSignup: import { onBeforeSignup } from \"@src/auth/hooks\",\n        onAfterSignup: import { onAfterSignup } from \"@src/auth/hooks\",\n        onAfterEmailVerified: import { onAfterEmailVerified } from \"@src/auth/hooks\",\n        onBeforeOAuthRedirect: import { onBeforeOAuthRedirect } from \"@src/auth/hooks\",\n        onBeforeLogin: import { onBeforeLogin } from \"@src/auth/hooks\",\n        onAfterLogin: import { onAfterLogin } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nIf the hooks are defined as async functions, Wasp _awaits_ them. This means the auth process waits for the hooks to finish before continuing.\n\nWasp ignores the hooks' return values. The only exception is the `onBeforeOAuthRedirect` hook, whose return value affects the OAuth redirect URL.\n\nWe'll now go through each of the available hooks.\n\n#### Executing code before the user signs up\n\nWasp calls the `onBeforeSignup` hook before the user is created.\n\nThe `onBeforeSignup` hook can be useful if you want to reject a user based on some criteria before they sign up.\n\nWorks with <EmailPill /> <UsernameAndPasswordPill /> <SlackPill /> <DiscordPill /> <GithubPill /> <GooglePill /> <KeycloakPill />\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      ...\n      auth: {\n        ...\n        onBeforeSignup: import { onBeforeSignup } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n\n    ```js title=\"src/auth/hooks.js\"\n    import { HttpError } from 'wasp/server'\n\n    export const onBeforeSignup = async ({ providerId, prisma, req }) => {\n      const count = await prisma.user.count()\n      console.log('number of users before', count)\n      console.log('provider name', providerId.providerName)\n      console.log('provider user ID', providerId.providerUserId)\n\n      if (count > 100) {\n        throw new HttpError(403, 'Too many users')\n      }\n\n      if (\n        providerId.providerName === 'email' &&\n        providerId.providerUserId === 'some@email.com'\n      ) {\n        throw new HttpError(403, 'This email is not allowed')\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      ...\n      auth: {\n        ...\n        onBeforeSignup: import { onBeforeSignup } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n\n    ```ts title=\"src/auth/hooks.ts\"\n    import { HttpError } from 'wasp/server'\n    import type { OnBeforeSignupHook } from 'wasp/server/auth'\n\n    export const onBeforeSignup: OnBeforeSignupHook = async ({\n      providerId,\n      prisma,\n      req,\n    }) => {\n      const count = await prisma.user.count()\n      console.log('number of users before', count)\n      console.log('provider name', providerId.providerName)\n      console.log('provider user ID', providerId.providerUserId)\n\n      if (count > 100) {\n        throw new HttpError(403, 'Too many users')\n      }\n\n      if (\n        providerId.providerName === 'email' &&\n        providerId.providerUserId === 'some@email.com'\n      ) {\n        throw new HttpError(403, 'This email is not allowed')\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nRead more about the data the `onBeforeSignup` hook receives in the [API Reference](#the-onbeforesignup-hook).\n\n#### Executing code after the user signs up\n\nWasp calls the `onAfterSignup` hook after the user is created.\n\nThe `onAfterSignup` hook can be useful if you want to send the user a welcome email or perform some other action after the user signs up like syncing the user with a third-party service.\n\nSince the `onAfterSignup` hook receives the OAuth tokens, you can use this hook to store the OAuth access token and/or [refresh token](#refreshing-the-oauth-access-token) in your database.\n\nWorks with <EmailPill /> <UsernameAndPasswordPill /> <SlackPill /> <DiscordPill /> <GithubPill /> <GooglePill /> <KeycloakPill />\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      ...\n      auth: {\n        ...\n        onAfterSignup: import { onAfterSignup } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n\n    ```js title=\"src/auth/hooks.js\"\n    export const onAfterSignup = async ({\n      providerId,\n      user,\n      oauth,\n      prisma,\n      req,\n    }) => {\n      const count = await prisma.user.count()\n      console.log('number of users after', count)\n      console.log('user object', user)\n\n      // If this is an OAuth signup, you have access to the OAuth tokens and the uniqueRequestId\n      if (oauth) {\n        console.log('accessToken', oauth.tokens.accessToken)\n        console.log('uniqueRequestId', oauth.uniqueRequestId)\n\n        const id = oauth.uniqueRequestId\n        const data = someKindOfStore.get(id)\n        if (data) {\n          console.log('saved data for the ID', data)\n        }\n        someKindOfStore.delete(id)\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      ...\n      auth: {\n        ...\n        onAfterSignup: import { onAfterSignup } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n\n    ```ts title=\"src/auth/hooks.ts\"\n    import type { OnAfterSignupHook } from 'wasp/server/auth'\n\n    export const onAfterSignup: OnAfterSignupHook = async ({\n      providerId,\n      user,\n      oauth,\n      prisma,\n      req,\n    }) => {\n      const count = await prisma.user.count()\n      console.log('number of users after', count)\n      console.log('user object', user)\n\n      // If this is an OAuth signup, you have access to the OAuth tokens and the uniqueRequestId\n      if (oauth) {\n        console.log('accessToken', oauth.tokens.accessToken)\n        console.log('uniqueRequestId', oauth.uniqueRequestId)\n\n        const id = oauth.uniqueRequestId\n        const data = someKindOfStore.get(id)\n        if (data) {\n          console.log('saved data for the ID', data)\n        }\n        someKindOfStore.delete(id)\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nRead more about the data the `onAfterSignup` hook receives in the [API Reference](#the-onaftersignup-hook).\n\n#### Executing code after a user verifies their email\n\nWasp calls the `onAfterEmailVerified` hook exactly once, after the user verifies their email.\n\nThe `onAfterEmailVerified` hook is useful for triggering actions in response to the verification event — such as sending a welcome email or syncing user data with a third-party service.\n\nThe `onAfterEmailVerified` hook receives an `email` string and `user` object, this makes it easy to perform personalized actions upon email verification.\n\nWorks with <EmailPill />\n\n<Tabs groupId=\"js-ts\">\n<TabItem value=\"js\" label=\"JavaScript\">\n\n```wasp title=\"main.wasp\"\napp myApp {\n  ...\n  auth: {\n    ...\n    onAfterEmailVerified: import { onAfterEmailVerified } from \"@src/auth/hooks\",\n  },\n}\n```\n\n```js title=\"src/auth/hooks.js\"\n\nexport const onAfterEmailVerified = async ({ email }) => {\n  const info = await emailSender.send({\n    from: {\n      name: 'John Doe',\n      email: 'john@doe.com',\n    },\n    to: email,\n    subject: 'Thank you for verifying your email!',\n    text: `Your email ${email} has been successfully verified!`,\n  })\n  // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"ts\" label=\"TypeScript\">\n\n```wasp title=\"main.wasp\"\napp myApp {\n  ...\n  auth: {\n    ...\n    onAfterEmailVerified: import { onAfterEmailVerified } from \"@src/auth/hooks\",\n  },\n}\n```\n\n```ts title=\"src/auth/hooks.ts\"\n\nexport const onAfterEmailVerified: OnAfterEmailVerifiedHook = async ({\n  email,\n}) => {\n  const info = await emailSender.send({\n    from: {\n      name: 'John Doe',\n      email: 'john@doe.com',\n    },\n    to: email,\n    subject: 'Thank you for verifying your email!',\n    text: `Your email ${email} has been successfully verified!`,\n  })\n  // ...\n}\n```\n\n</TabItem>\n</Tabs>\n\nRead more about the data the `onAfterEmailVerified` hook receives in the [API Reference](#the-onafteremailverified-hook).\n\n#### Executing code before the OAuth redirect\n\nWasp calls the `onBeforeOAuthRedirect` hook after the OAuth redirect URL is generated but before redirecting the user. This hook can access the request object sent from the client at the start of the OAuth process.\n\nThe `onBeforeOAuthRedirect` hook can be useful if you want to save some data (e.g. request query parameters) that you can use later in the OAuth flow. You can use the `uniqueRequestId` parameter to reference this data later in the `onAfterSignup` or `onAfterLogin` hooks.\n\nWorks with <DiscordPill /> <GithubPill /> <GooglePill /> <KeycloakPill />\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      ...\n      auth: {\n        ...\n        onBeforeOAuthRedirect: import { onBeforeOAuthRedirect } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n\n    ```js title=\"src/auth/hooks.js\"\n    export const onBeforeOAuthRedirect = async ({ url, oauth, prisma, req }) => {\n      console.log('query params before oAuth redirect', req.query)\n\n      // Saving query params for later use in onAfterSignup or onAfterLogin hooks\n      const id = oauth.uniqueRequestId\n      someKindOfStore.set(id, req.query)\n\n      return { url }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      ...\n      auth: {\n        ...\n        onBeforeOAuthRedirect: import { onBeforeOAuthRedirect } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n\n    ```ts title=\"src/auth/hooks.ts\"\n    import type { OnBeforeOAuthRedirectHook } from 'wasp/server/auth'\n\n    export const onBeforeOAuthRedirect: OnBeforeOAuthRedirectHook = async ({\n      url,\n      oauth,\n      prisma,\n      req,\n    }) => {\n      console.log('query params before oAuth redirect', req.query)\n\n      // Saving query params for later use in onAfterSignup or onAfterLogin hooks\n      const id = oauth.uniqueRequestId\n      someKindOfStore.set(id, req.query)\n\n      return { url }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThis hook's return value must be an object that looks like this: `{ url: URL }`. Wasp uses the URL to redirect the user to the OAuth provider.\n\nRead more about the data the `onBeforeOAuthRedirect` hook receives in the [API Reference](#the-onbeforeoauthredirect-hook).\n\n#### Executing code before the user logs in\n\nWasp calls the `onBeforeLogin` hook before the user is logged in.\n\nThe `onBeforeLogin` hook can be useful if you want to reject a user based on some criteria before they log in.\n\nWorks with <EmailPill /> <UsernameAndPasswordPill /> <SlackPill /> <DiscordPill /> <GithubPill /> <GooglePill /> <KeycloakPill />\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      ...\n      auth: {\n        ...\n        onBeforeLogin: import { onBeforeLogin } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n\n    ```js title=\"src/auth/hooks.js\"\n    import { HttpError } from 'wasp/server'\n\n    export const onBeforeLogin = async ({ providerId, user, prisma, req }) => {\n      if (\n        providerId.providerName === 'email' &&\n        providerId.providerUserId === 'some@email.com'\n      ) {\n        throw new HttpError(403, 'You cannot log in with this email')\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      ...\n      auth: {\n        ...\n        onBeforeLogin: import { onBeforeLogin } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n\n    ```ts title=\"src/auth/hooks.ts\"\n    import { HttpError } from 'wasp/server'\n    import type { OnBeforeLoginHook } from 'wasp/server/auth'\n\n    export const onBeforeLogin: OnBeforeLoginHook = async ({\n      providerId,\n      user,\n      prisma,\n      req,\n    }) => {\n      if (\n        providerId.providerName === 'email' &&\n        providerId.providerUserId === 'some@email.com'\n      ) {\n        throw new HttpError(403, 'You cannot log in with this email')\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nRead more about the data the `onBeforeLogin` hook receives in the [API Reference](#the-onbeforelogin-hook).\n\n#### Executing code after the user logs in\n\nWasp calls the `onAfterLogin` hook after the user logs in.\n\nThe `onAfterLogin` hook can be useful if you want to perform some action after the user logs in, like syncing the user with a third-party service.\n\nSince the `onAfterLogin` hook receives the OAuth tokens, you can use it to update the OAuth access token for the user in your database. You can also use it to [refresh the OAuth access token](#refreshing-the-oauth-access-token) if the provider supports it.\n\nWorks with <EmailPill /> <UsernameAndPasswordPill /> <DiscordPill /> <GithubPill /> <GooglePill /> <KeycloakPill />\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      ...\n      auth: {\n        ...\n        onAfterLogin: import { onAfterLogin } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n\n    ```js title=\"src/auth/hooks.js\"\n    export const onAfterLogin = async ({\n      providerId,\n      user,\n      oauth,\n      prisma,\n      req,\n    }) => {\n      console.log('user object', user)\n\n      // If this is an OAuth signup, you have access to the OAuth tokens and the uniqueRequestId\n      if (oauth) {\n        console.log('accessToken', oauth.tokens.accessToken)\n        console.log('uniqueRequestId', oauth.uniqueRequestId)\n\n        const id = oauth.uniqueRequestId\n        const data = someKindOfStore.get(id)\n        if (data) {\n          console.log('saved data for the ID', data)\n        }\n        someKindOfStore.delete(id)\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      ...\n      auth: {\n        ...\n        onAfterLogin: import { onAfterLogin } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n\n    ```ts title=\"src/auth/hooks.ts\"\n    import type { OnAfterLoginHook } from 'wasp/server/auth'\n\n    export const onAfterLogin: OnAfterLoginHook = async ({\n      providerId,\n      user,\n      oauth,\n      prisma,\n      req,\n    }) => {\n      console.log('user object', user)\n\n      // If this is an OAuth signup, you have access to the OAuth tokens and the uniqueRequestId\n      if (oauth) {\n        console.log('accessToken', oauth.tokens.accessToken)\n        console.log('uniqueRequestId', oauth.uniqueRequestId)\n\n        const id = oauth.uniqueRequestId\n        const data = someKindOfStore.get(id)\n        if (data) {\n          console.log('saved data for the ID', data)\n        }\n        someKindOfStore.delete(id)\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nRead more about the data the `onAfterLogin` hook receives in the [API Reference](#the-onafterlogin-hook).\n\n#### Refreshing the OAuth access token\n\nSome OAuth providers support refreshing the access token when it expires. To refresh the access token, you need the OAuth **refresh token**.\n\nWasp exposes the OAuth refresh token in the `onAfterSignup` and `onAfterLogin` hooks. You can store the refresh token in your database and use it to refresh the access token when it expires.\n\nImport the provider object with the OAuth client from the `wasp/server/auth` module. For example, to refresh the Google OAuth access token, import the `google` object from the `wasp/server/auth` module. You use the `refreshAccessToken` method of the OAuth client to refresh the access token.\n\nHere's an example of how you can refresh the access token for Google OAuth:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/auth/hooks.js\"\n    import { google } from 'wasp/server/auth'\n\n    export const onAfterLogin = async ({ oauth }) => {\n      if (oauth.provider === 'google' && oauth.tokens.refreshToken !== null) {\n        const newTokens = await google.oAuthClient.refreshAccessToken(\n          oauth.tokens.refreshToken\n        )\n        log('new tokens', newTokens)\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/auth/hooks.ts\"\n    import type { OnAfterLoginHook } from 'wasp/server/auth'\n    import { google } from 'wasp/server/auth'\n\n    export const onAfterLogin: OnAfterLoginHook = async ({ oauth }) => {\n      if (oauth.provider === 'google' && oauth.tokens.refreshToken !== null) {\n        const newTokens = await google.oAuthClient.refreshAccessToken(\n          oauth.tokens.refreshToken\n        )\n        log('new tokens', newTokens)\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nGoogle exposes the `accessTokenExpiresAt` field in the `oauth.tokens` object. You can use this field to determine when the access token expires.\n\nIf you want to refresh the token periodically, use a [Wasp Job](../advanced/jobs.md).\n\n### API Reference\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp\n    app myApp {\n      wasp: {\n        version: \"{latestWaspVersion}\"\n      },\n      auth: {\n        userEntity: User,\n        methods: {\n          ...\n        },\n        onBeforeSignup: import { onBeforeSignup } from \"@src/auth/hooks\",\n        onAfterSignup: import { onAfterSignup } from \"@src/auth/hooks\",\n        onAfterEmailVerified: import { onAfterEmailVerified } from \"@src/auth/hooks\",\n        onBeforeOAuthRedirect: import { onBeforeOAuthRedirect } from \"@src/auth/hooks\",\n        onBeforeLogin: import { onBeforeLogin } from \"@src/auth/hooks\",\n        onAfterLogin: import { onAfterLogin } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n  </TabItem>\n\n  <Ta",
        "namespace": "xtasker",
        "timestamp": 1754702882258
      },
      {
        "key": "waspfull_ah",
        "value": "bItem value=\"ts\" label=\"TypeScript\">\n    ```wasp\n    app myApp {\n      wasp: {\n        version: \"{latestWaspVersion}\"\n      },\n      auth: {\n        userEntity: User,\n        methods: {\n          ...\n        },\n        onBeforeSignup: import { onBeforeSignup } from \"@src/auth/hooks\",\n        onAfterSignup: import { onAfterSignup } from \"@src/auth/hooks\",\n        onAfterEmailVerified: import { onAfterEmailVerified } from \"@src/auth/hooks\",\n        onBeforeOAuthRedirect: import { onBeforeOAuthRedirect } from \"@src/auth/hooks\",\n        onBeforeLogin: import { onBeforeLogin } from \"@src/auth/hooks\",\n        onAfterLogin: import { onAfterLogin } from \"@src/auth/hooks\",\n      },\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n#### Common hook input\n\nThe following properties are available in all auth hooks:\n\n- `prisma: PrismaClient`\n\n  The Prisma client instance which you can use to query your database.\n\n- `req: Request`\n\n  The [Express request object](https://expressjs.com/en/api.html#req) from which you can access the request headers, cookies, etc.\n\n#### The `onBeforeSignup` hook\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/auth/hooks.js\"\n    export const onBeforeSignup = async ({ providerId, prisma, req }) => {\n      // Hook code goes here\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/auth/hooks.ts\"\n    import type { OnBeforeSignupHook } from 'wasp/server/auth'\n\n    export const onBeforeSignup: OnBeforeSignupHook = async ({\n      providerId,\n      prisma,\n      req,\n    }) => {\n      // Hook code goes here\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThe hook receives an object as **input** with the following properties:\n\n- [`providerId: ProviderId`](#providerid-fields)\n\n- Plus the [common hook input](#common-hook-input)\n\nWasp ignores this hook's **return value**.\n\n#### The `onAfterSignup` hook\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/auth/hooks.js\"\n    export const onAfterSignup = async ({\n      providerId,\n      user,\n      oauth,\n      prisma,\n      req,\n    }) => {\n      // Hook code goes here\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/auth/hooks.ts\"\n    import type { OnAfterSignupHook } from 'wasp/server/auth'\n\n    export const onAfterSignup: OnAfterSignupHook = async ({\n      providerId,\n      user,\n      oauth,\n      prisma,\n      req,\n    }) => {\n      // Hook code goes here\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThe hook receives an object as **input** with the following properties:\n\n- [`providerId: ProviderId`](#providerid-fields)\n\n- `user: User`\n\n  The user object that was created.\n\n- [`oauth?: OAuthFields`](#oauth-fields)\n\n- Plus the [common hook input](#common-hook-input)\n\nWasp ignores this hook's **return value**.\n\n#### The `onAfterEmailVerified` hook\n\n<Tabs groupId=\"js-ts\">\n<TabItem value=\"js\" label=\"JavaScript\">\n\n```js title=\"src/auth/hooks.js\"\nexport const onAfterEmailVerified = async ({ email, user, prisma, req }) => {\n  // Hook code goes here\n}\n```\n\n</TabItem>\n<TabItem value=\"ts\" label=\"TypeScript\">\n\n```ts title=\"src/auth/hooks.ts\"\n\nexport const onAfterEmailVerified: OnAfterEmailVerifiedHook = async ({\n  email,\n  user,\n  prisma,\n  req,\n}) => {\n  // Hook code goes here\n}\n```\n\n</TabItem>\n</Tabs>\n\nThe hook receives an object as **input** with the following properties:\n\n- `email: string`\n\n  The user's veriried email address.\n\n- `user: User`\n\n  The user who completed email verification.\n\n- Plus the [common hook input](#common-hook-input)\n\nWasp ignores this hook's **return value**.\n\n#### The `onBeforeOAuthRedirect` hook\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/auth/hooks.js\"\n    export const onBeforeOAuthRedirect = async ({ url, oauth, prisma, req }) => {\n      // Hook code goes here\n\n      return { url }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/auth/hooks.ts\"\n    import type { OnBeforeOAuthRedirectHook } from 'wasp/server/auth'\n\n    export const onBeforeOAuthRedirect: OnBeforeOAuthRedirectHook = async ({\n      url,\n      oauth,\n      prisma,\n      req,\n    }) => {\n      // Hook code goes here\n\n      return { url }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThe hook receives an object as **input** with the following properties:\n\n- `url: URL`\n\n  Wasp uses the URL for the OAuth redirect.\n\n- `oauth: { uniqueRequestId: string }`\n\n  The `oauth` object has the following fields:\n\n  - `uniqueRequestId: string`\n\n    The unique request ID for the OAuth flow (you might know it as the `state` parameter in OAuth.)\n\n    You can use the unique request ID to save data (e.g. request query params) that you can later use in the `onAfterSignup` or `onAfterLogin` hooks.\n\n- Plus the [common hook input](#common-hook-input)\n\nThis hook's return value must be an object that looks like this: `{ url: URL }`. Wasp uses the URL to redirect the user to the OAuth provider.\n\n#### The `onBeforeLogin` hook\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/auth/hooks.js\"\n    export const onBeforeLogin = async ({ providerId, prisma, req }) => {\n      // Hook code goes here\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/auth/hooks.ts\"\n    import type { OnBeforeLoginHook } from 'wasp/server/auth'\n\n    export const onBeforeLogin: OnBeforeLoginHook = async ({\n      providerId,\n      prisma,\n      req,\n    }) => {\n      // Hook code goes here\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThe hook receives an object as **input** with the following properties:\n\n- [`providerId: ProviderId`](#providerid-fields)\n\n- `user: User`\n\n  The user that is trying to log in.\n\n- Plus the [common hook input](#common-hook-input)\n\nWasp ignores this hook's **return value**.\n\n#### The `onAfterLogin` hook\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/auth/hooks.js\"\n    export const onAfterLogin = async ({\n      providerId,\n      user,\n      oauth,\n      prisma,\n      req,\n    }) => {\n      // Hook code goes here\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/auth/hooks.ts\"\n    import type { OnAfterLoginHook } from 'wasp/server/auth'\n\n    export const onAfterLogin: OnAfterLoginHook = async ({\n      providerId,\n      user,\n      oauth,\n      prisma,\n      req,\n    }) => {\n      // Hook code goes here\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThe hook receives an object as **input** with the following properties:\n\n- [`providerId: ProviderId`](#providerid-fields)\n\n- `user: User`\n\n  The logged-in user's object.\n\n- [`oauth?: OAuthFields`](#oauth-fields)\n\n- Plus the [common hook input](#common-hook-input)\n\nWasp ignores this hook's **return value**.\n\n#### ProviderId fields\n\nThe `providerId` object represents the user for the current authentication method. Wasp passes it to the `onBeforeSignup`, `onAfterSignup`, `onBeforeLogin`, and `onAfterLogin` hooks.\n\nIt has the following fields:\n\n- `providerName: string`\n\n  The provider's name (e.g. `'email'`, `'google'`, `'github`)\n\n- `providerUserId: string`\n\n  The user's unique ID in the provider's system (e.g. email, Google ID, GitHub ID)\n\n#### OAuth fields\n\nWasp passes the `oauth` object to the `onAfterSignup` and `onAfterLogin` hooks only when the user is authenticated with [Social Auth](./social-auth/overview.md).\n\nIt has the following fields:\n\n- `providerName: string`\n\n  The name of the OAuth provider the user authenticated with (e.g. `'google'`, `'github'`).\n\n- `tokens: Tokens`\n\n  You can use the OAuth tokens to make requests to the provider's API on the user's behalf.\n\n  Depending on the OAuth provider, the `tokens` object might have different fields. For example, Google has the fields `accessToken`, `refreshToken`, `idToken`, and `accessTokenExpiresAt`.\n\n  <ShowForTs>\n    To access the provider-specific fields, you must first narrow down the `oauth.tokens` object type to the specific OAuth provider type.\n\n    ```ts\n    if (oauth && oauth.providerName === 'google') {\n      console.log(oauth.tokens.accessToken)\n      //                  ^ Google specific tokens are available here\n      console.log(oauth.tokens.refreshToken)\n      console.log(oauth.tokens.idToken)\n      console.log(oauth.tokens.accessTokenExpiresAt)\n    }\n    ```\n  </ShowForTs>\n\n- `uniqueRequestId: string`\n\n  The unique request ID for the OAuth flow (you might know it as the `state` parameter in OAuth.)\n\n  You can use the unique request ID to get the data that was saved in the `onBeforeOAuthRedirect` hook.\n\n## custom-auth-actions\n\n## Custom sign-up actions\n\nIf you need to deeply hook into the sign-up process, you can create your own sign-up action and customize the code to, for example, add extra validation, store more data, or otherwise call custom code at registration time.\n\n:::danger\n\nCustom sign-up actions are complex, and we don't recommend creating a custom sign-up action unless you have a good reason to do so.\nThey also require you to be careful, as any small mistake will compromise the security of your app.\n\nBefore using custom actions, check if our support for [custom auth UI](../overview.md#custom-auth-ui) and for [auth hooks](../auth-hooks.md) could fit well with you requirements.\n\n:::\n\nYou are not able to use Wasp UI with custom sign-up actions, so you're expected to implemented your own UI and call the custom actions you create from it.\n\n### Example code\n\nBelow you will find a starting point for creating your own actions. The given implementation is similar to what Wasp does under the hood, and it is up to you to customize it.\n\n#### Email\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    action customSignup {\n      fn: import { signup } from \"@src/auth/signup.js\",\n    }\n    ```\n\n    ```js title=\"src/auth/signup.js\"\n    import { HttpError } from 'wasp/server'\n    import {\n      createEmailVerificationLink,\n      createProviderId,\n      createUser,\n      ensurePasswordIsPresent,\n      ensureValidEmail,\n      ensureValidPassword,\n      findAuthIdentity,\n      getProviderData,\n      sanitizeAndSerializeProviderData,\n      sendEmailVerificationEmail,\n    } from 'wasp/server/auth'\n\n    export const signup = async (args, _context) => {\n      ensureValidEmail(args)\n      ensurePasswordIsPresent(args)\n      ensureValidPassword(args)\n\n      try {\n        const providerId = createProviderId('email', args.email)\n        const existingAuthIdentity = await findAuthIdentity(providerId)\n\n        let providerData\n\n        if (existingAuthIdentity) {\n          // User already exists, handle accordingly\n\n          // For example, throw an error or return a message\n          throw new HttpError(400, 'Email already exists.')\n\n          // Or, another example, you can check if the user is already\n          // verified and re-send the verification email if not\n          providerData = getProviderData(existingAuthIdentity.providerData)\n          if (providerData.isEmailVerified) {\n            throw new HttpError(400, 'Email already verified.')\n          }\n        }\n\n        if (!providerData) {\n          providerData = await sanitizeAndSerializeProviderData({\n            // The provider will hash the password for us, so we don't need to do it here.\n            hashedPassword: args.password,\n            isEmailVerified: false,\n            emailVerificationSentAt: null,\n            passwordResetSentAt: null,\n          })\n          await createUser(\n            providerId,\n            providerData,\n            // Any additional data you want to store on the User entity\n            {}\n          )\n        }\n\n        // Verification link links to a client route e.g. /email-verification\n        const verificationLink = await createEmailVerificationLink(\n          args.email,\n          '/email-verification'\n        )\n        try {\n          await sendEmailVerificationEmail(args.email, {\n            from: {\n              name: 'My App Postman',\n              email: 'hello@itsme.com',\n            },\n            to: args.email,\n            subject: 'Verify your email',\n            text: `Click the link below to verify your email: ${verificationLink}`,\n            html: `\n                          <p>Click the link below to verify your email</p>\n                          <a href=\"${verificationLink}\">Verify email</a>\n                      `,\n          })\n        } catch (e) {\n          console.error('Failed to send email verification email:', e)\n          throw new HttpError(500, 'Failed to send email verification email.')\n        }\n      } catch (e) {\n        return {\n          success: false,\n          message: e.message,\n        }\n      }\n\n      // Your custom code after sign-up.\n      // ...\n\n      return {\n        success: true,\n        message: 'User created successfully',\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    action customSignup {\n      fn: import { signup } from \"@src/auth/signup.js\",\n    }\n    ```\n\n    ```ts title=\"src/auth/signup.ts\"\n    import { HttpError } from 'wasp/server'\n    import {\n      createEmailVerificationLink,\n      createProviderId,\n      createUser,\n      ensurePasswordIsPresent,\n      ensureValidEmail,\n      ensureValidPassword,\n      findAuthIdentity,\n      getProviderData,\n      sanitizeAndSerializeProviderData,\n      sendEmailVerificationEmail,\n    } from 'wasp/server/auth'\n    import type { CustomSignup } from 'wasp/server/operations'\n\n    type CustomSignupInput = {\n      email: string\n      password: string\n    }\n    type CustomSignupOutput = {\n      success: boolean\n      message: string\n    }\n\n    export const signup: CustomSignup<\n      CustomSignupInput,\n      CustomSignupOutput\n    > = async (args, _context) => {\n      ensureValidEmail(args)\n      ensurePasswordIsPresent(args)\n      ensureValidPassword(args)\n\n      try {\n        const providerId = createProviderId('email', args.email)\n        const existingAuthIdentity = await findAuthIdentity(providerId)\n\n        let providerData\n\n        if (existingAuthIdentity) {\n          // User already exists, handle accordingly\n\n          // For example, throw an error or return a message\n          throw new HttpError(400, 'Email already exists.')\n\n          // Or, another example, you can check if the user is already\n          // verified and re-send the verification email if not\n          providerData = getProviderData<'email'>(existingAuthIdentity.providerData)\n          if (providerData.isEmailVerified)\n            throw new HttpError(400, 'Email already verified.')\n        }\n\n        if (!providerData) {\n          providerData = await sanitizeAndSerializeProviderData<'email'>({\n            // The provider will hash the password for us, so we don't need to do it here.\n            hashedPassword: args.password,\n            isEmailVerified: false,\n            emailVerificationSentAt: null,\n            passwordResetSentAt: null,\n          })\n          await createUser(\n            providerId,\n            providerData,\n            // Any additional data you want to store on the User entity\n            {}\n          )\n        }\n\n        // Verification link links to a client route e.g. /email-verification\n        const verificationLink = await createEmailVerificationLink(\n          args.email,\n          '/email-verification'\n        )\n        try {\n          await sendEmailVerificationEmail(args.email, {\n            from: {\n              name: 'My App Postman',\n              email: 'hello@itsme.com',\n            },\n            to: args.email,\n            subject: 'Verify your email',\n            text: `Click the link below to verify your email: ${verificationLink}`,\n            html: `\n                          <p>Click the link below to verify your email</p>\n                          <a href=\"${verificationLink}\">Verify email</a>\n                      `,\n          })\n        } catch (e: unknown) {\n          console.error('Failed to send email verification email:', e)\n          throw new HttpError(500, 'Failed to send email verification email.')\n        }\n      } catch (e: any) {\n        return {\n          success: false,\n          message: e.message,\n        }\n      }\n\n      // Your custom code after sign-up.\n      // ...\n\n      return {\n        success: true,\n        message: 'User created successfully',\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n#### Username and password\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    action customSignup {\n      fn: import { signup } from \"@src/auth/signup.js\",\n    }\n    ```\n\n    ```js title=\"src/auth/signup.js\"\n    import {\n      createProviderId,\n      createUser,\n      ensurePasswordIsPresent,\n      ensureValidPassword,\n      ensureValidUsername,\n      sanitizeAndSerializeProviderData,\n    } from 'wasp/server/auth'\n\n    export const signup = async (args, _context) => {\n      ensureValidUsername(args)\n      ensurePasswordIsPresent(args)\n      ensureValidPassword(args)\n\n      try {\n        const providerId = createProviderId('username', args.username)\n        const providerData = await sanitizeAndSerializeProviderData({\n          // The provider will hash the password for us, so we don't need to do it here.\n          hashedPassword: args.password,\n        })\n\n        await createUser(providerId, providerData, {})\n      } catch (e) {\n        console.error('Error creating user:', e)\n        return {\n          success: false,\n          message: e.message,\n        }\n      }\n\n      return {\n        success: true,\n        message: 'User created successfully',\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    // ...\n\n    action customSignup {\n      fn: import { signup } from \"@src/auth/signup\",\n    }\n    ```\n\n    ```ts title=\"src/auth/signup.ts\"\n    import {\n      createProviderId,\n      createUser,\n      ensurePasswordIsPresent,\n      ensureValidPassword,\n      ensureValidUsername,\n      sanitizeAndSerializeProviderData,\n    } from 'wasp/server/auth'\n    import type { CustomSignup } from 'wasp/server/operations'\n\n    type CustomSignupInput = {\n      username: string\n      password: string\n    }\n    type CustomSignupOutput = {\n      success: boolean\n      message: string\n    }\n\n    export const signup: CustomSignup<\n      CustomSignupInput,\n      CustomSignupOutput\n    > = async (args, _context) => {\n      ensureValidUsername(args)\n      ensurePasswordIsPresent(args)\n      ensureValidPassword(args)\n\n      try {\n        const providerId = createProviderId('username', args.username)\n        const providerData = await sanitizeAndSerializeProviderData<'username'>({\n          // The provider will hash the password for us, so we don't need to do it here.\n          hashedPassword: args.password,\n        })\n\n        await createUser(providerId, providerData, {})\n      } catch (e: any) {\n        console.error('Error creating user:', e)\n        return {\n          success: false,\n          message: e.message,\n        }\n      }\n\n      return {\n        success: true,\n        message: 'User created successfully',\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n### Validators API Reference\n\nWe suggest using the built-in field validators for your authentication flow. You can import them from `wasp/server/auth`. These are the same validators that Wasp uses internally for the default authentication flow.\n\n##### Username\n\n- `ensureValidUsername(args)`\n\n  Checks if the username is valid and throws an error if it's not. Read more about the validation rules [here](../overview.md#default-validations).\n\n##### Email\n\n- `ensureValidEmail(args)`\n\n  Checks if the email is valid and throws an error if it's not. Read more about the validation rules [here](../overview.md#default-validations).\n\n##### Password\n\n- `ensurePasswordIsPresent(args)`\n\n  Checks if the password is present and throws an error if it's not.\n\n- `ensureValidPassword(args)`\n\n  Checks if the password is valid and throws an error if it's not. Read more about the validation rules [here](../overview.md#default-validations).\n\n------\n\n# Project Setup\n\n## Starter Templates\n\nWe created a few starter templates to help you get started with Wasp. Check out the list [below](#available-templates).\n\n### Using a Template\n\nRun `wasp new` to run the interactive mode for creating a new Wasp project.\n\nIt will ask you for the project name, and then for the template to use:\n\n```\n$ wasp new\nEnter the project name (e.g. my-project) ▸ MyFirstProject\nChoose a starter template\n[1] basic (default)\n    Simple starter template with a single page.\n[2] todo-ts\n    Simple but well-rounded Wasp app implemented with Typescript & full-stack type safety.\n[3] saas\n    Everything a SaaS needs! Comes with Auth, ChatGPT API, Tailwind, Stripe payments and more. Check out https://opensaas.sh/ for more details.\n[4] embeddings\n    Comes with code for generating vector embeddings and performing vector similarity search.\n[5] ai-generated\n    🤖 Describe an app in a couple of sentences and have Wasp AI generate initial code for you. (experimental)\n ▸ 1\n\n🐝 --- Creating your project from the \"basic\" template... -------------------------\n\nCreated new Wasp app in ./MyFirstProject directory!\n\nTo run your new app, do:\n    cd MyFirstProject\n    wasp db start\n```\n\n### Available Templates\n\nWhen you have a good idea for a new product, you don't want to waste your time on setting up common things like authentication, database, etc. That's why we created a few starter templates to help you get started with Wasp.\n\n#### OpenSaaS.sh template\n\n![SaaS Template](/img/starter-templates/open-saas-banner.png)\n\nEverything a SaaS needs! Comes with Auth, ChatGPT API, Tailwind, Stripe payments and more. Check out https://opensaas.sh/ for more details.\n\n**Features:** Stripe Payments, OpenAI GPT API, Google Auth, SendGrid, Tailwind, & Cron Jobs\n\nUse this template:\n\n```\nwasp new <project-name> -t saas\n```\n\n#### Vector Similarity Search Template\n\n![Vector Similarity Search Template](/img/starter-templates/embeddings-client.png)\n\nA template for generating embeddings and performing vector similarity search on your text data!\n\n**Features:** Embeddings & vector similarity search, OpenAI Embeddings API, Vector DB (Pinecone), Tailwind, Full-stack Type Safety\n\nUse this template:\n\n```\nwasp new <project-name> -t embeddings\n```\n\n#### Todo App w/ Typescript\n\nA simple Todo App with Typescript and Full-stack Type Safety.\n\n**Features:** Auth (username/password), Full-stack Type Safety\n\nUse this template:\n\n```\nwasp new <project-name> -t todo-ts\n```\n\n#### AI Generated Starter 🤖\n\nUsing the same tech as used on https://usemage.ai/, Wasp generates your custom starter template based on your\nproject description. It will automatically generate your data model, auth, queries, actions and React pages.\n\n_You will need to provide your own OpenAI API key to be able to use this template._\n\n**Features:** Generated using OpenAI's GPT models, Auth (username/password), Queries, Actions, Pages, Full-stack Type Safety\n\n## Customizing the App\n\nEach Wasp project can have only one `app` type declaration. It is used to configure your app and its components.\n\n```wasp\napp todoApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"ToDo App\",\n  head: [\n    \"<link rel=\\\"stylesheet\\\" href=\\\"https://fonts.googleapis.com/css?family=Roboto:300,400,500&display=swap\\\" />\"\n  ]\n}\n```\n\nWe'll go through some common customizations you might want to do to your app. For more details on each of the fields, check out the [API Reference](#api-reference).\n\n#### Changing the App Title\n\nYou may want to change the title of your app, which appears in the browser tab, next to the favicon. You can change it by changing the `title` field of your `app` declaration:\n\n```wasp\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"BookFace\"\n}\n```\n\n#### Adding Additional Lines to the Head\n\nIf you are looking to add additional style sheets or scripts to your app, you can do so by adding them to the `head` field of your `app` declaration.\n\nAn example of adding extra style sheets and scripts:\n\n```wasp\napp myApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"My App\",\n  head: [  // optional\n    \"<link rel=\\\"stylesheet\\\" href=\\\"https://fonts.googleapis.com/css?family=Roboto:300,400,500&display=swap\\\" />\",\n    \"<script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.min.js\\\"></script>\",\n    \"<meta name=\\\"viewport\\\" content=\\\"minimum-scale=1, initial-scale=1, width=device-width\\\" />\"\n  ]\n}\n```\n\n### API Reference\n\n```wasp\napp todoApp {\n  wasp: {\n    version: \"{latestWaspVersion}\"\n  },\n  title: \"ToDo App\",\n  head: [\n    \"<link rel=\\\"stylesheet\\\" href=\\\"https://fonts.googleapis.com/css?family=Roboto:300,400,500&display=swap\\\" />\"\n  ],\n  auth: {\n    // ...\n  },\n  client: {\n    // ...\n  },\n  server: {\n    // ...\n  },\n  db: {\n    // ...\n  },\n  emailSender: {\n    // ...\n  },\n  webSocket: {\n    // ...\n  }\n}\n```\n\nThe `app` declaration has the following fields:\n\n- `wasp: dict` Required!\n  Wasp compiler configuration. It is a dictionary with a single field:\n\n  - `version: string` Required!\n\n    The version specifies which versions of Wasp are compatible with the app. It should contain a valid [SemVer range](https://github.com/npm/node-semver#ranges)\n\n    :::info\n    For now, the version field only supports caret ranges (i.e., `^x.y.z`). Support for the full specification will come in a future version of Wasp\n    :::\n\n- `title: string` Required!\n\n  Title of your app. It will appear in the browser tab, next to the favicon.\n\n- `head: [string]`\n\n  List of additional lines (e.g. `<link>` or `<script>` tags) to be included in the `<head>` of your HTML document.\n\nThe rest of the fields are covered in dedicated sections of the docs:\n\n- `auth: dict`\n\n  Authentication configuration. Read more in the [authentication section](../auth/overview) of the docs.\n\n- `client: dict`\n\n  Configuration for the client side of your app. Read more in the [client configuration section](../project/client-config) of the docs.\n\n- `server: dict`\n\n  Configuration for the server side of your app. Read more in the [server configuration section](../project/server-config) of the docs.\n\n- `db: dict`\n\n  Database configuration. Read more in the [database configuration section](../data-model/databases.md) of the docs.\n\n- `emailSender: dict`\n\n  Email sender configuration. Read more in the [email sending section](../advanced/email) of the docs.\n\n- `webSocket: dict`\n\n  WebSocket configuration. Read more in the [WebSocket section](../advanced/web-sockets) of the docs.\n\n## Client Config\n\nYou can configure the client using the `client` field inside the `app` declaration:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      client: {\n        rootComponent: import Root from \"@src/Root.jsx\",\n        setupFn: import mySetupFunction from \"@src/myClientSetupCode.js\"\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      client: {\n        rootComponent: import Root from \"@src/Root.tsx\",\n        setupFn: import mySetupFunction from \"@src/myClientSetupCode.ts\"\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n### Root Component\n\nWasp gives you the option to define a \"wrapper\" component for your React app.\n\nIt can be used for a variety of purposes, but the most common ones are:\n\n- Defining a common layout for your application.\n- Setting up various providers that your application needs.\n\n#### Defining a Common Layout\n\nLet's define a common layout for your application:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      client: {\n        rootComponent: import Root from \"@src/Root.jsx\",\n      }\n    }\n    ```\n\n    ```jsx title=\"src/Root.jsx\"\n    import { Outlet } from 'react-router-dom'\n\n    export default function Root() {\n      return (\n        <div>\n          <header>\n            <h1>My App</h1>\n          </header>\n          // highlight-next-line\n          <Outlet />\n          <footer>\n            <p>My App footer</p>\n          </footer>\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      client: {\n        rootComponent: import Root from \"@src/Root.tsx\",\n      }\n    }\n    ```\n\n    ```tsx title=\"src/Root.tsx\"\n    import { Outlet } from 'react-router-dom'\n\n    export default function Root() {\n      return (\n        <div>\n          <header>\n            <h1>My App</h1>\n          </header>\n          // highlight-next-line\n          <Outlet />\n          <footer>\n            <p>My App footer</p>\n          </footer>\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nYou need to import the [`Outlet`](https://reactrouter.com/en/main/components/outlet#outlet) component from `react-router-dom` and put it where you want the current page to be rendered.\n\n#### Setting up a Provider\n\nThis is how to set up various providers that your application needs:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      client: {\n        rootComponent: import Root from \"@src/Root.jsx\",\n      }\n    }\n    ```\n\n    ```jsx title=\"src/Root.jsx\"\n    import { Outlet } from 'react-router-dom'\n    import store from './store'\n    import { Provider } from 'react-redux'\n\n    export default function Root() {\n      return (\n        <Provider store={store}>\n          <Outlet />\n        </Provider>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      client: {\n        rootComponent: import Root from \"@src/Root.tsx\",\n      }\n    }\n    ```\n\n    ```tsx title=\"src/Root.tsx\"\n    import { Outlet } from 'react-router-dom'\n    import store from './store'\n    import { Provider } from 'react-redux'\n\n    export default function Root() {\n      return (\n        <Provider store={store}>\n          <Outlet />\n        </Provider>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nAs long as you render the `Outlet` component, you can put what ever you want in the root component.\n\nRead more about the root component in the [API Reference](#rootcomponent-extimport).\n\n### Setup Function\n\n`setupFn` declares a <ShowForTs>Typescript</ShowForTs><ShowForJs>JavaScript</ShowForJs> function that Wasp executes on the client before everything else.\n\n#### Running Some Code\n\nWe can run any code we want in the setup function.\n\nFor example, here's a setup function that logs a message every hour:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/myClientSetupCode.js\"\n    export default async function mySetupFunction() {\n      let count = 1\n      setInterval(\n        () => console.log(`You have been online for ${count++} hours.`),\n        1000 * 60 * 60\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/myClientSetupCode.ts\"\n    export default async function mySetupFunction(): Promise<void> {\n      let count = 1\n      setInterval(\n        () => console.log(`You have been online for ${count++} hours.`),\n        1000 * 60 * 60\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n#### Overriding Default Behaviour for Queries\n\n:::info\nYou can change the options for a **single** Query using the `options` object, as described [here](../data-model/operations/queries#the-usequery-hook-1).\n:::\n\nWasp's `useQuery` hook uses `react-query`'s `useQuery` hook under the hood. Since `react-query` comes configured with aggressive but sane default options, you most likely won't have to change those defaults for all Queries.\n\nIf you do need to change the global defaults, you can do so inside the client setup function.\n\nWasp exposes a `configureQueryClient` hook that lets you configure _react-query_'s `QueryClient` object:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/myClientSetupCode.js\"\n    import { configureQueryClient } from 'wasp/client/operations'\n\n    export default async function mySetupFunction() {\n      // ... some setup\n      configureQueryClient({\n        defaultOptions: {\n          queries: {\n            staleTime: Infinity,\n          },\n        },\n      })\n      // ... some more setup\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/myClientSetupCode.ts\"\n    import { configureQueryClient } from 'wasp/client/operations'\n\n    export default async function mySetupFunction(): Promise<void> {\n      // ... some setup\n      configureQueryClient({\n        defaultOptions: {\n          queries: {\n            staleTime: Infinity,\n          },\n        },\n      })\n      // ... some more setup\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nMake sure to pass in an object expected by the `QueryClient`'s constructor, as\nexplained in\n[react-query's docs](https://tanstack.com/query/v4/docs/reference/QueryClient).\n\nRead more about the setup function in the [API Reference](#setupfn-extimport).\n\n### Base Directory\n\nIf you need to serve the client from a subdirectory, you can use the `baseDir` option:\n\n```wasp title=\"main.wasp\"\napp MyApp {\n  title: \"My app\",\n  // ...\n  client: {\n    baseDir: \"/my-app\",\n  }\n}\n```\n\nThis means that if you serve your app from `https://example.com/my-app`, the\nrouter will work correctly, and all the assets will be served from\n`https://example.com/my-app`.\n\n<BaseDirEnvNote />\n\n### API Reference\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      client: {\n        rootComponent: import Root from \"@src/Root.jsx\",\n        setupFn: import mySetupFunction from \"@src/myClientSetupCode.js\"\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      client: {\n        rootComponent: import Root from \"@src/Root.tsx\",\n        setupFn: import mySetupFunction from \"@src/myClientSetupCode.ts\",\n        baseDir: \"/my-app\",\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nClient has the following options:\n\n- #### `rootComponent: ExtImport`\n\n  `rootComponent` defines the root component of your client application. It is\n  expected to be a React component, and Wasp will use it as the root of the\n  client application.\n  It must render the `Outlet` component from `react-router-dom` to render the\n  current page.\n\n  Here's an example of a root component that both sets up a provider and\n  renders a custom layout:\n\n  <Tabs groupId=\"js-ts\">\n    <TabItem value=\"js\" label=\"JavaScript\">\n      ```jsx title=\"src/Root.jsx\"\n      import { Outlet } from 'react-router-dom'\n      import store from './store'\n      import { Provider } from 'react-redux'\n\n      export default function Root() {\n        return (\n          <Provider store={store}>\n            <Layout />\n          </Provider>\n        )\n      }\n\n      function Layout() {\n        return (\n          <div>\n            <header>\n              <h1>My App</h1>\n            </header>\n            // highlight-next-line\n            <Outlet />\n            <footer>\n              <p>My App footer</p>\n            </footer>\n          </div>\n        )\n      }\n      ```\n    </TabItem>\n\n    <TabItem value=\"ts\" label=\"TypeScript\">\n      ```tsx title=\"src/Root.tsx\"\n      import { Outlet } from 'react-router-dom'\n      import store from './store'\n      import { Provider } from 'react-redux'\n\n      export default function Root() {\n        return (\n          <Provider store={store}>\n            <Layout />\n          </Provider>\n        )\n      }\n\n      function Layout() {\n        return (\n          <div>\n            <header>\n              <h1>My App</h1>\n            </header>\n            // highlight-next-line\n            <Outlet />\n            <footer>\n              <p>My App footer</p>\n            </footer>\n          </div>\n        )\n      }\n      ```\n    </TabItem>\n  </Tabs>\n\n- #### `setupFn: ExtImport`\n\n  <ShowForTs>\n    `setupFn` declares a Typescript function that Wasp executes on the client\n    before everything else. It is expected to be asynchronous, and\n    Wasp will await its completion before rendering the page. The function takes no\n    arguments, and its return value is ignored.\n  </ShowForTs>\n\n  <ShowForJs>\n    `setupFn` declares a JavaScript function that Wasp executes on the client\n    before everything else. It is expected to be asynchronous, and\n    Wasp will await its completion before rendering the page. The function takes no\n    arguments, and its return value is ignored.\n  </ShowForJs>\n\n  You can use this function to perform any custom setup (e.g., setting up\n  client-side periodic jobs).\n\n  <Tabs groupId=\"js-ts\">\n    <TabItem value=\"js\" label=\"JavaScript\">\n      ```js title=\"src/myClientSetupCode.js\"\n      export default async function mySetupFunction() {\n        // Run some code\n      }\n      ```\n    </TabItem>\n\n    <TabItem value=\"ts\" label=\"TypeScript\">\n      ```ts title=\"src/myClientSetupCode.ts\"\n      export default async function mySetupFunction(): Promise<void> {\n        // Run some code\n      }\n      ```\n    </TabItem>\n  </Tabs>\n\n- #### `baseDir: String`\n\n  If you need to serve the client from a subdirectory, you can use the `baseDir` option.\n\n  If you set `baseDir` to `/my-app` for example, that will make Wasp set the `basename` prop of the `Router` to\n  `/my-app`. It will also set the `base` option of the Vite config to `/my-app`.\n\n  This means that if you serve your app from `https://example.com/my-app`, the router will work correctly, and all the assets will be served from `https://example.com/my-app`.\n\n  <BaseDirEnvNote />\n\n## Server Config\n\nYou can configure the behavior of the server via the `server` field of `app` declaration:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      server: {\n        setupFn: import { mySetupFunction } from \"@src/myServerSetupCode.js\",\n        middlewareConfigFn: import { myMiddlewareConfigFn } from \"@src/myServerSetupCode.js\"\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      server: {\n        setupFn: import { mySetupFunction } from \"@src/myServerSetupCode.js\",\n        middlewareConfigFn: import { myMiddlewareConfigFn } from \"@src/myServerSetupCode.js\"\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n### Setup Function\n\n<ShowForTs>\n  `setupFn` declares a Typescript function that will be executed on server start.\n</ShowForTs>\n\n<ShowForJs>\n  `setupFn` declares a Javascript function that will be executed on server start.\n</ShowForJs>\n\n#### Adding a Custom Route\n\nAs an example, adding a custom route would look something like:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/myServerSetupCode.ts\"\n    export const mySetupFunction = async ({ app }) => {\n      addCustomRoute(app)\n    }\n\n    function addCustomRoute(app) {\n      app.get('/customRoute', (_req, res) => {\n        res.send('I am a custom route')\n      })\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/myServerSetupCode.ts\"\n    import { ServerSetupFn } from 'wasp/server'\n    import { Application } from 'express'\n\n    export const mySetupFunction: ServerSetupFn = async ({ app }) => {\n      addCustomRoute(app)\n    }\n\n    function addCustomRoute(app: Application) {\n      app.get('/customRoute', (_req, res) => {\n        res.send('I am a custom route')\n      })\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n#### Storing Some Values for Later Use\n\nIn case you want to store some values for later use, or to be accessed by the [Operations](../data-model/operations/overview) you do that in the `setupFn` function.\n\nDummy example of such function and its usage:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/myServerSetupCode.js\"\n    let someResource = undefined\n\n    export const mySetupFunction = async () => {\n      // Let's pretend functions setUpSomeResource and startSomeCronJob\n      // are implemented below or imported from another file.\n      someResource = await setUpSomeResource()\n      startSomeCronJob()\n    }\n\n    export const getSomeResource = () => someResource\n    ```\n\n    ```js title=\"src/queries.js\"\n    import { getSomeResource } from './myServerSetupCode.js'\n\n    ...\n\n    export const someQuery = async (args, context) => {\n      const someResource = getSomeResource()\n      return queryDataFromSomeResource(args, someResource)\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/myServerSetupCode.ts\"\n    import { type ServerSetupFn } from 'wasp/server'\n\n    let someResource = undefined\n\n    export const mySetupFunction: ServerSetupFn = async () => {\n      // Let's pretend functions setUpSomeResource and startSomeCronJob\n      // are implemented below or imported from another file.\n      someResource = await setUpSomeResource()\n      startSomeCronJob()  \n    }\n\n    export const getSomeResource = () => someResource\n    ```\n\n    ```ts title=\"src/queries.ts\"\n    import { type SomeQuery } from 'wasp/server/operations'\n    import { getSomeResource } from './myServerSetupCode.js'\n\n    ...\n\n    export const someQuery: SomeQuery<...> = async (args, context) => {\n      const someResource = getSomeResource()\n      return queryDataFromSomeResource(args, someResource)\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n:::note\nThe recommended way is to put the variable in the same module where you defined the setup function and then expose additional functions for reading those values, which you can then import directly from Operations and use.\n\nThis effectively turns your module into a singleton whose construction is performed on server start.\n:::\n\nRead more about [server setup function](#setupfn-extimport) below.\n\n### Middleware Config Function\n\nYou can configure the global middleware via the `middlewareConfigFn`. This will modify the middleware stack for all operations and APIs.\n\nRead more about [middleware config function](#middlewareconfigfn-extimport) below.\n\n### API Reference\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      server: {\n        setupFn: import { mySetupFunction } from \"@src/myServerSetupCode.js\",\n        middlewareConfigFn: import { myMiddlewareConfigFn } from \"@src/myServerSetupCode.js\"\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      server: {\n        setupFn: import { mySetupFunction } from \"@src/myServerSetupCode.js\",\n        middlewareConfigFn: import { myMiddlewareConfigFn } from \"@src/myServerSetupCode.js\"\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n`app.server` is a dictionary with the following fields:\n\n- #### `setupFn: ExtImport`\n\n  `setupFn` declares a <ShowForTs>Typescript</ShowForTs><ShowForJs>Javascript</ShowForJs> function that will be executed on server start. This function is expected to be async and will be awaited before the server starts accepting any requests.\n\n  It allows you to do any custom setup, e.g. setting up additional database/websockets or starting cron/scheduled jobs.\n\n  The `setupFn` function receives the `express.Application` and the `http.Server` instances as part of its context. They can be useful for setting up any custom server logic.\n\n  <Tabs groupId=\"js-ts\">\n    <TabItem value=\"js\" label=\"JavaScript\">\n      ```js title=\"src/myServerSetupCode.js\"\n      export const mySetupFunction = async () => {\n        await setUpSomeResource()\n      }\n      ```\n    </TabItem>\n\n    <TabItem value=\"ts\" label=\"TypeScript\">\n      Types for the setup function and its context are as follows:\n\n      ```ts title=\"wasp/server\"\n      export type ServerSetupFn = (context: ServerSetupFnContext) => Promise<void>\n\n      export type ServerSetupFnContext = {\n        app: Application // === express.Application\n        server: Server // === http.Server\n      }\n      ```\n\n      ```ts title=\"src/myServerSetupCode.ts\"\n      import { type ServerSetupFn } from 'wasp/server'\n\n      export const mySetupFunction: ServerSetupFn = async () => {\n        await setUpSomeResource()\n      }\n      ```\n    </TabItem>\n  </Tabs>\n\n- #### `middlewareConfigFn: ExtImport`\n\n  The import statement to an Express middleware config function. This is a global modification affecting all operations and APIs. See more in the [configuring middleware section](../advanced/middleware-config#1-customize-global-middleware).\n\n## Static Asset Handling\n\n### Importing an Asset as URL\n\nImporting a static asset (e.g. an image) will return its URL. For example:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/App.jsx\"\n    import imgUrl from './img.png'\n\n    function App() {\n      return <img src={imgUrl} alt=\"img\" />\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```jsx title=\"src/App.tsx\"\n    import imgUrl from './img.png'\n\n    function App() {\n      return <img src={imgUrl} alt=\"img\" />\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nFor example, `imgUrl` will be `/img.png` during development, and become `/assets/img.2d8efhg.png` in the production build.\n\nThis is what you want to use most of the time, as it ensures that the asset file exists and is included in the bundle.\n\nWe are using Vite under the hood, read more about importing static assets in Vite's [docs](https://vitejs.dev/guide/assets.html#importing-asset-as-url).\n\n### The `public` Directory\n\nIf you have assets that are:\n\n- Never referenced in source code (e.g. robots.txt)\n- Must retain the exact same file name (without hashing)\n- ...or you simply don't want to have to import an asset first just to get its URL\n\nThen you can place the asset in the `public` directory at the root of your project:\n\n```\n.\n└── public\n    ├── favicon.ico\n    └── robots.txt\n```\n\nAssets in this directory will be served at root path `/` during development and copied to the root of the dist directory as-is.\n\nFor example, if you have a file `favicon.ico` in the `public` directory, and your app is hosted at `https://myapp.com`, it will be made available at `https://myapp.com/favicon.ico`.\n\n:::info Usage in client code\nNote that:\n\n- You should always reference public assets using root absolute path\n  - for example, `public/icon.png` should be referenced in source code as `/icon.png`.\n- Assets in the `public` directory **cannot be imported** from <ShowForJs>JavaScript</ShowForJs><ShowForTs>TypeScript</ShowForTs>.\n  :::\n\n## Env Variables\n\n**Environment variables** are used to configure projects based on the context in which they run. This allows them to exhibit different behaviors in different environments, such as development, staging, or production.\n\nFor instance, _during development_, you may want your project to connect to a local development database running on your machine, but _in production_, you want it to connect to the production database. Similarly, in development, you may want to use a test Stripe account, while in production, your app should use a real Stripe account.\n\nWhile some env vars are required by Wasp, such as the database connection or secrets for social auth, you can also define your env vars for any other useful purposes, and then access them in the code.\n\nLet's go over the available env vars in Wasp, how to define them, and how to use them in your project.\n\n### Client Env Vars\n\nClient environment variables are injected into the client Javascript code during the build process, making them public and readable by anyone. Therefore, you should **never store secrets in them** (such as secret API keys, you should store secrets in the server env variables).\n\n<ClientEnvVarsNote />\n\nYou can read them from the client code like this:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/App.js\"\n    import { env } from 'wasp/client'\n\n    console.log(env.REACT_APP_SOME_VAR_NAME)\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/App.ts\"\n    import { env } from 'wasp/client'\n\n    console.log(env.REACT_APP_SOME_VAR_NAME)\n    ```\n  </TabItem>\n</Tabs>\n\nRead more about the `env` object in the [API reference](#client-env-vars-1).\n\n#### Wasp Client Env Vars\n\nHere are the client env vars that Wasp defines:\n\n##### General Configuration {#client-general-configuration}\n\nThese are some general env variables used for various Wasp features:\n\n<EnvVarsTable\n  envVars={[\n{ name: \"REACT_APP_API_URL\", type: \"URL\", isRequired: false, defaultValue: \"http://localhost:3001\", note: \"The client uses this as the server URL.\" }\n]}\n/>\n\n### Server Env Vars\n\nYou can store secret values (e.g. secret API keys) in the server env variables since they are not publicly readable. You can define them without any special prefix, such as `SOME_VAR_NAME=...`.\n\nYou can read the env vars from server code like this:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js\n    import { env } from 'wasp/server'\n\n    console.log(env.SOME_VAR_NAME)\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts\n    import { env } from 'wasp/server'\n\n    console.log(env.SOME_VAR_NAME)\n    ```\n  </TabItem>\n</Tabs>\n\nRead more about the `env` object in the [API reference](#server-env-vars-1).\n\n#### Wasp Server Env Vars\n\n##### General Configuration {#server-general-configuration}\n\nThese are some general env variables used for various Wasp features:\n\n<EnvVarsTable\n  envVars={[\n{ name: \"DATABASE_URL\", type: \"String\", isRequired: true, note: \"The URL of the PostgreSQL database you want your app to use.\" },\n{ name: \"WASP_WEB_CLIENT_URL\", type: \"URL\", isRequired: true, note: \"Server uses this value as your client URL in various features e.g. linking to your app in e-mails.\" },\n{ name: \"WASP_SERVER_URL\", type: \"URL\", isRequired: true, note: \"Server uses this value as your server URL in various features e.g. to redirect users when logging in with OAuth providers like Google or GitHub.\" },\n{ name: \"JWT_SECRET\", type: \"String\", isRequired: true, note: <span>Needed to generate secure tokens. <a href=\"https://jwtsecret.com/generate\" target=\"_blank\" rel=\"noreferrer\">Generate</a> a random string at least 32 characters long.</span> },\n{ name: \"PORT\", type: \"Integer\", isRequired: false, defaultValue: \"3001\", note: \"This is where the server listens for requests.\" }\n]}\n/>\n\n##### SMTP Email Sender\n\nIf you are using `SMTP` as your email sender, y",
        "namespace": "xtasker",
        "timestamp": 1754702886779
      },
      {
        "key": "waspfull_ai",
        "value": "ou need to provide the following environment variables:\n\n<EnvVarsTable\n  envVars={[\n{ name: \"SMTP_HOST\", type: \"String\", isRequired: true, note: \"The SMTP server host.\" },\n{ name: \"SMTP_PORT\", type: \"Integer\", isRequired: true, note: \"The SMTP server port.\" },\n{ name: \"SMTP_USERNAME\", type: \"String\", isRequired: true, note: \"The SMTP server username.\" },\n{ name: \"SMTP_PASSWORD\", type: \"String\", isRequired: true, note: \"The SMTP server password.\" }\n]}\n/>\n\n##### SendGrid Email Sender\n\nIf you are using `SendGrid` as your email sender, you need to provide the following environment variables:\n\n<EnvVarsTable\n  envVars={[\n{ name: \"SENDGRID_API_KEY\", type: \"String\", isRequired: true, note: \"The SendGrid API key.\" }\n]}\n/>\n\n##### Mailgun Email Sender\n\nIf you are using `Mailgun` as your email sender, you need to provide the following environment variables:\n\n<EnvVarsTable\n  envVars={[\n{ name: \"MAILGUN_API_KEY\", type: \"String\", isRequired: true, note: \"The Mailgun API key.\" },\n{ name: \"MAILGUN_DOMAIN\", type: \"String\", isRequired: true, note: \"The Mailgun domain.\" },\n{ name: \"MAILGUN_API_URL\", type: \"URL\", isRequired: false, note: <span>Useful if you want to use the EU API endpoint (<code>https://api.eu.mailgun.net</code>).</span> }\n]}\n/>\n\n##### OAuth Providers\n\nIf you are using OAuth, you need to provide the following environment variables:\n\n<EnvVarsTable\n  envVars={[\n{ name: \"<PROVIDER_NAME>_CLIENT_ID\", type: \"String\", isRequired: true, note: \"The client ID provided by the OAuth provider.\" },\n{ name: \"<PROVIDER_NAME>_CLIENT_SECRET\", type: \"String\", isRequired: true, note: \"The client secret provided by the OAuth provider.\" }\n]}\n/>\n\n<small>\n  \\* `<PROVIDER_NAME>` is the uppercase name of the provider you are using. For example, if you are using Google OAuth, you need to provide the `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET` environment variables.\n</small>\n\nIf you are using [Keycloak](../auth/social-auth/keycloak.md), you'll need to provide one extra environment variable:\n\n<EnvVarsTable\n  envVars={[\n{ name: \"KEYCLOAK_REALM_URL\", type: \"URL\", isRequired: true, note: \"The URL of the Keycloak realm.\" }\n]}\n/>\n\n##### Jobs\n\n<EnvVarsTable\n  envVars={[\n{ name: \"PG_BOSS_NEW_OPTIONS\", type: \"String\", isRequired: false, note: <span>A <a href=\"#json-env-vars\">JSON env var</a>. Enables you to provide <a href=\"../advanced/jobs#pg_boss_new_options\">custom config</a> for PgBoss.</span> }\n]}\n/>\n\n##### Development\n\nWe provide some helper env variables in development:\n\n<EnvVarsTable\n  envVars={[\n{ name: \"SKIP_EMAIL_VERIFICATION_IN_DEV\", type: \"Boolean\", isRequired: false, defaultValue: \"false\", note: \"If set to true, automatically sets user emails as verified in development.\" }\n]}\n/>\n\n### Defining Env Vars in Development\n\nDuring development (`wasp start`), there are two ways to provide env vars to your Wasp project:\n\n1. Using `.env` files. **(recommended)**\n2. Using shell. (useful for overrides)\n\n#### 1. Using .env (dotenv) Files\n\n![Env vars usage in development](/img/env/prod_dev_fade.svg)\n\nThis is the recommended method for providing env vars to your Wasp project during development.\n\nIn the root of your Wasp project you can create two distinct files:\n\n- `.env.server` for env vars that will be provided to the server.\n\nVariables are defined in these files in the form of `NAME=VALUE`, for example:\n\n```shell title=\".env.server\"\nDATABASE_URL=postgresql://localhost:5432\nSOME_VAR_NAME=somevalue\n```\n\n- `.env.client` for env vars that will be provided to the client.\n\n  Variables are defined in these files in the form of `NAME=VALUE`, for example:\n\n  ```shell title=\".env.client\"\n  REACT_APP_SOME_VAR_NAME=somevalue\n  ```\n\n  <ClientEnvVarsNote />\n\n`.env.server` should not be committed to version control as it can contain secrets, while `.env.client` can be versioned as it must not contain any secrets.\nBy default, in the `.gitignore` file that comes with a new Wasp app, we ignore all dotenv files.\n\n#### 2. Using Shell\n\nIf you set environment variables in the shell where you run your Wasp commands (e.g., `wasp start`), Wasp will recognize them.\n\nYou can set environment variables in the `.profile` or a similar file, which will set them permanently, or you can set them temporarily by defining them at the start of a command (`SOME_VAR_NAME=SOMEVALUE wasp start`).\n\nThis is not specific to Wasp and is simply how environment variables can be set in the shell.\n\nDefining environment variables in this way can be cumbersome even for a single project and even more challenging to manage if you have multiple Wasp projects. Therefore, we do not recommend this as a default method for providing environment variables to Wasp projects during development, you should use .env files instead. However, it can be useful for occasionally **overriding** specific environment variables because environment variables set this way **take precedence over those defined in `.env` files**.\n\n### Defining Env Vars in Production\n\nDefining env variables in production will depend on where you are deploying your Wasp project. In general, you will define them via mechanisms that your hosting provider provides.\n\nWe talk about how to define env vars for each deployment option in the [deployment section](../deployment/env-vars.md).\n\n### JSON Env Vars {#json-env-vars}\n\nSome of the environment variables you pass to Wasp are parsed as JSON values. This is useful for features needing more in-depth configuration, but it comes with the caveat of ensuring that the JSON syntax is valid.\n\nThe main issue comes in the form of escaping quotes, and the different ways to do it depending on where you are defining the env var.\n\n##### In `.env` files\n\nIn `.env` files, you don't need to quote the full value, so you don't need to escape the quotes. For example, you can define a JSON object like this:\n\n```shell title=\".env.server\"\nPG_BOSS_NEW_OPTIONS={\"connectionString\":\"...db url...\",\"jobExpirationInSeconds\":60,\"maxRetries\":3}\n```\n\n##### In the shell\n\nIn the shell, you need to quote the full value and escape the quotes inside the JSON object. For example, you can define a JSON object like this:\n\n```shell\nPG_BOSS_NEW_OPTIONS=\"{\\\"connectionString\\\":\\\"...db url...\\\",\\\"jobExpirationInSeconds\\\":60,\\\"maxRetries\\\":3}\"\n```\n\nAs an alternative, you can use single quotes to avoid escaping the quotes inside the JSON object:\n\n```shell\nPG_BOSS_NEW_OPTIONS='{\"connectionString\":\"...db url...\",\"jobExpirationInSeconds\":60,\"maxRetries\":3}'\n```\n\n### Custom Env Var Validations\n\nIf your code requires some environment variables, you usually want to ensure that they are correctly defined. In Wasp, you can define your environment variables validation by defining a [Zod object schema](https://zod.dev/?id=basic-usage) and telling Wasp to use it.\n\n:::info What is Zod?\n\n[Zod](https://zod.dev/) is a library that lets you define what you expect from your data. For example, you can use Zod to define that:\n\n- A value should be a string that's a valid email address.\n- A value should be a number between 0 and 100.\n- ... and much more.\n\n:::\n\nTake a look at an example of defining env vars validation:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/env.js\"\n    import * as z from 'zod'\n\n    import { defineEnvValidationSchema } from 'wasp/env'\n\n    export const serverEnvValidationSchema = defineEnvValidationSchema(\n      z.object({\n        STRIPE_API_KEY: z.string({\n          required_error: 'STRIPE_API_KEY is required.',\n        }),\n      })\n    )\n\n    export const clientEnvValidationSchema = defineEnvValidationSchema(\n      z.object({\n        REACT_APP_NAME: z.string().default('TODO App'),\n      })\n    )\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/env.ts\"\n    import * as z from 'zod'\n\n    import { defineEnvValidationSchema } from 'wasp/env'\n\n    export const serverEnvValidationSchema = defineEnvValidationSchema(\n      z.object({\n        STRIPE_API_KEY: z.string({\n          required_error: 'STRIPE_API_KEY is required.',\n        }),\n      })\n    )\n\n    export const clientEnvValidationSchema = defineEnvValidationSchema(\n      z.object({\n        REACT_APP_NAME: z.string().default('TODO App'),\n      })\n    )\n    ```\n\n    The `defineEnvValidationSchema` function ensures your Zod schema is type-checked.\n  </TabItem>\n</Tabs>\n\n```wasp title=\"main.wasp\"\napp myApp {\n  ...\n  client: {\n    envValidationSchema: import { clientEnvValidationSchema } from \"@src/env\",\n  },\n  server: {\n    envValidationSchema: import { serverEnvValidationSchema } from \"@src/env\",\n  },\n}\n```\n\nYou defined schemas for both the client and the server env vars and told Wasp to use them. Wasp merges your env validation schemas with the built-in env vars validation schemas when it validates the `process.env` object on the server and the `import.meta.env` object on the client.\n\nThis means you can use the `env` object to access **your env vars** like this:\n\n```ts title=\"src/stripe.ts\"\n\nconst stripeApiKey = env.STRIPE_API_KEY\n```\n\nRead more about the env object in the [API Reference](#api-reference).\n\n### API Reference\n\nThere are **Wasp-defined** and **user-defined** env vars. Wasp already comes with built-in validation for Wasp-defined env vars. For your env vars, you can define your own validation.\n\n#### Client Env Vars\n\n##### User-defined env vars validation\n\nYou can define your client env vars validation like this:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/env.js\"\n    import * as z from 'zod'\n\n    import { defineEnvValidationSchema } from 'wasp/env'\n\n    export const envValidationSchema = defineEnvValidationSchema(\n      z.object({\n        REACT_APP_ANALYTICS_ID: z.string({\n          required_error: 'REACT_APP_ANALYTICS_ID is required.',\n        }),\n      })\n    )\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/env.ts\"\n    import * as z from 'zod'\n\n    import { defineEnvValidationSchema } from 'wasp/env'\n\n    export const envValidationSchema = defineEnvValidationSchema(\n      z.object({\n        REACT_APP_ANALYTICS_ID: z.string({\n          required_error: 'REACT_APP_ANALYTICS_ID is required.',\n        }),\n      })\n    )\n    ```\n\n    The `defineEnvValidationSchema` function ensures your Zod schema is type-checked.\n  </TabItem>\n</Tabs>\n\n```wasp title=\"main.wasp\"\napp myApp {\n  ...\n  client: {\n    envValidationSchema: import { envValidationSchema } from \"@src/env\",\n  },\n}\n```\n\nWasp merges your env validation schemas with the built-in env vars validation schemas when it validates the `import.meta.env` object.\n\n##### Accessing env vars in client code\n\nYou can access both **Wasp-defined** and **user-defined** client env vars in your client code using the `env` object:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/App.js\"\n    import { env } from 'wasp/client'\n\n    // Wasp-defined\n    const apiUrl = env.REACT_APP_API_URL\n\n    // User-defined\n    const analyticsId = env.REACT_APP_ANALYTICS_ID\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/App.ts\"\n    import { env } from 'wasp/client'\n\n    // Wasp-defined\n    const apiUrl = env.REACT_APP_API_URL\n\n    // User-defined\n    const analyticsId = env.REACT_APP_ANALYTICS_ID\n    ```\n  </TabItem>\n</Tabs>\n\nYou can use `import.meta.env.REACT_APP_SOME_VAR_NAME` directly in your code. We don't recommend this since `import.meta.env` isn't validated and missing env vars can cause runtime errors.\n\n#### Server Env Vars\n\n##### User-defined env vars validation\n\nYou can define your env vars validation like this:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/env.js\"\n    import * as z from 'zod'\n\n    import { defineEnvValidationSchema } from 'wasp/env'\n\n    export const envValidationSchema = defineEnvValidationSchema(\n      z.object({\n        STRIPE_API_KEY: z.string({\n          required_error: 'STRIPE_API_KEY is required.',\n        }),\n      })\n    )\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/env.ts\"\n    import * as z from 'zod'\n\n    import { defineEnvValidationSchema } from 'wasp/env'\n\n    export const envValidationSchema = defineEnvValidationSchema(\n      z.object({\n        STRIPE_API_KEY: z.string({\n          required_error: 'STRIPE_API_KEY is required.',\n        }),\n      })\n    )\n    ```\n\n    The `defineEnvValidationSchema` function ensures your Zod schema is type-checked.\n  </TabItem>\n</Tabs>\n\n```wasp title=\"main.wasp\"\napp myApp {\n  ...\n  server: {\n    envValidationSchema: import { envValidationSchema } from \"@src/env\",\n  },\n}\n```\n\nWasp merges your env validation schemas with the built-in env vars validation schemas when it validates the `process.env` object.\n\n##### Accessing env vars in server code\n\nYou can access both **Wasp-defined** and **user-defined** client env vars in your client code using the `env` object:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/stripe.js\"\n    import { env } from 'wasp/server'\n\n    // Wasp-defined\n    const serverUrl = env.WASP_SERVER_URL\n\n    // User-defined\n    const stripeApiKey = env.STRIPE_API_KEY\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/stripe.ts\"\n    import { env } from 'wasp/server'\n\n    // Wasp-defined\n    const serverUrl = env.WASP_SERVER_URL\n\n    // User-defined\n    const stripeApiKey = env.STRIPE_API_KEY\n    ```\n  </TabItem>\n</Tabs>\n\nYou can use `process.env.SOME_SECRET` directly in your code. We don't recommend this since `process.env` isn't validated and missing env vars can cause runtime errors.\n\n## Testing\n\n:::info\nWasp is in beta, so keep in mind there might be some kinks / bugs, and possibly some changes with testing support in the future. If you encounter any issues, reach out to us on [Discord](https://discord.gg/rzdnErX) and we will make sure to help you out!\n:::\n\n### Testing Your React App\n\nWasp enables you to quickly and easily write both unit tests and React component tests for your frontend code. Because Wasp uses [Vite](https://vitejs.dev/), we support testing web apps through [Vitest](https://vitest.dev/).\n\n<details>\n  <summary>Included Libraries</summary>\n\n  <div>\n    [`vitest`](https://www.npmjs.com/package/vitest): Unit test framework with native Vite support.\n\n    [`@vitest/ui`](https://www.npmjs.com/package/@vitest/ui): A nice UI for seeing your test results.\n\n    [`jsdom`](https://www.npmjs.com/package/jsdom): A web browser test environment for Node.js.\n\n    [`@testing-library/react`](https://www.npmjs.com/package/@testing-library/react) / [`@testing-library/jest-dom`](https://www.npmjs.com/package/@testing-library/jest-dom): Testing helpers.\n\n    [`msw`](https://www.npmjs.com/package/msw): A server mocking library.\n  </div>\n</details>\n\n#### Writing Tests\n\nFor Wasp to pick up your tests, they should be placed within the `src` directory and use an extension that matches [these glob patterns](https://vitest.dev/config#include). Some of the file names that Wasp will pick up as tests:\n\n- `yourFile.test.ts`\n- `YourComponent.spec.jsx`\n\nWithin test files, you can import your other source files as usual. For example, if you have a component `Counter.jsx`, you test it by creating a file in the same directory called `Counter.test.jsx` and import the component with `import Counter from './Counter'`.\n\n#### Running Tests\n\nRunning `wasp test client` will start Vitest in watch mode and recompile your Wasp project when changes are made.\n\n- If you want to see a real-time UI, pass `--ui` as an option.\n- To run the tests just once, use `wasp test client run`.\n\nAll arguments after `wasp test client` are passed directly to the Vitest CLI, so check out [their documentation](https://vitest.dev/guide/cli.html) for all of the options.\n\n:::warning Be Careful\nYou should not run `wasp test` while `wasp start` is running. Both will try to compile your project to `.wasp/out`.\n:::\n\n#### React Testing Helpers\n\nWasp provides several functions to help you write React tests:\n\n- `renderInContext`: Takes a React component, wraps it inside a `QueryClientProvider` and `Router`, and renders it. This is the function you should use to render components in your React component tests.\n\n  ```js\n  import { renderInContext } from \"wasp/client/test\";\n\n  renderInContext(<MainPage />);\n  ```\n\n- `mockServer`: Sets up the mock server and returns an object containing the `mockQuery` and `mockApi` utilities. This should be called outside of any test case, in each file that wants to use those helpers.\n\n  ```js\n  import { mockServer } from \"wasp/client/test\";\n\n  const { mockQuery, mockApi } = mockServer();\n  ```\n\n  - `mockQuery`: Takes a Wasp [query](../data-model/operations/queries) to mock and the JSON data it should return.\n\n    ```js\n    import { getTasks } from \"wasp/client/operations\";\n\n    mockQuery(getTasks, []);\n    ```\n\n    - Helpful when your component uses `useQuery`.\n    - Behind the scenes, Wasp uses [`msw`](https://npmjs.com/package/msw) to create a server request handle that responds with the specified data.\n    - Mock are cleared between each test.\n\n  - `mockApi`: Similar to `mockQuery`, but for [APIs](../advanced/apis). Instead of a Wasp query, it takes a route containing an HTTP method and a path.\n\n    ```js\n    import { HttpMethod } from \"wasp/client\";\n\n    mockApi({ method: HttpMethod.Get, path: \"/foor/bar\" }, { res: \"hello\" });\n    ```\n\n### Testing Your Server-Side Code\n\nWasp currently does not provide a way to test your server-side code, but we will be adding support soon. You can track the progress at [this GitHub issue](https://github.com/wasp-lang/wasp/issues/110) and express your interest by commenting.\n\n### Examples\n\nYou can see some tests in a Wasp project [here](https://github.com/wasp-lang/wasp/blob/release/waspc/examples/todoApp/src/pages/auth/helpers.test.ts).\n\n#### Client Unit Tests\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/helpers.js\"\n    export function areThereAnyTasks(tasks) {\n      return tasks.length === 0;\n    }\n    ```\n\n    ```js title=\"src/helpers.test.js\"\n    import { test, expect } from \"vitest\";\n\n    import { areThereAnyTasks } from \"./helpers\";\n\n    test(\"areThereAnyTasks\", () => {\n      expect(areThereAnyTasks([])).toBe(false);\n    });\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/helpers.ts\"\n    import { type Task } from \"wasp/entities\";\n\n    export function areThereAnyTasks(tasks: Task[]): boolean {\n      return tasks.length === 0;\n    }\n    ```\n\n    ```ts title=\"src/helpers.test.ts\"\n    import { test, expect } from \"vitest\";\n\n    import { areThereAnyTasks } from \"./helpers\";\n\n    test(\"areThereAnyTasks\", () => {\n      expect(areThereAnyTasks([])).toBe(false);\n    });\n    ```\n  </TabItem>\n</Tabs>\n\n#### React Component Tests\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/Todo.jsx\"\n    import { useQuery, getTasks } from \"wasp/client/operations\";\n\n    const Todo = (_props) => {\n      const { data: tasks } = useQuery(getTasks);\n      return (\n        <ul>\n          {tasks &&\n            tasks.map((task) => (\n              <li key={task.id}>\n                <input type=\"checkbox\" value={task.isDone} />\n                {task.description}\n              </li>\n            ))}\n        </ul>\n      );\n    };\n    ```\n\n    ```js title=\"src/Todo.test.jsx\"\n    import { test, expect } from \"vitest\";\n    import { screen } from \"@testing-library/react\";\n\n    import { mockServer, renderInContext } from \"wasp/client/test\";\n    import { getTasks } from \"wasp/client/operations\";\n    import Todo from \"./Todo\";\n\n    const { mockQuery } = mockServer();\n\n    const mockTasks = [\n      {\n        id: 1,\n        description: \"test todo 1\",\n        isDone: true,\n        userId: 1,\n      },\n    ];\n\n    test(\"handles mock data\", async () => {\n      mockQuery(getTasks, mockTasks);\n\n      renderInContext(<Todo />);\n\n      await screen.findByText(\"test todo 1\");\n\n      expect(screen.getByRole(\"checkbox\")).toBeChecked();\n\n      screen.debug();\n    });\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/Todo.tsx\"\n    import { useQuery, getTasks } from \"wasp/client/operations\";\n\n    const Todo = (_props: {}) => {\n      const { data: tasks } = useQuery(getTasks);\n\n      return (\n        <ul>\n          {tasks &&\n            tasks.map((task) => (\n              <li key={task.id}>\n                <input type=\"checkbox\" value={task.isDone} />\n                {task.description}\n              </li>\n            ))}\n        </ul>\n      );\n    };\n    ```\n\n    ```tsx title=\"src/Todo.test.tsx\"\n    import { test, expect } from \"vitest\";\n    import { screen } from \"@testing-library/react\";\n\n    import { mockServer, renderInContext } from \"wasp/client/test\";\n    import { getTasks } from \"wasp/client/operations\";\n    import Todo from \"./Todo\";\n\n    const { mockQuery } = mockServer();\n\n    const mockTasks = [\n      {\n        id: 1,\n        description: \"test todo 1\",\n        isDone: true,\n        userId: 1,\n      },\n    ];\n\n    test(\"handles mock data\", async () => {\n      mockQuery(getTasks, mockTasks);\n\n      renderInContext(<Todo />);\n\n      await screen.findByText(\"test todo 1\");\n\n      expect(screen.getByRole(\"checkbox\")).toBeChecked();\n\n      screen.debug();\n    });\n    ```\n  </TabItem>\n</Tabs>\n\n#### Testing With Mocked APIs\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```jsx title=\"src/Todo.jsx\"\n    import { api } from \"wasp/client/api\";\n\n    const Todo = (_props) => {\n      const [tasks, setTasks] = useState([]);\n      useEffect(() => {\n        api\n          .get(\"/tasks\")\n          .then((res) => res.json())\n          .then((tasks) => setTasks(tasks))\n          .catch((err) => window.alert(err));\n      });\n\n      return (\n        <ul>\n          {tasks &&\n            tasks.map((task) => (\n              <li key={task.id}>\n                <input type=\"checkbox\" value={task.isDone} />\n                {task.description}\n              </li>\n            ))}\n        </ul>\n      );\n    };\n    ```\n\n    ```jsx title=\"src/Todo.test.jsx\"\n    import { test, expect } from \"vitest\";\n    import { screen } from \"@testing-library/react\";\n\n    import { mockServer, renderInContext } from \"wasp/client/test\";\n    import Todo from \"./Todo\";\n\n    const { mockApi } = mockServer();\n\n    const mockTasks = [\n      {\n        id: 1,\n        description: \"test todo 1\",\n        isDone: true,\n        userId: 1,\n      },\n    ];\n\n    test(\"handles mock data\", async () => {\n      mockApi(\"/tasks\", { res: mockTasks });\n\n      renderInContext(<Todo />);\n\n      await screen.findByText(\"test todo 1\");\n\n      expect(screen.getByRole(\"checkbox\")).toBeChecked();\n\n      screen.debug();\n    });\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```tsx title=\"src/Todo.tsx\"\n    import { type Task } from \"wasp/entities\";\n    import { api } from \"wasp/client/api\";\n\n    const Todo = (_props: {}) => {\n      const [tasks, setTasks] = useState<Task>([]);\n      useEffect(() => {\n        api\n          .get(\"/tasks\")\n          .then((res) => res.json() as Task[])\n          .then((tasks) => setTasks(tasks))\n          .catch((err) => window.alert(err));\n      });\n\n      return (\n        <ul>\n          {tasks &&\n            tasks.map((task) => (\n              <li key={task.id}>\n                <input type=\"checkbox\" value={task.isDone} />\n                {task.description}\n              </li>\n            ))}\n        </ul>\n      );\n    };\n    ```\n\n    ```tsx title=\"src/Todo.test.tsx\"\n    import { test, expect } from \"vitest\";\n    import { screen } from \"@testing-library/react\";\n\n    import { mockServer, renderInContext } from \"wasp/client/test\";\n    import Todo from \"./Todo\";\n\n    const { mockApi } = mockServer();\n\n    const mockTasks = [\n      {\n        id: 1,\n        description: \"test todo 1\",\n        isDone: true,\n        userId: 1,\n      },\n    ];\n\n    test(\"handles mock data\", async () => {\n      mockApi(\"/tasks\", mockTasks);\n\n      renderInContext(<Todo />);\n\n      await screen.findByText(\"test todo 1\");\n\n      expect(screen.getByRole(\"checkbox\")).toBeChecked();\n\n      screen.debug();\n    });\n    ```\n  </TabItem>\n</Tabs>\n\n## Dependencies\n\nIn a Wasp project, dependencies are defined in a standard way for JavaScript projects: using the [package.json](https://docs.npmjs.com/cli/configuring-npm/package-json) file, located at the root of your project. You can list your dependencies under the `dependencies` or `devDependencies` fields.\n\n#### Adding a New Dependency\n\nTo add a new package, like `date-fns` (a great date handling library), you use `npm`:\n\n```bash\nnpm install date-fns\n```\n\nThis command will add the package in the `dependencies` section of your `package.json` file.\n\nYou will notice that there are some other packages in the `dependencies` section, like `react` and `wasp`. These are the packages that Wasp uses internally, and you should not modify or remove them.\n\n#### Using Packages that are Already Used by Wasp Internally\n\nIn the current version of Wasp, if Wasp is already internally using a certain dependency (e.g. React) with a certain version specified, you are not allowed to define that same npm dependency yourself while specifying _a different version_.\n\nIf you do that, you will get an error message telling you which exact version you have to use for that dependency.\nThis means Wasp _dictates exact versions of certain packages_, so for example you can't choose the version of React you want to use.\n\n:::note\n\nWe are currently working on a restructuring that will solve this and some other quirks: check [issue #1644](https://github.com/wasp-lang/wasp/issues/1644) to follow our progress.\n\n:::\n\n## CSS Frameworks\n\n### Tailwind\n\nWasp works great with [Tailwind CSS](https://v3.tailwindcss.com/), a utility-first CSS framework. Currently, Wasp supports Tailwind CSS v3, but we are [working on supporting v4](https://github.com/wasp-lang/wasp/issues/2483) as well. You can use Tailwind CSS in your Wasp project by following the steps below.\n\n#### Adding Tailwind to your Wasp project\n\n:::caution\nMake sure to use the `.cjs` extension for the Tailwind CSS and PostCSS config files, if you name them with a `.js` extension, Wasp will not detect them.\n:::\n\n1. Install Tailwind as a development dependency.\n\n```bash\nnpm install -D tailwindcss@3.2.7\n```\n\n2. Add `./tailwind.config.cjs`.\n\n```js title=\"./tailwind.config.cjs\"\nconst { resolveProjectPath } = require('wasp/dev')\n\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [resolveProjectPath('./src/**/*.{js,jsx,ts,tsx}')],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n\n:::note The `resolveProjectPath` function\n\nBecause Wasp copies the configuration files to the generated project, you must wrap any paths in the `content` array with the `resolveProjectPath` function. This function resolves the path to the generated project, so that Tailwind can find your source files.\n\n:::\n\n3. Add `./postcss.config.cjs`.\n\n```js title=\"./postcss.config.cjs\"\nmodule.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n```\n\n4. Import Tailwind into your CSS file. For example, in a new project you might import Tailwind into `Main.css`.\n\n```css title=\"./src/Main.css\" {1-3}\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n/* ... */\n```\n\n5. Start using Tailwind 🥳\n\n```jsx title=\"./src/MainPage.jsx\"\n// ...\n\n<h1 className=\"text-3xl font-bold underline\">\n  Hello world!\n</h1>\n\n// ...\n```\n\n#### Adding Tailwind Plugins\n\nTo add Tailwind plugins, install them as npm development [dependencies](../project/dependencies) and add them to the plugins list in your `tailwind.config.cjs` file:\n\n```shell\nnpm install -D @tailwindcss/forms\nnpm install -D @tailwindcss/typography\n```\n\nand also\n\n```js title=\"./tailwind.config.cjs\" {5-6}\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  // ...\n  plugins: [\n    require('@tailwindcss/forms'),\n    require('@tailwindcss/typography'),\n  ],\n  // ...\n}\n```\n\n## Custom Vite Config\n\nWasp uses [Vite](https://vitejs.dev/) to serve the client during development and bundling it for production. If you want to customize the Vite config, you can do that by editing the `vite.config.{js,ts}` file in your project root directory.\n\nWasp will use your config and **merge** it with the default Wasp's Vite config.\n\nVite config customization can be useful for things like:\n\n- Adding custom Vite plugins.\n- Customising the dev server.\n- Customising the build process.\n\nBe careful with making changes to the Vite config, as it can break the Wasp's client build process. Check out the default Vite config [here](https://github.com/wasp-lang/wasp/blob/release/waspc/data/Generator/templates/react-app/vite.config.ts) to see what you can change.\n\n### Examples\n\nBelow are some examples of how you can customize the Vite config.\n\n#### Changing the Dev Server Behaviour\n\nIf you want to stop Vite from opening the browser automatically when you run `wasp start`, you can do that by customizing the `open` option.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"vite.config.js\"\n    export default {\n      server: {\n        open: false,\n      },\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"vite.config.ts\"\n    import { defineConfig } from 'vite'\n\n    export default defineConfig({\n      server: {\n        open: false,\n      },\n    })\n    ```\n  </TabItem>\n</Tabs>\n\n#### Custom Dev Server Port\n\nYou have access to all of the [Vite dev server options](https://vitejs.dev/config/server-options.html) in your custom Vite config. You can change the dev server port by setting the `port` option.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"vite.config.js\"\n    export default {\n      server: {\n        port: 4000,\n      },\n    }\n    ```\n\n    ```env title=\".env.server\"\n    WASP_WEB_CLIENT_URL=http://localhost:4000\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"vite.config.ts\"\n    import { defineConfig } from 'vite'\n\n    export default defineConfig({\n      server: {\n        port: 4000,\n      },\n    })\n    ```\n\n    ```env title=\".env.server\"\n    WASP_WEB_CLIENT_URL=http://localhost:4000\n    ```\n  </TabItem>\n</Tabs>\n\n:::warning Changing the dev server port\n⚠️ Be careful when changing the dev server port, you'll need to update the `WASP_WEB_CLIENT_URL` env var in your `.env.server` file.\n:::\n\n#### Customising the Base Path\n\nIf you, for example, want to serve the client from a different path than `/`, you can do that by customizing the `base` option.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"vite.config.js\"\n    export default {\n      base: '/my-app/',\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"vite.config.ts\"\n    import { defineConfig } from 'vite'\n\n    export default defineConfig({\n      base: '/my-app/',\n    })\n    ```\n  </TabItem>\n</Tabs>\n\n------\n\n# Deployment\n\n## Introduction\n\nAfter developing your app locally on your machine, the next step is to deploy it to the web so that others can access it.\n\nIn this section, we'll walk you through the steps to deploy your Wasp app.\n\n#### Wasp app structure\n\nBefore we start, let's understand what Wasp generates when it builds your app.\n\nWhat we call a \"Wasp app\" consists of three different parts:\n\n- **Client app**\n  - It's a single-page application (SPA), built using [React](https://react.dev/). It's what the user sees and interacts with.\n  - It's usually served by some static file server or you can host it on a CDN like Cloudflare or Netlify.\n\n- **Server app**:\n  - The backend of your app, built using [Express](https://expressjs.com/) on Node.js.\n  - It handles requests from the client app, interacts with the database, and returns responses.\n  - It comes with a ready-to-use `Dockerfile` so you can easily package it and deploy it anywhere where Docker is supported.\n\n- **Database**:\n  - Wasp uses [PostgreSQL](https://www.postgresql.org/) as its production database.\n  - You can host the database on your own server or use a cloud service.\n\n<ImgWithCaption source=\"/img/deploying/wasp-app-flow.gif\" alt=\"Wasp app structure\" caption=\"Data flow in a typical deployed Wasp app where all three parts are deployed separately\" />\n\nThe thing to take away from this: the client app and server app are separate applications that communicate with each other over HTTP. This means you can deploy them on the same or different servers, depending on your needs.\n\nWe'll show you different ways of how deploy your app in the [deployment methods](./deployment-methods/overview.md) section.\n\nServer needs to be able to communicate with the database, we'll show you how to set that up using [env variables](./env-vars.md).\n\n#### Deploying your app\n\nIn the following sections, we'll go through all the different things you need to know about deployment:\n\n- How [env variables](./env-vars.md) work in production - they are different than using .env files in development.\n- Production [database setup](./database.md) - how migrations work, how to connect to the database, etc.\n- Different deployment methods (using [Wasp's CLI](./deployment-methods/cli.md), [cloud services](./deployment-methods/paas.md), [self-hosting](./deployment-methods/self-hosted.md), etc.)\n- How to [set up CI/CD](./ci-cd.md) for your app - automatically deploy your app when you push to your Git repository.\n- Some [extras](./extras.md) like custom domains, CDN, etc.\n\n## Env Variables\n\nWe talked about environment variables in the [project setup section](../project/env-vars.md). If you haven't read it, make sure to check it out first. In this section, we'll talk about environment variables in the context of deploying the app.\n\nWhile developing our app on our machine, we had the option of using `.env.client` and `.env.server` files which made it easy to define and manage env vars.\n\nHowever, when we are deploying our app, **`.env.client` and `.env.server` files will be ignored, and we need to provide env vars differently.**\n\n![Env vars usage in development and production](/img/env/prod_dev_fade_2.svg)\n\n#### Client Env Vars\n\nDuring the build process, client env vars are injected into the client Javascript code, making them public and readable by anyone. Therefore, you should **never store secrets in them** (such as secret API keys).\n\nWhen building for production, the `.env.client` file will be ignored, since it is meant to be used only during development.\nInstead, you should provide the production client env vars directly to the build command that turns client code into static files:\n\n```shell\nREACT_APP_API_URL=<url_to_wasp_backend> REACT_APP_SOME_OTHER_VAR_NAME=someothervalue npm run build\n```\n\nAlso, notice **that you can't and shouldn't provide client env vars to the client code by setting them on the hosting provider** (unlike providing server env vars to the server app, in that case this is how you should do it). Your client code will ignore those, as at that point client code is just static files.\n\n:::info How it works\nWhat happens behind the scenes is that Wasp will replace all occurrences of `import.meta.env.REACT_APP_SOME_VAR_NAME` in your client code with the env var value you provided. This is done during the build process, so the value is injected into the static files produced from the client code.\n\nRead more about it in Vite's [docs](https://vitejs.dev/guide/env-and-mode.html#production-replacement).\n:::\n\n#### Server Env Vars\n\nWhen building your Wasp app for production `.env.server` will be ignored, since it is meant to be used only during development.\n\nYou can provide production env vars to your server code in production by defining them and making them available on the server where your server code is running.\n\n::::caution Set the required env vars\n\nMake sure to go through [all the required server env vars](../project/env-vars.md#server-general-configuration) like `DATABASE_URL`, `WASP_WEB_CLIENT_URL` etc. and set them up in your production environment.\n\n**If you are using the [Wasp CLI](./deployment-methods/cli.md)** deployment method, Wasp will set the general configuration env vars for you, but you will need to set the rest of the env vars yourself (like the ones for OAuth auth methods or any other custom env vars you might have defined).\n::::\n\nSetting server env variables up will highly depend on where you are deploying your server, but in general it comes down to defining the env vars via mechanisms that your hosting provider provides.\n\nFor example, if you deploy your server to [Fly](https://fly.io), you can define them using the `fly` CLI tool:\n\n```shell\nfly secrets set SOME_VAR_NAME=somevalue\n```\n\nWe talk about specific providers in the [PaaS deployment section](./deployment-methods/paas.md) or the [self-hosted deployment section](./deployment-methods/self-hosted.md).\n\n## Database\n\nIn this section, we'll discuss what happens with the database when your app goes live. When you develop your app locally, you probably use a local dev database (started with `wasp start db` or some other way). However, when it's time to deploy your app, you'll need to set up a production database.\n\n#### Production database requirements\n\nThe server app that Wasp generates uses a PostgreSQL database. The only requirement from Wasp's point of view is that the database is accessible from the server via the `DATABASE_URL` server env variable.\n\nIt can be a PostgreSQL database running on the same server as the server app, or it can be a managed PostgreSQL database service like [Fly Postgres](https://fly.io/docs/postgres/), [AWS RDS](https://aws.amazon.com/rds/), or some other service.\n\n### Migrations\n\nEvery time you make a change in your [Prisma schema](../data-model/prisma-file.md) e.g. adding a new model, changing a field type, etc., you need to create a migration. Migrations are some code that describes the change you made in the schema, and they are used to apply the change to the database.\n\nThe benefit of migrations is that you can apply the same change to multiple databases. If there are multiple people working on the project, they can all apply the same changes to their local databases. When you deploy the app to production, the same chaanges are applied to the production database.\n\n#### Creating migrations\n\nAfter you made a change in the Prisma schema, you can create a migration by running the following command:\n\n```bash\nwasp db migrate-dev\n```\n\nThis command will create a new migration in the `migrations` directory. The migration is a set of SQL commands that describe the change you made in the schema.\n\n#### Applying migrations\n\n**In development**, the migrations are applied as soon as you run the `wasp start` command.\n\n**In production**, the server app first checks if there are any new migrations that need to be applied, and if there are, it applies them before starting the server. This way, the database schema is always in sync with the Prisma schema.\n\n:::note How it works\n\nIn the built server app, there are two npm scripts: `start` and `start-production`. The `start` script is used in development, and the `start-production` script is used in production. The `start-production` script first applies any pending migrations before starting the server.\n\n:::\n\nThe migrations might fail to apply if there is a conflict with the existing data in the database. In that case, you'll need to fix the migration and try again.\n\n#### Debugging failed migrations\n\nIf a migration fails to apply, the server app will log the error message and stop. You should then connect to the production database and see what went wrong. If you check the `_prisma_migrations` table, you'll see the failed migration there.\n\nYou can try resolving the erorr e.g. if you tried adding a `@unique` constraint to a field that already has duplicate values:\n\n1. Remove any duplicate values from the database\n2. Remove the failed migration from the `_prisma_migrations` table\n3. Try applying the migration again by restarting the server app\n\n:::tip Viewing the `_prisma_migrations` table\n\nYou can't use the `wasp db studio` command to view the `_prisma_migrations` table in the production database, but you can use a database management tool like [DBeaver](https://dbeaver.io/) or [pgAdmin](https://www.pgadmin.org/).\n:::\n\n### Connect to the production database\n\n**In development**, you can use the `wasp db studio` command to open a web-based database management tool that allows you to inspect the database.\n\nYou can use the same tool to inspect the **production database**, but you'll need to set the `DATABASE_URL` env variable to point to the production database. Set the `DATABASE_URL` env variable in your terminal before running the `wasp db studio` command:\n\n```bash\nDATABASE_URL=\"postgresql://user:password@host:port/dbname\" wasp db studio\n```\n\n:::caution Be careful with the `DATABASE_URL` env variable\n\nSetting the `DATABASE_URL` env variable in the `.env.server` file to point to your production database also works, but then you might forget to remove it and you could accidentally make changes to the production database when you run `wasp start` in development.\n\nThat's why we recommend setting the `DATABASE_URL` env variable in the terminal to avoid this.\n\n:::\n\nIf you are looking how to connect to a Fly.io production database, we wrote a [guide](https://github.com/wasp-lang/learning-materials/?tab=readme-ov-file#running-wasp-db-studio-on-production-db) on how to do that.\n\n## Deployment Overview\n\nWasp apps are full-stack apps that consist of:\n\n- A Node.js server.\n- A static client.\n- A PostgreSQL database.\n\nYou can deploy each part **anywhere** where you can usually deploy Node.js apps or static apps. For example, you can deploy your client on [Netlify](https://www.netlify.com/), the server on [Fly.io](https://fly.io/), and the database on [Neon](https://neon.tech/).\n\nTo make deploying as smooth as possible, Wasp also offers a single-command deployment through the **Wasp CLI**.\n\n<DeploymentOptionsGrid />\n\nRegardless of how you choose to deploy your app (i.e., manually or using the Wasp CLI), you'll need to know about some common patterns covered below.\n\n:::tip Deployed? Get some swag! 👕🐝\n\nDo you have a Wasp app running in production? If yes, we'd love to send some swag your way! All you need to do is\nfill [this form](https://e44cy1h4s0q.typeform.com/to/EPJCwsMi) out and we'll make it happen.\n\n:::\n\n### Customizing the Dockerfile\n\nBy default, Wasp generates a multi-stage Dockerfile.\nThis file is used to build and run a Docker image with the Wasp-generated server code.\nIt also runs any pending migrations.\n\nYou can **add extra steps to this multi-stage `Dockerfile`** by creating your own `Dockerfile` in the project's root directory.\nIf Wasp finds a Dockerfile in the project's root, it appends its contents at the _bottom_ of the default multi-stage Dockerfile.\n\nSince the last definition in a Dockerfile wins, you can override or continue from any existing build stages.\nYou can also choose not to use any of our build stages and have your own custom Dockerfile used as-is.\n\nA few things to keep in mind:\n\n- If you override an intermediate build stage, no later build stages will be used unless you reproduce them below.\n- The generated Dockerfile's content is dynamic and depends on which features your app uses. The content can also change in future releases, so please verify it from time to time.\n- Make sure to supply `ENTRYPOINT` in your final build stage. Your changes won't have any effect if you don't.\n\nRead more in the official Docker docs on [multi-stage builds](https://docs.docker.com/build/building/multi-stage/).\n\nTo see what your project's (potentially combined) Dockerfile will look like, run:\n\n```shell\nwasp dockerfile\n```\n\nJoin our [Discord](https://discord.gg/rzdnErX) if you have any questions, or if you need more customization than this hook provides.\n\n## Wasp CLI\n\nWasp CLI can deploy your full-stack application with only a single command.\nThe command automates the manual deployment process and is the recommended way of deploying Wasp apps.\n\n### Supported Providers\n\nWasp supports automated deployment to the following providers:\n\n- [Fly.io](#flyio)\n- [Railway](#railway)\n\n### Fly.io {#flyio}\n\n#### Prerequisites\n\nFly requires you to add your credit card information before you can deploy your apps. If you don't, the deployment will fail. Prices are usage based and can be [estimated here](https://fly.io/calculator).\n\nYou can add the required credit card information on the [account's billing page](https://fly.io/dashboard/personal/billing).\n\n:::info Fly.io CLI\nYou will need the [`fly` CLI](https://fly.io/docs/hands-on/install-flyctl/) installed on your machine before you can deploy to Fly.io.\n:::\n\n#### Deploying\n\nUsing the Wasp CLI, you can easily deploy a new app to [Fly.io](https://fly.io) with just a single command:\n\n```shell\nwasp deploy fly launch my-wasp-app mia\n```\n\n<small>\n  Please do not CTRL-C or exit your terminal while the commands are running.\n</small>\n\nTwo things to keep in mind:\n\n1. Your app name (for example `my-wasp-app`) must be **unique** across all of Fly or deployment will fail.\n\n1. If your account is a member of **more than one organization** on Fly.io, you will need to specify under which one you want to execute the command. To do that, provide an additional `--org <org-slug>` option. You can find out the names (slugs) of your organizations by running `fly orgs list`.\n\nThe `launch` command uses the app basename `my-wasp-app` and deploy it to the `mia` region (`mia` is short for _Miami, Florida (US)_). Read more about Fly.io regions [here](#flyio-regions).\n\nThe basename is used to create all three app tiers, resulting in three separate apps in your Fly dashboard:\n\n- `my-wasp-app-client`\n- `my-wasp-app-server`\n- `my-wasp-app-db`\n\nYou'll notice that Wasp creates two new files in your project root directory:\n\n- `fly-server.toml`\n- `fly-client.toml`\n\nYou should include these files in your version control so that you can deploy your app with a single command in the future.\n\n<LaunchCommandEnvVars />\n\nIf your app requires any additional environment variables, use the `wasp deploy fly cmd secrets set` command. Read more in the [API Reference](#flyio-cli-environment-variables) section.\n\n#### Using a Custom Domain For Your App {#fly-custom-domain}\n\nSetting up a custom domain is a three-step process:\n\n1. You need to add your domain to your Fly client app. You can do this by running:\n\n```shell\nwasp deploy fly cmd --context client certs create mycoolapp.com\n```\n\n:::note Use Your Domain\nMake sure to replace `mycoolapp.com` with your domain in all of the commands mentioned in this section.\n:::\n\nThis command will output the instructions to add the DNS records to your domain. It will look something like this:\n\n```shell-session\nYou can direct traffic to mycoolapp.com by:\n\n1: Adding an A record to your DNS service which reads\n\n    A @ 66.241.1XX.154\n\nYou can validate your ownership of mycoolapp.com by:\n\n2: Adding an AAAA record to your DNS service which reads:\n\n    AAAA @ 2a09:82XX:1::1:ff40\n```\n\n2. You need to add the DNS records for your domain:\n\n   _This will depend on your domain provider, but it should be a matter of adding an A record for `@` and an AAAA record for `@` with the values provided by the previous command._\n\n3. You need to set your domain as the `WASP_WEB_CLIENT_URL` environment variable for your server app:\n\n```shell\nwasp deploy fly cmd --context server secrets set WASP_WEB_CLIENT_URL=https://mycoolapp.com\n```\n\n<small>\n  We need to do this to keep our CORS configuration up to date.\n</small>\n\nThat's it, your app should be available at `https://mycoolapp.com`!\n\n##### Adding a `www` Subdomain\n\nIf you'd also like to access your app at `https://www.mycoolapp.com`, you can generate certificates for the `www` subdomain.\n\n```shell\nwasp deploy fly cmd --context client certs create www.mycoolapp.com\n```\n\nOnce you do that, you will need to add another DNS record for your domain. It should be a CNAME record for `www` with the value of your root domain.\nHere's an example:\n\n| Type  | Name | Value         | TTL  |\n| ----- | ---- | ------------- | ---- |\n| CNAME | www  | mycoolapp.com | 3600 |\n\nWith the CNAME record (Canonical name), you are assigning the `www` subdomain as an alias to the root domain.\n\nYour app should now be available both at the root domain `https://mycoolapp.com` and the `www` sub-domain `https://www.mycoolapp.com`.\n\n:::caution CORS Configuration\n\nUsing the `www` and `non-www` domains at the same time will require you to update your CORS configuration to allow both domains. You'll need to provide [custom CORS configuration](https://gist.github.com/infomiho/5ca98e5e2161df4ea78f76fc858d3ca2) in your server app to allow requests from both domains.\n\n:::\n\n### Railway {#railway}\n\n#### Prerequisites\n\nTo deploy to Railway using Wasp CLI:\n\n1. Create a [Railway](https://railway.com/) account,\n\n1. Wasp CLI requires that Railpack is set as the default deployment builder **for client routing to work correctly**. Go to your [Railway account settings](https://railway.com/account/feature-flags) and enable \"Default to Railpack\".\n\n1. Install the [`railway` CLI](https://docs.railway.com/guides/cli#installing-the-cli) on your machine.\n\n#### Deploying\n\nUsing the Wasp CLI, you can easily deploy a new app to Railway with a single command:\n\n```shell\nwasp deploy railway launch my-wasp-app\n```\n\n<small>\n  Please do not CTRL-C or exit your terminal while the commands are running.\n</small>\n\nKeep in mind that:\n\n1. Your project name (for example `my-wasp-app`) must be unique across all your Railway projects or deployment will fail (his is a current limitation of the Wasp CLI and Railway integration [#2926](https://github.com/wasp-lang/wasp/issues/2926)).\n\n1. If you are a member of multiple Railway organizations, the CLI will prompt you to select the organization under which you want to deploy your app.\n\nThe project name is used as a base for your server and client service names on Railway:\n\n- `my-wasp-app-client`\n- `my-wasp-app-server`\n\nRailway doesn't allow setting the database service name using the Railway CLI. It will always be named `Postgres`.\n\n<LaunchCommandEnvVars />\n\nIf you have any additional environment variables that your app needs, read how to set them in the [API Reference](#railway-environment-variables) section.\n\n#### Using a Custom Domain For Your App {#railway-custom-domain}\n\nSetting up a custom domain is a three-step process:\n\n1. Add your domain to the Railway client service:\n\n    - Go into the [Railway dashboard](https://railway.app/dashboard).\n    - Select your project (for example `my-wasp-app`).\n    - Click on the client service (for example `my-wasp-app-client`).\n    - Go to the **Settings** tab and click **Custom Domain**.\n    - Enter your domain name (for example `mycoolapp.com`) and port `8080`.\n    - Click **Add Domain**.\n\n2. Update the DNS records for your domain, adding a CNAME record at the domain or subdomain ",
        "namespace": "xtasker",
        "timestamp": 1754702891613
      },
      {
        "key": "waspfull_aj",
        "value": "you want, pointing to the address you've been given in the previous step. _This step depends on your domain provider, consult their documention in case of doubt._\n\n3. To avoid [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS) errors, you need to set your new client URL as the `WASP_WEB_CLIENT_URL` environment variable (for example `https://mycoolapp.com`) for your **server service** in the Railway dashboard.\n\n    - Go into the [Railway dashboard](https://railway.app/dashboard).\n    - Select your project (for example `my-wasp-app`).\n    - Click on the server service (for example `my-wasp-app-server`).\n    - Go to the **Variables** tab.\n\n    Update the `WASP_WEB_CLIENT_URL` variable with the new domain for your client.\n\nThat's it, your app should be available at `https://mycoolapp.com`!\n\n### API Reference\n\n#### Fly.io CLI Commands {#flyio-cli}\n\n##### The `launch` command\n\n`launch` is a convenience command that runs `setup`, `create-db`, and `deploy` in sequence.\n\n```shell\nwasp deploy fly launch <app-name> <region>\n```\n\nIt accepts the following arguments:\n\n- `<app-name>` Required!\n\n  The name of your app.\n\n- `<region>`  Required!\n\n  The region where your app will be deployed. Read how to find the available regions [here](#flyio-regions).\n\nRunning `wasp deploy fly launch` is same as running the following commands:\n\n```shell\nwasp deploy fly setup <app-name> <region>\nwasp deploy fly create-db <region>\nwasp deploy fly deploy\n```\n\n###### Environment Variables {#fly-launch-environment-variables}\n\n####### Server\n\nIf you are deploying an app that requires any other environment variables (like social auth secrets), you can set them with the `--server-secret` option:\n\n```\nwasp deploy fly launch my-wasp-app mia --server-secret GOOGLE_CLIENT_ID=<...> --server-secret GOOGLE_CLIENT_SECRET=<...>\n```\n\n####### Client\n\nIf you've added any [client-side environment variables](../../project/env-vars#client-env-vars) to your app, pass them to the terminal session before running the `launch` command, for example:\n\n```shell\nREACT_APP_ANOTHER_VAR=somevalue wasp deploy fly launch my-wasp-app mia\n```\n\n##### The `setup` command\n\nThe `setup` command registers your client and server apps on Fly, and sets up needed environment variables.\nIt only needs to be run once, when initially creating the app. It does _not_ trigger a deploy for the client or server apps.\n\n```shell\nwasp deploy fly setup <app-name> <region>\n```\n\nIt accepts the following arguments:\n\n- `<app-name>` Required!\n\n  The name of your app.\n\n- `<region>` Required!\n\n  The region where your app will be deployed. Read how to find the available regions [here](#flyio-regions).\n\nAfter running `setup`, Wasp creates two new files in your project root directory: `fly-server.toml` and `fly-client.toml`.\nYou should include these files in your version control.\n\nYou **can edit the `fly-server.toml` and `fly-client.toml` files** to further configure your Fly deployments. Wasp will use the TOML files when you run `deploy`.\n\nIf you want to maintain multiple apps, you can add the `--fly-toml-dir <abs-path>` option to point to different directories, like \"dev\" or \"staging\".\n\n:::caution Execute Only Once\nYou should only run `setup` once per app. If you run it multiple times, it creates unnecessary apps on Fly.\n:::\n\n##### The `create-db` command\n\nThe `create-db` command creates a new database for your app.\n\n```shell\nwasp deploy fly create-db <region>\n```\n\nIt accepts the following arguments:\n\n- `<region>` Required!\n\n  The region where your app will be deployed. Read how to find the available regions [here](#flyio-regions).\n\n:::caution Execute Only Once\nYou should only run `create-db` once per app. If you run it multiple times, it creates multiple databases, but your app needs only one.\n:::\n\n##### The `deploy` command\n\n```shell\nwasp deploy fly deploy\n```\n\nThe `deploy` command pushes your built client and server live.\n\nRun this command whenever you want to **update your deployed app** with the latest changes:\n\n```shell\nwasp deploy fly deploy\n```\n\nIf you've added any [client-side environment variables](../../project/env-vars#client-env-vars) to your app, pass them to the terminal session before running the `deploy` command, for example:\n\n```shell\nREACT_APP_ANOTHER_VAR=somevalue wasp deploy fly deploy\n```\n\nYou must specify your client-side environment variables every time you redeploy with the above command [to ensure they are included in the build process](../../project/env-vars#client-env-vars-1).\n\n##### The `cmd` command\n\nIf you want to run arbitrary Fly commands (for example `fly secrets list` for your server app), here's how to do it:\n\n```shell\nwasp deploy fly cmd secrets list --context server\n```\n\n##### Environment Variables {#flyio-cli-environment-variables}\n\n###### Server Secrets\n\nIf your app requires any other server-side environment variables (like social auth secrets), you can set them:\n\n1. Initially in the `launch` or `setup` commands with the [`--server-secret` option](#fly-launch-environment-variables)\n2. After the app has already been deployed by using the `secrets set` command:\n\n    ```\n    wasp deploy fly cmd secrets set GOOGLE_CLIENT_ID=<...> GOOGLE_CLIENT_SECRET=<...> --context=server\n    ```\n\n###### Client Environment Variables\n\nIf you've added any [client-side environment variables](../../project/env-vars#client-env-vars) to your app, pass them to the terminal session before running a deployment command, for example:\n\n```shell\nREACT_APP_ANOTHER_VAR=somevalue wasp deploy fly launch my-wasp-app mia\n```\n\nor\n\n```shell\nREACT_APP_ANOTHER_VAR=somevalue wasp deploy fly deploy\n```\n\nPlease note that you should do this for **every deployment**, not just the first time you set up the variables. One way to make sure you don't forget to add them is to create a `deploy` script in your `package.json` file:\n\n```json title=\"package.json\"\n{\n  \"scripts\": {\n    \"deploy\": \"REACT_APP_ANOTHER_VAR=somevalue wasp deploy fly deploy\"\n  }\n}\n```\n\nThen you can run `npm run deploy` to deploy your app.\n\n##### Fly.io Regions\n\n> Fly.io runs applications physically close to users: in datacenters around the world, on servers we run ourselves. You can currently deploy your apps in 34 regions, connected to a global Anycast network that makes sure your users hit our nearest server, whether they’re in Tokyo, São Paolo, or Frankfurt.\n\n<small>\n  Read more on Fly regions [here](https://fly.io/docs/reference/regions/).\n</small>\n\nYou can find the list of all available Fly regions by running:\n\n```shell\nfly platform regions\n```\n\n##### Multiple Fly.io Organizations\n\nIf you have multiple organizations, you can specify a `--org` option. For example:\n\n```shell\nwasp deploy fly launch my-wasp-app mia --org hive\n```\n\n##### Building Locally\n\nFly.io offers support for both **locally** built Docker containers and **remotely** built ones. However, for simplicity and reproducibility, the CLI defaults to the use of a remote Fly.io builder.\n\nIf you want to build locally, supply the `--build-locally` option to `wasp deploy fly launch` or `wasp deploy fly deploy`.\n\n#### Railway CLI Commands {#railway-cli}\n\n##### The `launch` command\n\n`launch` is a convenience command that runs `setup` and `deploy` in sequence.\n\n```shell\nwasp deploy railway launch <project-name>\n```\n\nIt accepts the following arguments:\n\n- `<project-name>` Required!\n\n  The name of your project.\n\nRunning `wasp deploy railway launch` is same as running the following commands:\n\n```shell\nwasp deploy railway setup <project-name>\nwasp deploy railway deploy <project-name>\n```\n\n###### Explicitly providing the Railway project ID\n\nBy default, Wasp CLI tries to create a new Railway project named `<project-name>`. If you want to use an existing Railway project, pass its ID with `--existing-project-id` option:\n\n```shell\nwasp deploy railway launch <project-name> --existing-project-id <railway-project-id>\n```\n\n###### Environment Variables {#railway-launch-environment-variables}\n\n####### Server\n\nIf you are deploying an app that requires any other environment variables (like social auth secrets), you can set them with the `--server-secret` option:\n\n```\nwasp deploy railway launch my-wasp-app --server-secret GOOGLE_CLIENT_ID=<...> --server-secret GOOGLE_CLIENT_SECRET=<...>\n```\n\n####### Client\n\nIf you've added any [client-side environment variables](../../project/env-vars#client-env-vars) to your app, pass them to the terminal session before running the `launch` command, for example:\n\n```shell\nREACT_APP_ANOTHER_VAR=somevalue wasp deploy railway launch my-wasp-app\n```\n\n##### The `deploy` command\n\nThe `deploy` command deploys your client and server apps to Railway.\n\n```shell\nwasp deploy railway deploy <project-name>\n```\n\nIt accepts the following arguments:\n\n- `<project-name>` Required!\n\n  The name of your project.\n\nRun this command whenever you want to **update your deployed app** with the latest changes:\n\n```shell\nwasp deploy railway deploy <project-name>\n```\n\n###### Explicitly providing the Railway project ID\n\nWhen you run the `deploy` command, Wasp CLI will use the Railway project that's linked to the Wasp project directory. If no Railway project is linked, the command will fail asking you to run the `setup` command first.\n\nIf you are deploying your Railway app in the CI, you can pass the `--existing-project-id` option to tell Wasp CLI the Railway project ID to use for the deployment:\n\n```shell\nwasp deploy railway deploy <project-name> --existing-project-id <railway-project-id>\n```\n\n###### Other Available Options\n\n- `--skip-client` - do not deploy the web client\n- `--skip-server` - do not deploy the server\n\nIf you've added any [client-side environment variables](../../project/env-vars#client-env-vars) to your app, pass them to the terminal session before running the `deploy` command, for example:\n\n```shell\nREACT_APP_ANOTHER_VAR=somevalue wasp deploy railway deploy <project-name>\n```\n\nYou must specify your client-side environment variables every time you redeploy with the above command [to ensure they are included in the build process](../../project/env-vars#client-env-vars-1).\n\n##### The `setup` command\n\nThe `setup` command creates your client, server, and database services on Railway. It also configures environment variables. It does _not_ deploy the client or server services.\n\n```shell\nwasp deploy railway setup <project-name>\n```\n\nIt accepts the following arguments:\n\n- `<project-name>` \n\n  the name of your project.\n\nThe project name is used as a base for your server and client service names on Railway:\n\n- `<project-name>-client`\n- `<project-name>-server`\n\nRailway also creates a PostgreSQL database service named `Postgres`.\n\n###### Explicitly providing the Railway project ID\n\nBy default, Wasp CLI tries to create a new Railway project named `<project-name>`. If you want to use an existing Railway project, pass its ID with `--existing-project-id` option:\n\n```shell\nwasp deploy railway setup <project-name> --existing-project-id <railway-project-id>\n```\n\n:::caution Execute Only Once\nYou should only run `setup` once per app. Wasp CLI skips creating the services if they already exist.\n:::\n\n##### Environment Variables {#railway-environment-variables}\n\n###### Server Secrets\n\nIf your app requires any other server-side environment variables (like social auth secrets), you can set them:\n\n1. Initially in the `launch` or `setup` commands with the [`--server-secret` option](#railway-launch-environment-variables)\n2. After the app has already been deployed go into the Railway dashboard and set them in the **Variables** tab of your server service.\n\n###### Client Environment Variables\n\nIf you've added any [client-side environment variables](../../project/env-vars#client-env-vars) to your app, pass them to the terminal session before running a deployment command, for example:\n\n```shell\nREACT_APP_ANOTHER_VAR=somevalue wasp deploy railway launch my-wasp-app\n```\n\nor\n\n```shell\nREACT_APP_ANOTHER_VAR=somevalue wasp deploy railway deploy\n```\n\nPlease note that you should do this for **every deployment**, not just the first time you set up the variables. One way to make sure you don't forget to add them is to create a `deploy` script in your `package.json` file:\n\n```json title=\"package.json\"\n{\n  \"scripts\": {\n    \"deploy\": \"REACT_APP_ANOTHER_VAR=somevalue wasp deploy railway deploy\"\n  }\n}\n```\n\nThen you can run `npm run deploy` to deploy your app.\n\n## Platform as a Service (PaaS)\n\nThis document explains how to build and prepare your Wasp app for deployment.\nYou can then deploy the built Wasp app wherever and however you want, as long as your provider/server supports Wasp's build format.\n\nAfter going through the general steps that apply to all deployments, you can\nfollow step-by-step guides for deploying your Wasp app to the most popular\nproviders:\n\n- [Fly.io](#flyio)\n- [Railway](#railway)\n- [Heroku](#heroku)\n- [Netlify](#netlify)\n- [Cloudflare](#cloudflare)\n\nNo worries, you can still deploy your app if your desired provider isn't on the\nlist - it just means we don't yet have a step-by-step guide for you to follow.\nFeel free to [open a\nPR](https://github.com/wasp-lang/wasp/edit/release/web/docs/deployment/deployment-methods/paas.md)\nif you'd like to write one yourself :)\n\n### Deploying a Wasp App\n\nDeploying a Wasp app comes down to the following:\n\n1. Generating deployable code.\n2. Deploying the API server (backend).\n3. Deploying the web client (frontend).\n4. Deploying a PostgreSQL database and keeping it running.\n\nLet's go through each of these steps.\n\n#### 1. Generating Deployable Code\n\nRunning the command `wasp build` generates deployable code for the whole app in the `.wasp/build/` directory.\n\n```\nwasp build\n```\n\n:::caution PostgreSQL in production\nYou won't be able to build the app if you are using SQLite as a database (which is the default database).\nYou'll have to [switch to PostgreSQL](../../data-model/databases.md#migrating-from-sqlite-to-postgresql) before deploying to production.\n:::\n\n#### 2. Deploying the API Server <Server />\n\nThere's a Dockerfile that defines an image for building the server in the `.wasp/build` directory.\n\nTo run the server in production, deploy this Docker image to a hosting provider and make sure the required env variables are correctly set up. Usually, you use the provider's dashboard UI or a CLI tool to set up these env variables.\n\nCheck the [required server env variables](../env-vars.md#server-env-vars) and make sure they are set up for your server.\n\nWhile these are the general instructions on deploying the server anywhere, we also have more detailed instructions for chosen providers below, so check that out for more guidance if you are deploying to one of those providers.\n\n#### 3. Deploying the Web Client <Client />\n\n<BuildingTheWebClient />\n\nThe command above will build the web client and put it in the `build/` directory in the `.wasp/build/web-app/`.\n\nSince the result of building is just a bunch of static files, you can now deploy your web client to any static hosting provider (e.g. Netlify, Cloudflare, ...) by deploying the contents of `.wasp/build/web-app/build/`.\n\n#### 4. Deploying the Database <Database />\n\nAny PostgreSQL database will do, as long as you provide the server with the correct `DATABASE_URL` env var and ensure that the database is accessible from the server.\n\n### Different Providers\n\nWe'll cover a few different deployment providers below:\n\n- Fly.io <Server /> <Database />\n- Railway <Server /> <Client /> <Database />\n- Heroku <Server /> <Database />\n- Netlify <Client />\n- Cloudflare <Client />\n\n### Fly.io <Server /> <Database /> {#flyio}\n\nIn this section, we'll show how to deploy your server and provision a database for it on Fly.io.\n\n:::info One command deploy\n\nWe recommend that you use [Wasp Deploy](./cli.md#flyio) to deploy your Wasp app to Fly.io. Wasp CLI automates deploying the client, the server and the database with one command.\n\n:::\n\n#### Prerequisites\n\nTo get started, follow these steps:\n\n1. Create a [Fly.io](https://fly.io/) account,\n1. Install the [`fly` CLI](https://fly.io/docs/flyctl/install/),\n1. Log in with the `fly` CLI.\n\nYou can check if you are logged in with `fly auth whoami`, and if you are not, you can log in with `fly auth login`.\n\n#### Set Up a Fly.io App\n\n:::info\nYou need to do this only once per Wasp app.\n:::\n\nUnless you already have a Fly.io app that you want to deploy to, let's create a new Fly.io app.\n\nAfter you have [built the app](#1-generating-deployable-code), position yourself in `.wasp/build/` directory:\n\n```shell\ncd .wasp/build\n```\n\nNext, run the launch command to set up a new app and create a `fly.toml` file:\n\n```bash\nfly launch --remote-only\n```\n\nThis will ask you a series of questions, such as asking you to choose a region and whether you'd like a database.\n\n- Say **yes** to **Would you like to set up a PostgreSQL database now?** and select **Development**. Fly.io will set a `DATABASE_URL` for you.\n- Say **no** to **Would you like to deploy now?** (and to any additional questions).\n\n  We still need to set up several environment variables.\n\n:::info What if the database setup fails?\nIf your attempts to initiate a new app fail for whatever reason, then you should run `fly apps destroy <app-name>` before trying again. Fly does not allow you to create multiple apps with the same name.\n\n<details>\n  <summary>\n    What does it look like when your DB is deployed correctly?\n  </summary>\n\n  <div>\n    <p>When your DB is deployed correctly, you'll see it in the <a href=\"https://fly.io/dashboard\">Fly.io dashboard</a>:</p>\n\n    <img width=\"662\" alt=\"image\" src=\"/img/deploying/fly-db.png\" />\n  </div>\n</details>\n\n:::\n\nNext, let's copy the `fly.toml` file up to our Wasp project dir for safekeeping.\n\n```shell\ncp fly.toml ../../\n```\n\nNext, add a few more environment variables for the server code.\n\n```bash\nfly secrets set PORT=8080\nfly secrets set JWT_SECRET=<random_string_at_least_32_characters_long>\nfly secrets set WASP_WEB_CLIENT_URL=<url_of_where_client_will_be_deployed>\nfly secrets set WASP_SERVER_URL=<url_of_where_server_will_be_deployed>\n```\n\n:::note\nIf you do not know what your client URL is yet, don't worry. You can set `WASP_WEB_CLIENT_URL` after you deploy your client.\n:::\n\n<AddExternalAuthEnvVarsReminder />\n\nIf you want to make sure you've added your secrets correctly, run `fly secrets list` in the terminal. Note that you will see hashed versions of your secrets to protect your sensitive data.\n\n#### Deploy to a Fly.io App\n\nWhile still in the `.wasp/build/` directory, run:\n\n```bash\nfly deploy --remote-only --config ../../fly.toml\n```\n\nThis will build and deploy the backend of your Wasp app on Fly.io to `https://<app-name>.fly.dev` 🤘🎸\n\nNow, if you haven't, you can deploy your client and add the client URL by running `fly secrets set WASP_WEB_CLIENT_URL=<url_of_deployed_client>`. We suggest using [Netlify](#netlify) for your client, but you can use any static hosting provider.\n\nAdditionally, some useful `fly` commands:\n\n```bash\nfly logs\nfly secrets list\nfly ssh console\n```\n\n#### Redeploying After Wasp Builds\n\nWhen you rebuild your Wasp app (with `wasp build`), it will remove your `.wasp/build/` directory. In there, you may have a `fly.toml` from any prior Fly.io deployments.\n\nWhile we will improve this process in the future, in the meantime, you have a few options:\n\n1. Copy the `fly.toml` file to a versioned directory, like your Wasp project dir.\n\nFrom there, you can reference it in `fly deploy --config <path>` commands, like above.\n\n1. Backup the `fly.toml` file somewhere before running `wasp build`, and copy it into .wasp/build/ after.\n\nWhen the `fly.toml` file exists in .wasp/build/ dir, you do not need to specify the `--config <path>`.\n\n1. Run `fly config save -a <app-name>` to regenerate the `fly.toml` file from the remote state stored in Fly.io.\n\n### Railway <Server /> <Client /> <Database /> {#railway}\n\nIn this section, we'll show how to deploy the client, the server, and provision a database on Railway.\n\n:::info One command deploy\n\nWe recommend that you use [Wasp Deploy](./cli.md#railway) to deploy your Wasp app to Railway. Wasp CLI automates deploying the client, the server and the database with one command.\n\n:::\n\n#### Prerequisites\n\nTo get started, follow these steps:\n\n1. Make sure your Wasp app is built by running `wasp build` in the project dir.\n1. Create a [Railway](https://railway.com/) account.\n1. Install the [Railway CLI](https://docs.railway.com/develop/cli#installation).\n1. Run `railway login` and a browser tab will open to authenticate you.\n1. Go to your [Railway account settings](https://railway.com/account/feature-flags) and enable **Railpack** as the default deployment builder. This is required for the client routing to work correctly.\n\n#### Create New Project\n\nLet's create our Railway project:\n\n1. Go to your [Railway dashboard](https://railway.com/dashboard), click on **New Project**, and select **Deploy PostgreSQL** from the dropdown menu.\n1. Once the project is created, left-click on the **Create** button in the top right corner and select **Empty Service**.\n1. Click on the new service, and change the name to `server`.\n1. Create another empty service and name it `client`.\n1. Deploy the changes by pressing the **Deploy** button on top.\n\n#### Deploy Your App to Railway\n\n##### Setup Domains\n\nWe'll need the domains for both the `server` and `client` services:\n\n1. Go to the `server` instance's **Settings** tab, and click **Generate Domain**.\n1. Enter `8080` as the port and click **Generate Domain**.\n1. Do the same under the `client`'s **Settings**.\n1. Copy both domains, as we will need them later.\n\n##### Deploying the Server\n\nYou'll deploy the server first:\n\n1. Move into the `.wasp/build` directory:\n\n    ```shell\n    cd .wasp/build\n    ```\n\n2. Link the `.wasp/build` directory to your newly created Railway project:\n\n    ```shell\n    railway link\n    ```\n\n    Select `server` when prompted to select a service.\n\n  <!-- TOPIC: env vars -->\n\n3. Go into the Railway dashboard and set up the required env variables:\n\n   Click on the `server` service and go to the **Variables** tab:\n\n   1. Click **Variable reference** and select `DATABASE_URL` (it will populate it with the correct value)\n\n   1. Add `WASP_WEB_CLIENT_URL` with the `client` domain (e.g. `https://client-production-XXXX.up.railway.app`). `https://` prefix is required!\n\n   1. Add `WASP_SERVER_URL` with the `server` domain (e.g. `https://server-production-XXXX.up.railway.app`). `https://` prefix is required!\n\n   1. Add `JWT_SECRET` with a random string at least 32 characters long (use an [online generator](https://djecrety.ir/))\n\n     <AddExternalAuthEnvVarsReminder />\n\n4. Push and deploy the project:\n\n    ```shell\n    railway up --ci\n    ```\n\n    <small>\n\n    We use the `--ci` flag to limit the log output to only the build process.\n    </small>\n\n    Railway will locate the `Dockerfile` in `.wasp/build` and deploy your server.\n\n##### Deploying the Client\n\n1. Next, go into your app's frontend build directory `.wasp/build/web-app`:\n\n    ```shell\n    cd web-app\n    ```\n\n2. Create the production build, using the `server` domain as the `REACT_APP_API_URL`:\n\n    ```shell\n    npm install && REACT_APP_API_URL=<url_to_wasp_backend> npm run build\n    ```\n\n3. Next, we want to link the client build directory to the `client` service:\n\n    ```shell\n    cd build\n    railway link\n    ```\n\n4. Next, deploy the client build to Railway:\n\n    ```shell\n    railway up --ci\n    ```\n\n    Select `client` when prompted to select a service.\n\n    Railway will detect the `index.html` file and deploy the client as a static site using [Railpack](https://railpack.com/languages/staticfile#root-directory-resolution).\n\nAnd now your Wasp should be deployed!\n\nBack in your [Railway dashboard](https://railway.com/dashboard), click on your project and you should see your newly deployed services: PostgreSQL, Server, and Client.\n\n#### Updates & Redeploying\n\nWhen you make updates and need to redeploy:\n\n1. Run `wasp build` to rebuild your app.\n1. Go into the `.wasp/build` directory and:\n\n    Deploy the server with:\n    ```shell\n    railway up --ci\n    ```\n1. Go into the `.wasp/build/web-app` directory and:\n\n    Rebuild the client with:\n    ```shell\n    npm install && REACT_APP_API_URL=<url_to_wasp_backend> npm run build\n    ```\n    And then deploy the client with:\n    ```shell\n    cd build\n    railway up --ci\n    ```\n\n### Heroku <Server /> <Database /> {#heroku}\n\nWe will show how to deploy the server and provision a database for it on Heroku. You can check their [pricing page](https://www.heroku.com/pricing) for more information on their plans.\n\nYou will need Heroku account, `heroku` [CLI](https://devcenter.heroku.com/articles/heroku-cli) and `docker` CLI installed to follow these instructions.\n\nMake sure you are logged in with `heroku` CLI. You can check if you are logged in with `heroku whoami`, and if you are not, you can log in with `heroku login`.\n\n#### Set up a Heroku app\n\n:::info\nYou need to do this only once per Wasp app.\n:::\n\nUnless you want to deploy to an existing Heroku app, let's create a new Heroku app:\n\n```\nheroku create <app-name>\n```\n\nUnless you have an external PostgreSQL database that you want to use, let's create a new database on Heroku and attach it to our app:\n\n```\nheroku addons:create --app <app-name> heroku-postgresql:essential-0\n```\n\n:::caution\n\nWe are using the `essential-0` database instance. It's the cheapest database instance Heroku offers and it costs $5/mo.\n:::\n\nHeroku will also set `DATABASE_URL` env var for us at this point. If you are using an external database, you will have to set it up yourself.\n\nThe `PORT` env var will also be provided by Heroku, so the ones left to set are the `JWT_SECRET`, `WASP_WEB_CLIENT_URL` and `WASP_SERVER_URL` env vars:\n\n```\nheroku config:set --app <app-name> JWT_SECRET=<random_string_at_least_32_characters_long>\nheroku config:set --app <app-name> WASP_WEB_CLIENT_URL=<url_of_where_client_will_be_deployed>\nheroku config:set --app <app-name> WASP_SERVER_URL=<url_of_where_server_will_be_deployed>\n```\n\n:::note\nIf you do not know what your client URL is yet, don't worry. You can set `WASP_WEB_CLIENT_URL` after you deploy your client.\n:::\n\n#### Deploy the Heroku app\n\nAfter you have [built the app](#1-generating-deployable-code), position yourself in `.wasp/build/` directory:\n\n```shell\ncd .wasp/build\n```\n\nassuming you were at the root of your Wasp project at that moment.\n\nLog in to Heroku Container Registry:\n\n```shell\nheroku container:login\n```\n\nSet your app's stack to `container` so we can deploy our app as a Docker container:\n\n```shell\nheroku stack:set container --app <app-name>\n```\n\nBuild the Docker image and push it to Heroku:\n\n```shell\nheroku container:push --app <app-name> web\n```\n\nApp is still not deployed at this point.\nThis step might take some time, especially the very first time, since there are no cached Docker layers.\n\nDeploy the pushed image and restart the app:\n\n```shell\nheroku container:release --app <app-name> web\n```\n\nThis is it, the backend is deployed at `https://<app-name>-XXXX.herokuapp.com` 🎉\n\nFind out the exact app URL with:\n\n```shell\nheroku info --app <app-name>\n```\n\nAdditionally, you can check out the logs with:\n\n```shell\nheroku logs --tail --app <app-name>\n```\n\n:::note Using `pg-boss` with Heroku\n\nIf you wish to deploy an app leveraging [Jobs](../../advanced/jobs) that use `pg-boss` as the executor to Heroku, you need to set an additional environment variable called [`PG_BOSS_NEW_OPTIONS`](../../advanced/jobs.md#pg_boss_new_options) to `{\"connectionString\":\"<REGULAR_HEROKU_DATABASE_URL>\",\"ssl\":{\"rejectUnauthorized\":false}}`. This is because pg-boss uses the `pg` extension, which does not seem to connect to Heroku over SSL by default, which Heroku requires. Additionally, Heroku uses a self-signed cert, so we must handle that as well.\n\nRead more: https://devcenter.heroku.com/articles/connecting-heroku-postgres#connecting-in-node-js\n:::\n\n### Netlify <Client /> {#netlify}\n\nNetlify is a static hosting solution that is free for many use cases. You will need a Netlify account to follow these instructions.\n\nMake sure you are logged in with Netlify CLI. You can check if you are logged in with `npx netlify-cli status`, and if you are not, you can log in with `npx netlify-cli login`.\n\nFirst, make sure you have [built the Wasp app](#1-generating-deployable-code). We'll build the client web app next.\n\n<BuildingTheWebClient />\n\nWe can now deploy the client with:\n\n```shell\nnpx netlify-cli deploy\n```\n\n<small>\n  Carefully follow the instructions: decide if you want to create a new app or use an existing one, pick the team under which your app will be deployed etc.\n</small>\n\nThe final step is to run:\n\n```shell\nnpx netlify-cli deploy --prod\n```\n\nThat is it! Your client should be live at `https://<app-name>.netlify.app`.\n\n:::note\nMake sure you set the `https://<app-name>.netlify.app` URL as the `WASP_WEB_CLIENT_URL` environment variable in your server hosting environment.\n:::\n\n:::caution Redirecting URLs toward `index.html`\nIf you follow the instructions above, the Netlify CLI will use `netlify.toml` file that Wasp generates by default in `.wasp/build/web-app/`. This will correctly configure Netlify to redirect URLs toward `index.html`, which is important since Wasp is a Single Page Application (SPA) and needs to handle routing on the client side.\n\nIf you instead use another method of deployment to Netlify, for example doing it using CI, make sure that Netlify picks up that `netlify.toml` file, or configure URL redirecting yourself manually on Netlify.\n\nWe recommend to deploy using the Netlify CLI in Github Actions. You can find an example Github Action configuration below.\n:::\n\n#### Deploying through Github Actions\n\nTo enable automatic deployment of the client whenever you push to the `main` branch, you can set up a GitHub Actions workflow. To do this, create a file in your repository at `.github/workflows/deploy.yaml`. Feel free to rename `deploy.yaml` as long as the file type is not changed.\n\nHere’s an example configuration file to help you get started. This example workflow will trigger a deployment to Netlify whenever changes are pushed to the main branch.\n\n<details>\n  <summary>Example Github Action</summary>\n\n  ```yaml\n  name: Deploy Client to Netlify\n\n  on:\n    push:\n      branches:\n        - main # Deploy on every push to the main branch\n\n  jobs:\n    deploy:\n      runs-on: ubuntu-latest\n\n      steps:\n        - name: Checkout Code\n          uses: actions/checkout@v2\n\n        - name: Setup Node.js\n          id: setup-node\n          uses: actions/setup-node@v4\n          with:\n            node-version: '20'\n\n        - name: Install Wasp\n          run: curl -sSL https://get.wasp.sh/installer.sh | sh -s -- -v 0.16.0 # Change to your Wasp version\n\n        - name: Wasp Build\n          run: wasp build\n\n        - name: Install dependencies and build the client\n          run: |\n            cd ./.wasp/build/web-app\n            npm install\n            REACT_APP_API_URL=${{ secrets.WASP_SERVER_URL }} npm run build\n\n        - name: Deploy to Netlify\n          run: |\n            cd ./.wasp/build/web-app\n            npx netlify-cli@17.36.1 deploy --prod --dir=build --auth=$NETLIFY_AUTH_TOKEN --site=$NETLIFY_SITE_NAME\n\n      env:\n        NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}\n        NETLIFY_SITE_NAME: netlify-site-name\n  ```\n</details>\n\n<details>\n  <summary>How do I get the Environment Variables?</summary>\n\n  - **`NETLIFY_AUTH_TOKEN`**: For the auth token, you'll generate a new Personal Access Token on [Netlify](https://docs.netlify.com/cli/get-started/#obtain-a-token-in-the-netlify-ui).\n\n  - **`NETLIFY_SITE_NAME`**: This is the name of your Netlify project.\n\n  - **`WASP_SERVER_URL`**: This is your server's URL and is generally only available after **deploying the backend**. This variable can be skipped when the backend is not functional or not deployed, but be aware that backend-dependent functionalities may be broken.\n\n  After getting the environment variables, you need to set these in GitHub Repository Secrets.\n</details>\n\n### Cloudflare <Client /> {#cloudflare}\n\n[Cloudflare](https://www.cloudflare.com/) is a cloud services provider that offers a variety of services, including free static hosting with Cloudflare Pages. You will need a Cloudflare account to follow these instructions.\n\nMake sure you are logged in with the Cloudflare's CLI called Wrangler. You can log in by running:\n\n```bash\nnpx wrangler login\n```\n\nBefore you continue, make sure you have [built the Wasp app](#1-generating-deployable-code). We'll build the client web app next.\n\n<BuildingTheWebClient />\n\nTo deploy the client, make sure you are positioned in the `.wasp/buld/web-app` folder and then run the following:\n\n```shell\nnpx wrangler pages deploy ./build --commit-dirty=true --branch=main\n```\n\n<small>\n  Carefully follow the instructions i.e. do you want to create a new app or use an existing one.\n</small>\n\nThat is it! Your client should be live at `https://<app-name>.pages.dev`.\n\n:::note\nMake sure you set the `https://<app-name>.pages.dev` URL as the `WASP_WEB_CLIENT_URL` environment variable in your server hosting environment.\n:::\n\n:::info Redirecting URLs toward `index.html`\n\nCloudflare will automatically redirect all paths toward `index.html`, which is important since Wasp's client app is a Single Page Application (SPA) and needs to handle routing on the client side.\n:::\n\n#### Deploying through Github Actions\n\nTo enable automatic deployment of the client whenever you push to the `main` branch, you can set up a GitHub Actions workflow. To do this, create a file in your repository at `.github/workflows/deploy.yaml`. Feel free to rename `deploy.yaml` as long as the file type is not changed.\n\nHere’s an example configuration file to help you get started. This example workflow will trigger a deployment to Cloudflare Pages whenever changes are pushed to the main branch.\n\n<details>\n  <summary>Example Github Action</summary>\n\n  ```yaml\n  name: Deploy Client to Cloudflare\n\n  on:\n    push:\n      branches:\n        - main # Deploy on every push to the main branch\n\n  jobs:\n    deploy:\n      runs-on: ubuntu-latest\n\n      steps:\n        - name: Checkout Code\n          uses: actions/checkout@v2\n\n        - name: Setup Node.js\n          id: setup-node\n          uses: actions/setup-node@v4\n          with:\n            node-version: '20'\n\n        - name: Install Wasp\n          run: curl -sSL https://get.wasp.sh/installer.sh | sh -s -- -v 0.16.0 # Change to your Wasp version\n\n        - name: Wasp Build\n          run: cd ./app && wasp build\n\n        - name: Install dependencies and build the client\n          run: |\n            cd ./app/.wasp/build/web-app\n            npm install\n            REACT_APP_API_URL=${{ secrets.WASP_SERVER_URL }} npm run build\n\n        - name: Deploy to Cloudflare Pages\n          uses: cloudflare/wrangler-action@v3\n          with:\n            apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}\n            accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}\n            command: pages deploy ./app/.wasp/build/web-app/build --project-name=${{ env.CLIENT_CLOUDFLARE_APP_NAME }} --commit-dirty=true --branch=main\n\n      env:\n        CLIENT_CLOUDFLARE_APP_NAME: cloudflare-pages-app-name\n  ```\n</details>\n\n<details>\n  <summary>How do I get the Environment Variables?</summary>\n\n  - **`CLOUDFLARE_API_TOKEN` and `CLOUDFLARE_ACCOUNT_ID`**: You can get these from your [Cloudflare dashboard](https://dash.cloudflare.com/profile/api-tokens). Make sure to give the token `Cloudflare Pages: Read` and `Cloudflare Pages: Edit` permissions.\n\n  - **`CLIENT_CLOUDFLARE_APP_NAME`**: This is the name of your Cloudflare Pages app. You can create a new Cloudflare Pages app with `npx wrangler pages project create <app-name>`.\n\n  - **`WASP_SERVER_URL`**: This is your server's URL and is generally only available after **deploying the backend**. This variable can be skipped when the backend is not functional or not deployed, but be aware that backend-dependent functionalities may be broken.\n\n  After getting the environment variables, you need to set these in GitHub Repository Secrets.\n</details>\n\n## Self-Hosted\n\nIf you have your server or rent out a server, you can self-host your Wasp apps. Self-hosting your apps gives you full control over your apps and their data. It can be more cost-effective than a cloud provider since you can deploy multiple apps on a single server. However, you'll need to manage the server yourself, which can be time-consuming and require some technical knowledge.\n\n### What you'll need\n\nTo successfully self-host your Wasp app, you need to have the following:\n\n- A server with a public IP address.\n  - There are many cloud providers you can use to rent a server. Some popular ones are [AWS](https://aws.amazon.com/ec2/), [DigitalOcean](https://www.digitalocean.com/), [OVH](https://www.ovhcloud.com/en/vps/), and [Hetzner](https://www.hetzner.com/cloud/).\n- A domain name, for example, `myapp.com` (needed for HTTPS support).\n\n### Self-hosting steps\n\nTo self-host your Wasp app, you need to follow these general steps:\n\n1. Get your **app's code** on the server.\n\n   - How you do this depends on your setup, we'll explore a few methods in the next section.\n\n2. Run your **client and server apps** on the server. Run the **database** on the server or use a managed database service.\n\n   - We'll use [Docker](https://docs.docker.com/engine/install/) to run the server app and the database, but you can run them without Docker if you prefer.\n\n3. Set up a **reverse proxy** on the server to be able to use a domain name with HTTPS for your app.\n\n4. Configure the **env variables** on your server for the server app.\n\n<ImgWithCaption source=\"/img/deploying/self-hosting.png\" alt=\"One of many possible self-hosting setups\" caption=\"One of possible self-hosting setups\" />\n\n### Deployment methods\n\nWe'll explore a few methods you can use to self-host your Wasp app. The first method is the most straightforward: you manually set up everything on your server. The other two methods require you to install and configure a self-hosted PaaS on your server and then use that to deploy apps to it.\n\n#### Simple setup\n\nIn this setup, you do all the steps on the server: you install Docker, set up the server env variable, set up a reverse proxy, and run your app. This is a very manual process, but you'll learn how everything works.\n\n##### Overview of the steps\n\nOn your server:\n\n1. Install [Docker](https://docs.docker.com/engine/install/), [Node.js](https://github.com/nvm-sh/nvm) and [Wasp CLI](/introduction/quick-start.md#installation).\n2. Get your **app's source code**.\n   - We recommend using Git to clone your app's repository and then pulling the latest changes when you want to deploy a new version. You can use any other method to get your app's code on the server.\n3. Build your app with **`wasp build`**.\n4. Build and run the **server app**.\n   - Wasp gives you a `Dockerfile` in the `.wasp/build` directory that you can use to build and run the server app.\n   - We are using Docker to run the server app, but you can run it without Docker if you prefer - just make sure to replicate the setup in the `Dockerfile`.\n   - When you run the server app with Docker, you need to setup the server env variables. You can do this with a `.env` file or by passing the env variables directly to the `docker run` command.\n5. Start the **database** on the server or use a managed database service.\n   - We usually run the database in Docker on the same server, but you can run the database directly on the server.\n   - You can also use a managed database service which you can connect to from your server. This is a great option if you don't want to manage the database yourself, but it can be more expensive.\n6. Build the **client app** into static files.\n   - Wasp outputs the client app in the `.wasp/build/web-app` directory.\n   <!-- TODO: we should change this link to the new place where we talk about how the client is built -->\n   - You should [build the client app](./paas.md#3-deploying-the-web-client-) into static files.\n7. Install and set up a **reverse proxy** to serve your client and server apps.\n   - There are many great choices for reverse proxies, like [Nginx](https://www.nginx.com/), [Caddy](https://caddyserver.com/), and [Traefik](https://traefik.io/).\n   - Make sure to set up the reverse proxy to serve the client app's static files and to proxy requests to the server app.\n8. Point your **domain(s)** to your server's IP address.\n   - We recommend setting `myapp.com` for the client and `api.myapp.com` for the server.\n   - The reverse proxy should serve the client app on `myapp.com` and proxy requests to the server app on `api.myapp.com`. Make sure your [env variables](../env-vars.md) are using these client and server URLs.\n\nCheck out one of our step-by-step guides for more details:\n\n<GuideLink linkToGuide=\"https://gist.github.com/infomiho/80f3f50346566e39db56c5e57fefa1fe\" title=\"Deploying Wasp with Docker on your server\" description=\"Uses Ubuntu, Git, Caddy, Docker\" />\n\n#### Coolify\n\n[Coolify](https://coolify.io/) is a deployment tool (self-hosted PaaS) that you run on your server. It makes it easier to deploy multple apps on your server. It has a nice looking UI and it helps you with managing your deployments.\n\n##### Overview of the steps\n\n1. Install [Coolify](https://coolify.io/) on your server.\n2. Create your **Coolify apps** (client, server, and database).\n   - You can run the database with Coolify on the same server, but you can run the database directly on your server or use a managed database service.\n3. In Coolify, set up the **server app env variables**.\n   - You can set up the env variables in the Coolify UI, check out which [env variables are required](../env-vars.md).\n4. Set up some sort of **CI/CD** (for example [Github Actions](https://github.com/features/actions)) to:\n   - build and upload your Docker images,\n   - trigger Coolify to pull the Docker images and deploy them.\n5. Point your domain to your server's IP address.\n   - We recommend setting `myapp.com` for the client and `api.myapp.com` for the server.\n   - Make sure to set the domains in the Coolify UI for the client and the server apps.\n   - Make sure to set the env variables for the client and the server URLs correctly.\n\nCheck out one of our step-by-step guides for more details:\n\n<GuideLink linkToGuide=\"https://gist.github.com/infomiho/ad6fade7396498ae32a931ca563a4524\" title=\"Deploying Wasp with Coolify on your server\" description=\"Uses Coolify, Github Actions, Github Container Registry\" />\n\n#### CapRover\n\n[CapRover](https://caprover.com/) is a deployment tool (self-hosted PaaS) that you run on your server. It makes it easier to deploy multple apps on your server. It has a nice looking UI and it helps you with managing your deployments.\n\n##### Overview of the steps\n\n1. Install [CapRover](https://caprover.com/) on your server.\n2. Create your CapRover apps (client, server, and database).\n   - You can run the database with CapRover on the same server, but you can run the database directly on your server or use a managed database service.\n3. Set up the server env variables.\n   - You can set up the env variables in the CapRover UI, check out which [env variables are required](../env-vars.md).\n4. Set up some sort of **CI/CD** (for example [Github Actions](https://github.com/features/actions)) to:\n   - build and upload your Docker images to a Docker registry,\n   - trigger CapRover to pull the Docker images and deploy them.\n5. Point your domain to your server's IP address.\n   - We recommend setting `myapp.com` for the client and `api.myapp.com` for the server.\n   - Make sure to set the domains in the CapRover UI for the client and the server apps.\n   - Make sure to set the env variables for the client and the server URLs correctly.\n\nCheck out one of our step-by-step guides for more details:\n\n<GuideLink linkToGuide=\"https://gist.github.com/infomiho/a853e2f92aff6d52e9120b8974887464\" title=\"Deploying Wasp with Caprover on your server\" description=\"Uses Caprover, Github Actions, Github Container Registry\" />\n\n### Database setup\n\nIn all of the guides, we run the **database on your server**. When you run the database on your server, you need to take care of backups, updates, and scaling. We suggest setting up [PostgresSQL periodic backups](https://tembo.io/docs/getting-started/postgres_guides/how-to-backup-and-restore-a-postgres-database) and/or taking snapshots of your server's disk. In case something bad happens to your server, you can restore your database from the backups.\n\nIf you prefer not to manage the database yourself, you can use a **managed database service**. The service provider takes care of backups, updates, and scaling for you but it can be more expensive than running the database on your server. Some popular managed database services are [AWS RDS](https://aws.amazon.com/rds/), [DigitalOcean Managed Databases](https://www.digitalocean.com/products/managed-databases/), and [Supabase](https://supabase.io/).\n\n## CI/CD Scenarios\n\nSetting up a CI/CD pipeline is an optional but highly recommended part of deploying applications.\n\n**Continuous Integration (CI)** involves verifying/testing code changes through an automated process whenever code is pushed to the repository. This helps us catch bugs early and make sure that our app works.\n\n**Continuous Deployment (CD)** refers to the automatic deployment of code changes to the production environment. This is commonly know as \"push to deploy\" and frees developers from having to manually deploy code changes.\n\n### Running tests in CI\n\n#### End to end tests\n\nEnd to end (e2e) tests simulate real user using your app and you can test different scenarios like login, adding items to cart, etc. Writing end to end tests frees you from\nmanually testing your app after every change.\n\n**To run e2e tests with Wasp in the CI**, you'll need to:\n\n1. Install Wasp in the CI environment.\n2. Run your app (with the database) in the CI environment.\n3. Run the e2e tests against the running app.\n\n##### Example app\n\nWe'll show you how to run end-to-end tests in CI using the [Github Actions](https://github.com/features/actions) as our CI and the [Playwright](https://playwright.dev/) as our e2e testing framework.\n\n1. Check our example app and its e2e tests in the [e2e-tests](https://github.com/wasp-lang/e2e-test-example/tree/main/e2e-tests) directory.\n\n   You can copy the `e2e-tests` directory to your own project and modify it to fit your app. This will enable you to run the e2e tests locally.\n\n   <details>\n     <summary>Example e2e test</summary>\n\n     ```ts\n     import { expect, test } from '@playwright/test'\n     import { generateRandomUser, logUserIn } from './utils'\n\n     const user = generateRandomUser()\n\n     test.describe('basic user flow test', () => {\n       test('log in and add task', async ({ page }) => {\n         await logUserIn({ page, user })\n         await expect(page).toHaveURL('/')\n         await expect(page.locator('body')).toContainText('No tasks yet.')\n\n         // Add a task\n         await page.fill('input[name=\"description\"]', 'First task')\n         await page.click('input:has-text(\"Create task\")')\n         await expect(page.locator('body')).toContainText('First task')\n       })\n     })\n     ```\n   </details>\n\n2. To run the tests in the Github Actions CI, you'll need to create a workflow file in your repository.\n\n   You should create a `.github/workflows/e2e-tests.yml` file in your repository. You can copy the contents of the [e2e-tests.yml](https://github.com/wasp-lang/e2e-test-example/blob/main/.github/workflows/e2e-tests.yml) file from our example app.\n\n#### Unit tests\n\nUnit tests test pieces of your code logic in isolation. They are much simpler and faster than e2e tests, but they don't simulate the real user interaction with your app.\n\nYou can use Wasp's built in [client tests](../project/testing.md) support to test the client side code of your app. You are free to use any testing framework for the server side code.\n\n**You'd run the unit tests in the CI** in a similar way as the e2e tests:\n\n1. Install Wasp in the CI environment.\n2. Run the client tests with `wasp test client run`.\n3. Run the server tests with your testing framework.\n\n### Continuous deployment\n\nWe'll look at two ways you can use the CI/CD pipeline to deploy your Wasp app:\n\n1. Package the server and client with Docker.\n2. Deploy the client as static files.\n\n#### Package the server and client with Docker\n\nThe most common way to package your app for deployment is using Docker images. This way you can easily deploy the same image to different environments (staging, production, etc.).\n\n**To build the app as a Docker image**, you'll need to:\n\n1. Install Docker in the CD environment.\n2. Build the app with `wasp build`.\n3. Build the Docker image and push it to a Docker registry:\n   - for our server app\n   - for our client app\n4. For some providers: notify them to deploy the new app version.\n\n:::info What is a Docker Registry?\n\nDocker Registry is a place where you can store your Docker images and then your deployment provider can pull them from there. The most common Docker Registry is the [Docker Hub](https://hub.docker.com/), but you can also use other registries like the [Github Container Registry (GHCR)](https://docs.github.com/en/packages/guides/about-github-container-registry).\n\n:::\n\n##### Example deployment\n\nWe'll take a look at our Coolify deployment example in the [deployment](./deployment-methods/self-hosted.md#coolify) section. We are using Github Actions to build the Docker images and their Github Container Registry (GHCR) to store them.\n\nLet's go through the [deploy.yml](https://gist.github.com/infomiho/ad6fade7396498ae32a931ca563a4524#file-deploy-yml) file in the Coolify guide:\n\n1. First, we **authenticate with the Github Container Registry (GHCR)**.\n\n   We are using the `docker/login-action` action to authenticate with the GHCR.\n\n2. Then, we **prepare the Docker image metadata** for later use.\n\n   We are using the `docker/metadata-action` action to prepare some extra info that we'll use later in the deployment process.\n\n3. Next, we **build the Wasp app** with `wasp build`.\n\n   This gives our server and the client app in the `.wasp/build` folder.\n\n4. Then, we **package the server app** into a Docker image and **push it to the GHCR**.\n\n   We use the `Dockerfile` in the `.wasp/build` directory to build and push the server Docker image using the `docker/build-push-action` action.\n\n5. Next, we create a `Dockerfile` for our client and then **package the client app** into a Docker image and **push it to the GHCR**.\n\n   We create a `Dockerfile` that uses a simple Go static server to serve the client app. We again use the `docker/build-push-action` action to build and push the client Docker image.\n\n6. Finally, we notify Coolify using their Webhook API to **deploy our new app version**.\n\n   And now you can open the [deploy.yml](https://gist.github.com/infomiho/ad6fade7396498ae32a931ca563a4524#file-deploy-yml) file in the Coolify guide and see the full d",
        "namespace": "xtasker",
        "timestamp": 1754702896044
      },
      {
        "key": "waspfull_ak",
        "value": "eployment process.\n\n#### Static build of the client\n\nWasp's client app is a single page application (SPA) which you build into static HTML, CSS, and JS files that you can upload to any hosting provider that supports serving static files. This means that for the client app, you don't need to use Docker images if don't want to. It's usually cheaper to host static files than to host Docker images.\n\n**To deploy the client app as static files**, you'll need to:\n\n1. Build the app with `wasp build` in the CD environment.\n2. Build the client app with `npm run build`.\n3. Upload the static files to your hosting provider.\n\nCheck out our instructions for deploying the client app to [Netlify](./deployment-methods/paas.md#netlify) or [Cloudflare](./deployment-methods/paas.md#cloudflare) where you can check out the example deployment using Github Actions.\n\n## Extras\n\nIn this section, we will cover some additional topics that are important for deploying Wasp apps in production.\n\n#### Custom domain setup\n\nIf you want to set up a custom domain for your Wasp app, you can do it for both the client and the server.\n\nThe important part is setting up the custom domain for the client - that's what your users visit from their browsers. Setting up a custom domain for the server is optional, but it can be useful if you'd like to hide some server details (for example, the IP address or auto-generated domain name) from the users.\n\n##### How to do it?\n\nIt's usually a two-step process, and it's the same for both the client and the server:\n\n1. Set up the **DNS records** for the domain.\n\n   This will depend on your hosting provider. You can usually do this by adding an `A` record in your DNS settings that points to the app's IPv4 address. You often set the `AAAA` record for IPv6 address as well. Some hosting providers ask you to set the `CNAME` record instead of the `A` and `AAAA` records.\n\n:::note Using `wasp deploy`?\n\nCheck out how to do it with [Fly](./deployment-methods/cli.md#fly-custom-domain) if you are using Fly.io or [Railway](./deployment-methods/cli.md#railway-custom-domain) if you are using Railway.\n\n:::\n\n2. Set up the **environment variables** for the app.\n\n   You need to set the environment variables so Wasp configures the app correctly (for example, for CORS to work correctly).\n\n   #### Client domain env vars\n\n   When [building the client](./env-vars.md#client-env-vars), set `REACT_APP_API_URL` to point to your server domain:\n\n   ```bash\n   REACT_APP_API_URL=https://api.myapp.com\n   ```\n\n   <small>\n     Learn more about client configuration in the [env vars section](../project/env-vars.md#client-general-configuration).\n   </small>\n\n   #### Server domain env vars\n\n   For the server, you need to [configure two variables](./env-vars.md#server-env-vars):\n\n   - `WASP_WEB_CLIENT_URL`: Your client app's domain\n   - `WASP_SERVER_URL`: Your server domain\n\n   <br />\n\n   ```bash\n   WASP_WEB_CLIENT_URL=https://myapp.com\n   WASP_SERVER_URL=https://server.myapp.com\n   ```\n\n   <small>\n     Learn more about server env variables in the [env vars section](../project/env-vars.md#server-general-configuration).\n   </small>\n\n#### DDoS protection and CDN recommendations\n\nWhen deploying your Wasp app, you might want to consider using a Content Delivery Network (CDN) and DDoS protection service to improve the performance and security of your app:\n\n1. **Content Delivery Network (CDN)** is a network of servers distributed worldwide that caches static assets like images, CSS, and JavaScript files.\n\n   Using a CDN in front of your **client** can help with caching static assets and serving them faster to users around the world. When a user requests a file, the CDN serves it from the server closest to the user, improving load times.\n\n2. **Distributed Denial of Service (DDoS)** attacks are a common threat to web applications.\n\n   Attackers send a large amount of traffic to your server, overwhelming it and making it unavailable to legitimate users. You can use a DDoS protection service for both your **client and server** to protect your app from these attacks.\n\nWe recommend using [Cloudflare](https://www.cloudflare.com/) for both CDN and DDoS protection. It's easy to set up and provides a free tier that should be enough for most small to medium-sized apps.\n\nThere are other CDN providers like [Fastly](https://www.fastly.com/), [Bunny](https://bunnycdn.com/) and [Amazon Cloudfront](https://aws.amazon.com/cloudfront/) that you can consider as well.\n\n#### Are Wasp apps production ready?\n\nAs we mentioned in the [introduction](./intro.md) section, what we call **Wasp apps** are three separate pieces: the client, the server, and the database.\n\nFor the server, we are using Node.js and the battle-tested Express.js framework. For the database, we are using PostgreSQL, which is a powerful and reliable database system. For the client, we are using React and Vite, which are both widely used and well-maintained.\n\nEach of these pieces is production-ready on its own, and Wasp just makes it easy to connect them together. Keep in mind that Wasp is still considered beta software, so there might be some rough edges here and there.\n\n------\n\n# Wasp AI\n\n## Creating New App with AI\n\nWasp comes with its own AI: Wasp AI, aka Mage (**M**agic web **A**pp **GE**nerator).\n\nWasp AI allows you to create a new Wasp app **from only a title and a short description** (using GPT in the background)!\n\nThere are two main ways to create a new Wasp app with Wasp AI:\n\n1. Free, open-source online app [usemage.ai](https://usemage.ai).\n2. Running `wasp new` on your machine and picking AI generation. For this you need to provide your own OpenAI API keys, but it allows for more flexibility (choosing GPT models).\n\nThey both use the same logic in the background, so both approaches are equally \"smart\", the difference is just in the UI / settings.\n\n:::info\nWasp AI is an experimental feature. Apps that Wasp AI generates can have mistakes (proportional to their complexity), but even then they can often serve as a great starting point (once you fix the mistakes) or an interesting way to explore how to implement stuff in Wasp.\n:::\n\n### usemage.ai\n\n<ImgWithCaption source=\"img/gpt-wasp/how-it-works.gif\" caption=\"1. Describe your app 2. Pick the color 3. Generate your app 🚀\" />\n\n[Mage](https://usemage.ai) is an open-source app with which you can create new Wasp apps from just a short title and description.\n\nIt is completely free for you - it uses our OpenAI API keys and we take on the costs.\n\nOnce you provide an app title, app description, and choose some basic settings, your new Wasp app will be created for you in a matter of minutes and you will be able to download it to your machine and keep working on it!\n\nIf you want to know more, check this [blog post](/blog/2023/07/10/gpt-web-app-generator) for more details on how Mage works, or this [blog post](/blog/2023/07/17/how-we-built-gpt-web-app-generator) for a high-level overview of how we implemented it.\n\n### Wasp CLI\n\nYou can create a new Wasp app using Wasp AI by running `wasp new` in your terminal and picking AI generation.\n\nIf you don't have them set yet, `wasp` will ask you to provide (via ENV vars) your OpenAI API keys (which it will use to query GPT).\n\nThen, after providing a title and description for your Wasp app, the new app will be generated on your disk!\n\n![wasp-cli-ai-input](./wasp-ai-1.png)\n![wasp-cli-ai-generation](./wasp-ai-2.png)\n\n## Developing Existing App with AI\n\nWhile Wasp AI doesn't at the moment offer any additional help for developing your Wasp app with AI beyond initial generation, this is something we are exploring actively.\n\nIn the meantime, while waiting for Wasp AI to add support for this, we suggest checking out [aider](https://github.com/paul-gauthier/aider), which is an AI pair programming tool in your terminal. This is a third-party tool, not affiliated with Wasp in any way, but we and some of Wasp users have found that it can be helpful when working on Wasp apps.\n\n------\n\n# Advanced Features\n\n## Sending Emails\n\n## Sending Emails\n\nWith Wasp's email-sending feature, you can easily integrate email functionality into your web application.\n\n```wasp title=\"main.wasp\"\napp Example {\n  ...\n  emailSender: {\n    provider: <provider>,\n    defaultFrom: {\n      name: \"Example\",\n      email: \"hello@itsme.com\"\n    },\n  }\n}\n```\n\nChoose from one of the providers:\n\n- `Dummy` (development only),\n- `Mailgun`,\n- `SendGrid`\n- or the good old `SMTP`.\n\nOptionally, define the `defaultFrom` field, so you don't need to provide it whenever sending an email.\n\n### Sending Emails\n\nBefore jumping into details about setting up various providers, let's see how easy it is to send emails.\n\nYou import the `emailSender` that is provided by the `wasp/server/email` module and call the `send` method on it.\n\n```ts title=\"src/actions/sendEmail.ts\" auto-js\n\n// In some action handler...\nconst info = await emailSender.send({\n  from: {\n    name: \"John Doe\",\n    email: \"john@doe.com\",\n  },\n  to: \"user@domain.com\",\n  subject: \"Saying hello\",\n  text: \"Hello world\",\n  html: \"Hello <strong>world</strong>\",\n});\n```\n\nRead more about the `send` method in the [API Reference](#javascript-api).\n\nThe `send` method returns an object with the status of the sent email. It varies depending on the provider you use.\n\n### Providers\n\nWe'll go over all of the available providers in the next section. For some of them, you'll need to set up some env variables. You can do that in the `.env.server` file.\n\n#### Using the Dummy Provider\n\n<DummyProviderNote />\n\nTo speed up development, Wasp offers a `Dummy` email sender that `console.log`s the emails in the console. Since it doesn't send emails for real, it doesn't require any setup.\n\nSet the provider to `Dummy` in your `main.wasp` file.\n\n```wasp title=\"main.wasp\"\napp Example {\n  ...\n  emailSender: {\n    provider: Dummy,\n  }\n}\n```\n\n#### Using the SMTP Provider\n\nFirst, set the provider to `SMTP` in your `main.wasp` file.\n\n```wasp title=\"main.wasp\"\napp Example {\n  ...\n  emailSender: {\n    provider: SMTP,\n  }\n}\n```\n\nThen, add the following env variables to your `.env.server` file.\n\n```properties title=\".env.server\"\nSMTP_HOST=\nSMTP_USERNAME=\nSMTP_PASSWORD=\nSMTP_PORT=\n```\n\nMany transactional email providers (e.g. Mailgun, SendGrid but also others) can also use SMTP, so you can use them as well.\n\n#### Using the Mailgun Provider\n\nSet the provider to `Mailgun` in the `main.wasp` file.\n\n```wasp title=\"main.wasp\"\napp Example {\n  ...\n  emailSender: {\n    provider: Mailgun,\n  }\n}\n```\n\nThen, get the Mailgun API key and domain and add them to your `.env.server` file.\n\n##### Getting the API Key and Domain\n\n1. Go to [Mailgun](https://www.mailgun.com/) and create an account.\n2. Go to [Domains](https://app.mailgun.com/mg/sending/new-domain) and create a new domain.\n3. Copy the domain and add it to your `.env.server` file.\n4. Create a new Sending API key under `Send > Sending > Domain settings` and find `Sending API keys`.\n5. Copy the API key and add it to your `.env.server` file.\n\n```properties title=\".env.server\"\nMAILGUN_API_KEY=\nMAILGUN_DOMAIN=\n```\n\n##### Using the EU Region\n\nIf your domain region is in the EU, you need to set the `MAILGUN_API_URL` variable in your `.env.server` file:\n\n```properties title=\".env.server\"\nMAILGUN_API_URL=https://api.eu.mailgun.net\n```\n\n#### Using the SendGrid Provider\n\nSet the provider field to `SendGrid` in your `main.wasp` file.\n\n```wasp title=\"main.wasp\"\napp Example {\n  ...\n  emailSender: {\n    provider: SendGrid,\n  }\n}\n```\n\nThen, get the SendGrid API key and add it to your `.env.server` file.\n\n##### Getting the API Key\n\n1. Go to [SendGrid](https://sendgrid.com/) and create an account.\n2. Go to [API Keys](https://app.sendgrid.com/settings/api_keys) and create a new API key.\n3. Copy the API key and add it to your `.env.server` file.\n\n```properties title=\".env.server\"\nSENDGRID_API_KEY=\n```\n\n### API Reference\n\n#### `emailSender` dict\n\n```wasp title=\"main.wasp\"\napp Example {\n  ...\n  emailSender: {\n    provider: <provider>,\n    defaultFrom: {\n      name: \"Example\",\n      email: \"hello@itsme.com\"\n    },\n  }\n}\n```\n\nThe `emailSender` dict has the following fields:\n\n- `provider: Provider` Required!\n\n  The provider you want to use. Choose from `Dummy`, `SMTP`, `Mailgun` or `SendGrid`.\n\n  <DummyProviderNote />\n\n- `defaultFrom: dict`\n\n  The default sender's details. If you set this field, you don't need to provide the `from` field when sending an email.\n\n#### JavaScript API\n\nUsing the `emailSender` in <ShowForTs>Typescript</ShowForTs><ShowForJs>JavaScript</ShowForJs>:\n\n```ts title=\"src/actions/sendEmail.ts\" auto-js\n\n// In some action handler...\nconst info = await emailSender.send({\n  from: {\n    name: \"John Doe\",\n    email: \"john@doe.com\",\n  },\n  to: \"user@domain.com\",\n  subject: \"Saying hello\",\n  text: \"Hello world\",\n  html: \"Hello <strong>world</strong>\",\n});\n```\n\nThe `send` method accepts an object with the following fields:\n\n- `from: object`\n\n  The sender's details. If you set up `defaultFrom` field in the `emailSender` dict in Wasp file, this field is optional.\n\n  - `name: string`\n\n    The name of the sender.\n\n  - `email: string`\n\n    The email address of the sender.\n\n- `to: string` Required!\n\n  The recipient's email address.\n\n- `subject: string` Required!\n\n  The subject of the email.\n\n- `text: string` Required!\n\n  The text version of the email.\n\n- `html: string` Required!\n\n  The HTML version of the email\n\n## Recurring Jobs\n\nIn most web apps, users send requests to the server and receive responses with some data. When the server responds quickly, the app feels responsive and smooth.\n\nWhat if the server needs extra time to fully process the request? This might mean sending an email or making a slow HTTP request to an external API. In that case, it's a good idea to respond to the user as soon as possible and do the remaining work in the background.\n\nWasp supports background jobs that can help you with this:\n\n- Jobs persist between server restarts,\n- Jobs can be retried if they fail,\n- Jobs can be delayed until a future time,\n- Jobs can have a recurring schedule.\n\n### Using Jobs\n\n#### Job Definition and Usage\n\nLet's write an example Job that will print a message to the console and return a list of tasks from the database.\n\n1. Start by creating a Job declaration in your `.wasp` file:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    job mySpecialJob {\n      executor: PgBoss,\n      perform: {\n        fn: import { foo } from \"@src/workers/bar\"\n      },\n      entities: [Task],\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    job mySpecialJob {\n      executor: PgBoss,\n      perform: {\n        fn: import { foo } from \"@src/workers/bar\"\n      },\n      entities: [Task],\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n2. After declaring the Job, implement its worker function:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"src/workers/bar.js\"\n    export const foo = async ({ name }, context) => {\n      console.log(`Hello ${name}!`)\n      const tasks = await context.entities.Task.findMany({})\n      return { tasks }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/workers/bar.ts\"\n    import { type MySpecialJob } from 'wasp/server/jobs'\n    import { type Task } from 'wasp/entities'\n\n    type Input = { name: string; }\n    type Output = { tasks: Task[]; }\n\n    export const foo: MySpecialJob<Input, Output> = async ({ name }, context) => {\n      console.log(`Hello ${name}!`)\n      const tasks = await context.entities.Task.findMany({})\n      return { tasks }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n:::info The worker function\nThe worker function must be an `async` function. The function's return value represents the Job's result.\n\nThe worker function accepts two arguments:\n\n- `args`: The data passed into the job when it's submitted.\n- `context: { entities }`: The context object containing entities you put in the Job declaration.\n  :::\n\n<ShowForTs>\n  `MySpecialJob`  is a generic type Wasp generates to help you  correctly type the Job's worker function, ensuring type information about the function's arguments and return value. Read more about type-safe jobs in the [Javascript API section](#javascript-api).\n</ShowForTs>\n\n3. After successfully defining the job, you can submit work to be done in your [Operations](../data-model/operations/overview) or [setupFn](../project/server-config#setup-function) (or any other NodeJS code):\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"someAction.js\"\n    import { mySpecialJob } from 'wasp/server/jobs'\n\n    const submittedJob = await mySpecialJob.submit({ job: \"Johnny\" })\n\n    // Or, if you'd prefer it to execute in the future, just add a .delay().\n    // It takes a number of seconds, Date, or ISO date string.\n    await mySpecialJob\n      .delay(10)\n      .submit({ name: \"Johnny\" })\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"someAction.ts\"\n    import { mySpecialJob } from 'wasp/server/jobs'\n\n    const submittedJob = await mySpecialJob.submit({ job: \"Johnny\" })\n\n    // Or, if you'd prefer it to execute in the future, just add a .delay().\n    // It takes a number of seconds, Date, or ISO date string.\n    await mySpecialJob\n      .delay(10)\n      .submit({ name: \"Johnny\" })\n    ```\n  </TabItem>\n</Tabs>\n\nAnd that's it. Your job will be executed by `PgBoss` as if you called `foo({ name: \"Johnny\" })`.\n\nIn our example, `foo` takes an argument, but passing arguments to jobs is not a requirement. It depends on how you've implemented your worker function.\n\n#### Recurring Jobs\n\nIf you have work that needs to be done on some recurring basis, you can add a `schedule` to your job declaration:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp {6-9} title=\"main.wasp\"\n    job mySpecialJob {\n      executor: PgBoss,\n      perform: {\n        fn: import { foo } from \"@src/workers/bar\"\n      },\n      schedule: {\n        cron: \"0 * * * *\",\n        args: {=json { \"job\": \"args\" } json=} // optional\n      }\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp {6-9} title=\"main.wasp\"\n    job mySpecialJob {\n      executor: PgBoss,\n      perform: {\n        fn: import { foo } from \"@src/workers/bar\"\n      },\n      schedule: {\n        cron: \"0 * * * *\",\n        args: {=json { \"job\": \"args\" } json=} // optional\n      }\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nIn this example, you _don't_ need to invoke anything in <ShowForJs>JavaScript</ShowForJs><ShowForTs>Typescript</ShowForTs>. You can imagine `foo({ job: \"args\" })` getting automatically scheduled and invoked for you every hour.\n\n<!-- ### Getting the Job's Result\n\nWhen you submit a job, you get a `SubmittedJob` object back. It has a `jobId` field, which you can use to get the job's result. -->\n\n### Job executors\n\nWasp supports Jobs through the use of **job executors**. A job executor is responsible for handling the scheduling, monitoring, and execution of jobs.\n\nCurrently, Wasp only has support for one job executor, `PgBoss`.\n\n#### `PgBoss` {#pgboss}\n\n[`PgBoss`](https://github.com/timgit/pg-boss/tree/8.4.2) is a lightweight job queue built on top of PostgreSQL. It is suitable for low-volume production use cases and does not require any additional infrastructure or complex management. By using PostgreSQL (and [SKIP LOCKED](https://www.2ndquadrant.com/en/blog/what-is-select-skip-locked-for-in-postgresql-9-5/)) as its storage and synchronization mechanism, you get many benefits of a traditional job queue, on top of your existing Postgres database.\n\n##### Requirements\n\n`PgBoss` requires that your database provider is set to `\"postgresql\"` in your `schema.prisma` file. Read more about setting the provider [here](../data-model/databases.md#postgresql).\n\n##### Limitations\n\n`PgBoss` runs together with your web server, whenever it is up. This means that it is not a separate process or service, but rather a part of your web server's application. As such, it is not suitable for CPU-heavy workloads, as it shares the CPU with your web server's application logic.\n\nThe `PgBoss` executor in Wasp does not (yet) support independent, horizontal scaling of pg-boss-only applications, nor starting them as separate workers/processes/threads. This means that your server must be running whenever you want to process jobs. If you need to scale your job processing, you will need to run multiple instances of your web server, each with its own `PgBoss` instance.\n\n##### Customization {#pg_boss_new_options}\n\nIf you need to customize the creation of the `PgBoss` instance, you can set an environment variable called `PG_BOSS_NEW_OPTIONS` to a stringified JSON object containing the initialization parameters. See the [pg-boss documentation](https://github.com/timgit/pg-boss/tree/8.4.2/docs#newoptions).\n\nPlease note that setting `PG_BOSS_NEW_OPTIONS` environment variable overwrites all Wasp defaults, so you must include the `connectionString` parameter inside it as well.\n\nFor example, to set the connection string and change the job archival and deletion settings, you can set the environment variable like this:\n\n```bash\n## In an .env file\nPG_BOSS_NEW_OPTIONS={\"connectionString\":\"postgresql://user:password@server:5432/database\",\"archiveCompletedAfterSeconds\":86400,\"deleteAfterDays\":30,\"maintenanceIntervalMinutes\":5}\n\n## In the shell\nPG_BOSS_NEW_OPTIONS='{\"connectionString\":\"postgresql://user:password@server:5432/database\",\"archiveCompletedAfterSeconds\":86400,\"deleteAfterDays\":30,\"maintenanceIntervalMinutes\":5}'\n```\n\nYou can read more about escaping JSON in environment variables in the [JSON Env Vars documentation](../project/env-vars.md#json-env-vars).\n\n##### Database setup\n\n:::tip You don't need to set up the database manually\n\nWhen using `PgBoss`, the database setup is automatically taken care of by the Wasp server, and doesn't need to be reflected in your schemas or migrations. The following information is given for your reference, and is explained in more detail in [the `PgBoss` documentation](https://github.com/timgit/pg-boss/blob/8.4.2/docs/readme.md).\n\n:::\n\nAll job data will be stored in a separate database schema called `pgboss`. It has some internal tracking tables, such as `job`, `archive`, and `schedule`. `PgBoss` tables have a `name` column in most tables that will correspond to your Job identifier. Additionally, these tables maintain arguments, states, return values, retry information, start and expiration times, and other metadata required by `PgBoss`.\n\n##### Known issues\n\n- **Renaming scheduled jobs**\n\n    The job name/identifier in your `.wasp` file is the same name that will be used in the `name` column of `pgboss` tables. If you change a name that had a `schedule` associated with it, pg-boss will continue scheduling those jobs but they will have no handlers associated, and will thus become stale and expire. To resolve this, you can remove the applicable row from the `pgboss.schedule` table.\n\n    For example, if you renamed a job from `emailReminder` to `sendEmailReminder`, you would need to remove the old scheduled job with the following SQL query:\n\n    ```sql\n    BEGIN;\n    DELETE FROM pgboss.schedule WHERE name = 'emailReminder';\n    COMMIT;\n    ```\n\n    **Important:** Only modify the database directly if you're comfortable with SQL operations. If you're unsure, consider keeping the old job name or restarting with a fresh database in development.\n\n##### Job data retention and cleanup\n\nBy default, `PgBoss` keeps job data for 12 hours after completion or failure. After that, it moves the data to an archive table, where it is kept for 7 days before being deleted. If you want to change this behavior, you can configure the `PG_BOSS_NEW_OPTIONS` environment variable to set custom values for job archival ([`archivedCompletedAfterSeconds`/`archiveFailedAfterSeconds`](https://github.com/timgit/pg-boss/tree/8.4.2/docs#newoptions:~:text=v1%22%20or%20%22v4%22-,archiveCompletedAfterSeconds,-Specifies%20how%20long)) and removal ([`deleteAfterSeconds`/`deleteAfterMinutes`/etc](https://github.com/timgit/pg-boss/tree/8.4.2/docs#newoptions:~:text=the%20skew%20warnings.-,Archive%20options,-When%20jobs%20in)).\n\n```bash\nPG_BOSS_NEW_OPTIONS={\"connectionString\":\"...your postgress connection url...\",\"archiveCompletedAfterSeconds\":86400,\"deleteAfterDays\":30,\"maintenanceIntervalMinutes\":5}\n```\n\n### API Reference\n\n#### Declaring Jobs\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"main.wasp\"\n    job mySpecialJob {\n      executor: PgBoss,\n      perform: {\n        fn: import { foo } from \"@src/workers/bar\",\n        executorOptions: {\n          pgBoss: {=json { \"retryLimit\": 1 } json=}\n        }\n      },\n      schedule: {\n        cron: \"*/5 * * * *\",\n        args: {=json { \"foo\": \"bar\" } json=},\n        executorOptions: {\n          pgBoss: {=json { \"retryLimit\": 0 } json=}\n        }\n      },\n      entities: [Task],\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"main.wasp\"\n    job mySpecialJob {\n      executor: PgBoss,\n      perform: {\n        fn: import { foo } from \"@src/workers/bar\",\n        executorOptions: {\n          pgBoss: {=json { \"retryLimit\": 1 } json=}\n        }\n      },\n      schedule: {\n        cron: \"*/5 * * * *\",\n        args: {=json { \"foo\": \"bar\" } json=},\n        executorOptions: {\n          pgBoss: {=json { \"retryLimit\": 0 } json=}\n        }\n      },\n      entities: [Task],\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThe Job declaration has the following fields:\n\n- `executor: JobExecutor` Required!\n\n  The job executor to use for this job. Currently, the only supported executor is [`PgBoss`](#pgboss).\n\n- `perform: dict` Required!\n\n  - `fn: ExtImport` Required!\n\n    - An `async` function that performs the work. Since Wasp executes Jobs on the server, the import path must lead to a NodeJS file.\n    - It receives the following arguments:\n      - `args: Input`: The data passed to the job when it's submitted.\n      - `context: { entities: Entities }`: The context object containing any declared entities.\n\n    Here's an example of a `perform.fn` function:\n\n    <Tabs groupId=\"js-ts\">\n      <TabItem value=\"js\" label=\"JavaScript\">\n        ```js title=\"src/workers/bar.js\"\n        export const foo = async ({ name }, context) => {\n          console.log(`Hello ${name}!`)\n          const tasks = await context.entities.Task.findMany({})\n          return { tasks }\n        }\n        ```\n      </TabItem>\n\n      <TabItem value=\"ts\" label=\"TypeScript\">\n        ```ts title=\"src/workers/bar.ts\"\n        import { type MySpecialJob } from 'wasp/server/jobs'\n\n        type Input = { name: string; }\n        type Output = { tasks: Task[]; }\n\n        export const foo: MySpecialJob<Input, Output> = async ({ name }, context) => {\n          console.log(`Hello ${name}!`)\n          const tasks = await context.entities.Task.findMany({})\n          return { tasks }\n        }\n        ```\n\n        Read more about type-safe jobs in the [Javascript API section](#javascript-api).\n      </TabItem>\n    </Tabs>\n\n  - `executorOptions: dict`\n\n    Executor-specific default options to use when submitting jobs. These are passed directly through and you should consult the documentation for the job executor. These can be overridden during invocation with `submit()` or in a `schedule`.\n\n    - `pgBoss: JSON`\n\n      See the docs for [pg-boss](https://github.com/timgit/pg-boss/blob/8.4.2/docs/readme.md#sendname-data-options).\n\n- `schedule: dict`\n\n  - `cron: string` Required!\n\n    A 5-placeholder format cron expression string. See rationale for minute-level precision [here](https://github.com/timgit/pg-boss/blob/8.4.2/docs/readme.md#scheduling).\n\n    _If you need help building cron expressions, Check out_ <em>[Crontab guru](https://crontab.guru/#0_*_*_*_*).</em>\n\n  - `args: JSON`\n\n    The arguments to pass to the `perform.fn` function when invoked.\n\n  - `executorOptions: dict`\n\n    Executor-specific options to use when submitting jobs. These are passed directly through and you should consult the documentation for the job executor. The `perform.executorOptions` are the default options, and `schedule.executorOptions` can override/extend those.\n\n    - `pgBoss: JSON`\n\n      See the docs for [pg-boss](https://github.com/timgit/pg-boss/blob/8.4.2/docs/readme.md#sendname-data-options).\n\n- `entities: [Entity]`\n\n  A list of entities you wish to use inside your Job (similar to [Queries and Actions](../data-model/operations/queries#using-entities-in-queries)).\n\n#### JavaScript API\n\n- Importing a Job:\n\n  <Tabs groupId=\"js-ts\">\n    <TabItem value=\"js\" label=\"JavaScript\">\n      ```js title=\"someAction.js\"\n      import { mySpecialJob } from 'wasp/server/jobs'\n      ```\n    </TabItem>\n\n    <TabItem value=\"ts\" label=\"TypeScript\">\n      ```ts title=\"someAction.ts\"\n      import { mySpecialJob, type MySpecialJob } from 'wasp/server/jobs'\n      ```\n\n      :::info Type-safe jobs\n      Wasp generates a generic type for each Job declaration, which you can use to type your `perform.fn` function. The type is named after the job declaration, and is available in the `wasp/server/jobs` module. In the example above, the type is `MySpecialJob`.\n\n      The type takes two type arguments:\n\n      - `Input`: The type of the `args` argument of the `perform.fn` function.\n      - `Output`: The type of the return value of the `perform.fn` function.\n        :::\n    </TabItem>\n  </Tabs>\n\n- `submit(jobArgs, executorOptions)`\n\n  - `jobArgs: Input`\n  - `executorOptions: object`\n\n  Submits a Job to be executed by an executor, optionally passing in a JSON job argument your job handler function receives, and executor-specific submit options.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"someAction.js\"\n    const submittedJob = await mySpecialJob.submit({ job: \"args\" })\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```js title=\"someAction.ts\"\n    const submittedJob = await mySpecialJob.submit({ job: \"args\" })\n    ```\n  </TabItem>\n</Tabs>\n\n- `delay(startAfter)`\n\n  - `startAfter: int | string | Date` Required!\n\n  Delaying the invocation of the job handler. The delay can be one of:\n\n  - Integer: number of seconds to delay. \\[Default 0]\n  - String: ISO date string to run at.\n  - Date: Date to run at.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js title=\"someAction.js\"\n    const submittedJob = await mySpecialJob\n      .delay(10)\n      .submit({ job: \"args\" }, { \"retryLimit\": 2 })\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"someAction.ts\"\n    const submittedJob = await mySpecialJob\n      .delay(10)\n      .submit({ job: \"args\" }, { \"retryLimit\": 2 })\n    ```\n  </TabItem>\n</Tabs>\n\n##### Tracking\n\nThe return value of `submit()` is an instance of `SubmittedJob`, which has the following fields:\n\n- `jobId`: The ID for the job in that executor.\n- `jobName`: The name of the job you used in your `.wasp` file.\n- `executorName`: The Symbol of the name of the job executor.\n\nThere are also some namespaced, job executor-specific objects.\n\n- For pg-boss, you may access: `pgBoss`\n  - `details()`: pg-boss specific job detail information. [Reference](https://github.com/timgit/pg-boss/blob/8.4.2/docs/readme.md#getjobbyidid)\n  - `cancel()`: attempts to cancel a job. [Reference](https://github.com/timgit/pg-boss/blob/8.4.2/docs/readme.md#cancelid)\n  - `resume()`: attempts to resume a canceled job. [Reference](https://github.com/timgit/pg-boss/blob/8.4.2/docs/readme.md#resumeid)\n\n## Web Sockets\n\nWasp provides a fully integrated WebSocket experience by utilizing [Socket.IO](https://socket.io/) on the client and server.\n\nWe handle making sure your URLs are correctly setup, CORS is enabled, and provide a useful `useSocket` and `useSocketListener` abstractions for use in React components.\n\nTo get started, you need to:\n\n1. Define your WebSocket logic on the server.\n2. Enable WebSockets in your Wasp file, and connect it with your server logic.\n3. Use WebSockets on the client, in React, via `useSocket` and `useSocketListener`.\n4. Optionally, type the WebSocket events and payloads for full-stack type safety.\n\nLet's go through setting up WebSockets step by step, starting with enabling WebSockets in your Wasp file.\n\n### Turn On WebSockets in Your Wasp File\n\nWe specify that we are using WebSockets by adding `webSocket` to our `app` and providing the required `fn`. You can optionally change the auto-connect behavior.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"todoApp.wasp\"\n    app todoApp {\n      // ...\n\n      webSocket: {\n        fn: import { webSocketFn } from \"@src/webSocket\",\n        autoConnect: true, // optional, default: true\n      },\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"todoApp.wasp\"\n    app todoApp {\n      // ...\n\n      webSocket: {\n        fn: import { webSocketFn } from \"@src/webSocket\",\n        autoConnect: true, // optional, default: true\n      },\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n### Defining the Events Handler\n\nLet's define the WebSockets server with all of the events and handler functions.\n\n<ShowForTs>\n  :::info Full-stack type safety\n  Check this out: we'll define the event types and payloads on the server, and they will be **automatically exposed on the client**. This helps you avoid mistakes when emitting events or handling them.\n  :::\n</ShowForTs>\n\n#### `webSocketFn` Function\n\nOn the server, you will get Socket.IO `io: Server` argument and `context` for your WebSocket function. The `context` object give you access to all of the entities from your Wasp app.\n\nYou can use this `io` object to register callbacks for all the regular [Socket.IO events](https://socket.io/docs/v4/server-api/).  Also, if a user is logged in, you will have a `socket.data.user` on the server.\n\nThis is how we can define our `webSocketFn` function:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```ts title=\"src/webSocket.js\"\n    import { v4 as uuidv4 } from 'uuid'\n    import { getFirstProviderUserId } from 'wasp/auth'\n\n    export const webSocketFn = (io, context) => {\n      io.on('connection', (socket) => {\n        const username = getFirstProviderUserId(socket.data.user) ?? 'Unknown'\n        console.log('a user connected: ', username)\n\n        socket.on('chatMessage', async (msg) => {\n          console.log('message: ', msg)\n          io.emit('chatMessage', { id: uuidv4(), username, text: msg })\n          // You can also use your entities here:\n          // await context.entities.SomeEntity.create({ someField: msg })\n        })\n      })\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts title=\"src/webSocket.ts\"\n    import { v4 as uuidv4 } from 'uuid'\n    import { getFirstProviderUserId } from 'wasp/auth'\n    import { type WebSocketDefinition, type WaspSocketData } from 'wasp/server/webSocket'\n\n    export const webSocketFn: WebSocketFn = (io, context) => {\n      io.on('connection', (socket) => {\n        const username = getFirstProviderUserId(socket.data.user) ?? 'Unknown'\n        console.log('a user connected: ', username)\n\n        socket.on('chatMessage', async (msg) => {\n          console.log('message: ', msg)\n          io.emit('chatMessage', { id: uuidv4(), username, text: msg })\n          // You can also use your entities here:\n          // await context.entities.SomeEntity.create({ someField: msg })\n        })\n      })\n    }\n\n    // Typing our WebSocket function with the events and payloads\n    // allows us to get type safety on the client as well\n\n    type WebSocketFn = WebSocketDefinition<\n      ClientToServerEvents,\n      ServerToClientEvents,\n      InterServerEvents,\n      SocketData\n    >\n\n    interface ServerToClientEvents {\n      chatMessage: (msg: { id: string, username: string, text: string }) => void;\n    }\n\n    interface ClientToServerEvents {\n      chatMessage: (msg: string) => void;\n    }\n\n    interface InterServerEvents {}\n\n    // Data that is attached to the socket.\n    // NOTE: Wasp automatically injects the JWT into the connection,\n    // and if present/valid, the server adds a user to the socket.\n    interface SocketData extends WaspSocketData {}\n    ```\n  </TabItem>\n</Tabs>\n\n### Using the WebSocket On The Client\n\n<ShowForTs>\n  :::info Full-stack type safety\n  All the hooks we use are typed with the events and payloads you defined on the server. VS Code will give you autocomplete for the events and payloads, and you will get type errors if you make a mistake.\n  :::\n</ShowForTs>\n\n#### The `useSocket` Hook\n\nClient access to WebSockets is provided by the `useSocket` hook. It returns:\n\n- `socket: Socket` for sending and receiving events.\n- `isConnected: boolean` for showing a display of the Socket.IO connection status.\n  - Note: Wasp automatically connects and establishes a WebSocket connection from the client to the server by default, so you do not need to explicitly `socket.connect()` or `socket.disconnect()`.\n  - If you set `autoConnect: false` in your Wasp file, then you should call these as needed.\n\nAll components using `useSocket` share the same underlying `socket`.\n\n#### The `useSocketListener` Hook\n\nAdditionally, there is a `useSocketListener: (event, callback) => void` hook which is used for registering event handlers. It takes care of unregistering the handler on unmount.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```tsx title=\"src/ChatPage.jsx\"\n    import React, { useState } from 'react'\n    import {\n      useSocket,\n      useSocketListener,\n    } from 'wasp/client/webSocket'\n\n    export const ChatPage = () => {\n      const [messageText, setMessageText] = useState('')\n      const [messages, setMessages] = useState([])\n      const { socket, isConnected } = useSocket()\n\n      useSocketListener('chatMessage', logMessage)\n\n      function logMessage(msg) {\n        setMessages((priorMessages) => [msg, ...priorMessages])\n      }\n\n      function handleSubmit(e) {\n        e.preventDefault()\n        socket.emit('chatMessage', messageText)\n        setMessageText('')\n      }\n\n      const messageList = messages.map((msg) => (\n        <li key={msg.id}>\n          <em>{msg.username}</em>: {msg.text}\n        </li>\n      ))\n      const connectionIcon = isConnected ? '🟢' : '🔴'\n\n      return (\n        <>\n          <h2>Chat {connectionIcon}</h2>\n          <div>\n            <form onSubmit={handleSubmit}>\n              <div>\n                <div>\n                  <input\n                    type=\"text\"\n                    value={messageText}\n                    onChange={(e) => setMessageText(e.target.value)}\n                  />\n                </div>\n                <div>\n                  <button type=\"submit\">Submit</button>\n                </div>\n              </div>\n            </form>\n            <ul>{messageList}</ul>\n          </div>\n        </>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    Wasp's **full-stack type safety** kicks in here: all the event types and payloads are automatically inferred from the server and are available on the client.\n\n    You can additionally use the `ClientToServerPayload` and `ServerToClientPayload` helper types to get the payload type for a specific event.\n\n    ```tsx title=\"src/ChatPage.tsx\"\n    import React, { useState } from 'react'\n    import {\n      useSocket,\n      useSocketListener,\n      ServerToClientPayload,\n    } from 'wasp/client/webSocket'\n\n    export const ChatPage = () => {\n      const [messageText, setMessageText] = useState<\n        // We are using a helper type to get the payload type for the \"chatMessage\" event.\n        ClientToServerPayload<'chatMessage'>\n      >('')\n      const [messages, setMessages] = useState<\n        ServerToClientPayload<'chatMessage'>[]\n      >([])\n      // The \"socket\" instance is typed with the types you defined on the server.\n      const { socket, isConnected } = useSocket()\n\n      // This is a type-safe event handler: \"chatMessage\" event and its payload type\n      // are defined on the server.\n      useSocketListener('chatMessage', logMessage)\n\n      function logMessage(msg: ServerToClientPayload<'chatMessage'>) {\n        setMessages((priorMessages) => [msg, ...priorMessages])\n      }\n\n      function handleSubmit(e: React.FormEvent<HTMLFormElement>) {\n        e.preventDefault()\n        // This is a type-safe event emitter: \"chatMessage\" event and its payload type\n        // are defined on the server.\n        socket.emit('chatMessage', messageText)\n        setMessageText('')\n      }\n\n      const messageList = messages.map((msg) => (\n        <li key={msg.id}>\n          <em>{msg.username}</em>: {msg.text}\n        </li>\n      ))\n      const connectionIcon = isConnected ? '🟢' : '🔴'\n\n      return (\n        <>\n          <h2>Chat {connectionIcon}</h2>\n          <div>\n            <form onSubmit={handleSubmit}>\n              <div>\n                <div>\n                  <input\n                    type=\"text\"\n                    value={messageText}\n                    onChange={(e) => setMessageText(e.target.value)}\n                  />\n                </div>\n                <div>\n                  <button type=\"submit\">Submit</button>\n                </div>\n              </div>\n            </form>\n            <ul>{messageList}</ul>\n          </div>\n        </>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n### API Reference\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp title=\"todoApp.wasp\"\n    app todoApp {\n      // ...\n\n      webSocket: {\n        fn: import { webSocketFn } from \"@src/webSocket\",\n        autoConnect: true, // optional, default: true\n      },\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp title=\"todoApp.wasp\"\n    app todoApp {\n      // ...\n\n      webSocket: {\n        fn: import { webSocketFn } from \"@src/webSocket\",\n        autoConnect: true, // optional, default: true\n      },\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThe `webSocket` dict has the following fields:\n\n- `fn: WebSocketFn` Required!\n\n  The function that defines the WebSocket events and handlers.\n\n- `autoConnect: bool`\n\n  Whether to automatically connect to the WebSocket server. Default: `true`.\n\n## Accessing the configuration\n\nWhenever you start a Wasp app, you are starting two processes.\n\n- **The client process** - A React app that implements your app's frontend.\n\n  During development, this is a dev server with hot reloading. In production,\n  it's a simple process that serves pre-built static files with environment variables\n  embedded during the build (details depend on [how you deploy it](../deployment/intro.md)).\n\n- **The server process** - An Express server that implements your app's backend.\n\n  During development, this is an Express server controlled by a\n  [`nodemon`](https://www.npmjs.com/package/nodemon) process that takes care of\n  hot reloading and restarts. In production, it's a regular Express server run\n  using Node.\n\nCheck [the introduction](/introduction/introduction.md) for a more in-depth explanation of Wasp's runtime architecture.\n\nYou can configure both processes through environment variables. See [the deployment instructions](../project/env-vars.md) for a full list of supported variables.\n\nWasp gives you runtime access to the processes' configurations through **configuration objects**.\n\n### Server configuration object\n\nThe server configuration object contains these fields:\n\n- `frontendUrl: String` - Set it with env var `WASP_WEB_CLIENT_URL`.\n\n  The URL of your client (the app's frontend).<br />\n  Wasp automatically sets it during development when you run `wasp start`.<br />\n  In production, you should set it to your client's URL as the server sees it\n  (i.e., with the DNS and proxies considered).\n\nYou can access it like this:\n\n```js\n\nconsole.log(config.frontendUrl)\n```\n\n### Client configuration object\n\nThe client configuration object contains these fields:\n\n- `apiUrl: String` - Set it with env var `REACT_APP_API_URL`\n\n  The URL of your server (the app's backend).<br />\n  Wasp automatically sets it during development when you run `wasp start`.<br />\n  In production, it should contain the value of your server's URL as the user's browser\n  sees it (i.e., with the DNS and proxies considered).\n\nYou can access it like this:\n\n```js\n\nconsole.log(config.apiUrl)\n```\n\n## Custom HTTP API Endpoints\n\nIn Wasp, the default client-server interaction mechanism is through [Operations](../data-model/operations/overview). However, if you need a specific URL method/path, or a specific response, Operations may not be suitable for you. For these cases, you can use an `api`. Best of all, they should look and feel very familiar.\n\n### How to Create an API\n\nAPIs are used to tie a JS function to a certain endpoint e.g. `POST /something/special`. They are distinct from Operations and have no client-side helpers (like `useQuery`).\n\nTo create a Wasp API, you must:\n\n1. Declare the API in Wasp using the `api` declaration\n2. Define the API's NodeJS implementation\n\nAfter completing these two steps, you'll be able to call the API from the client code (via our `Axios` wrapper), or from the outside world.\n\n#### Declaring the API in Wasp\n\nFirst, we need to declare the API in the Wasp file and you can easily do this with the `api` declaration:\n\n```wasp title=\"main.wasp\"\n// ...\n\napi fooBar { // APIs and their implementations don't need to (but can) have the same name.\n  fn: import { fooBar } from \"@src/apis\",\n  httpRoute: (GET, \"/foo/bar\")\n}\n```\n\nRead more about the supported fields in the [API Reference](#api-reference).\n\n#### Defining the API's NodeJS Implementation\n\n<ShowForTs>\n  :::note\n  To make sure the Wasp compiler generates the types for APIs for use in the NodeJS implementation, you should add your `api` declarations to your `.wasp` file first _and_ keep the `wasp start` command running.\n  :::\n</ShowForTs>\n\nAfter you defined the API, it should be implemented as a NodeJS function that takes three arguments:\n\n1. `req`: Express Request object\n2. `res`: Express Response object\n3. `context`: An additional context object **injected into the API by Wasp**. This object contains user session information, as well as information about entities. The examples here won't use the context for simplicity purposes. You can read more about it in the [section about using entities in APIs](#using-entities-in-apis).\n\n```ts title=\"src/apis.ts\" auto-js\n\nexport const fooBar: FooBar = (req, res, context) => {\n  res.set(\"Access-Control-Allow-Origin\", \"*\"); // Example of modifying headers to override Wasp default CORS middleware.\n  res.json({ msg: `Hello, ${context.user ? \"registered user\" : \"stranger\"}!` });\n};\n```\n\n<ShowForTs>\n  :::note\n  The `FooBar` type is generated by Wasp based on the `api` declaration above.\n  :::\n\n  #### Providing Extra Type Information\n\n  We'll see how we can provide extra type information to an API function.\n\n  Let's say you wanted to create some `GET` route that would take an email address as a param, and provide them the answer to \"Life, the Universe and Everything.\" 😀 What would this look like in TypeScript?\n\n  Define the API in Wasp:\n\n  ```wasp title=\"main.wasp\"\n  api fooBar {\n    fn: import { fooBar } from \"@src/apis\",\n    entities: [Task],\n    httpRoute: (GET, \"/foo/bar/:email\")\n  }\n  ```\n\n  We can use the `FooBar` type to which we'll provide the generic **params** and **response** types, which then gives us full type safety in the implementation.\n\n  ```ts title=\"src/apis.ts\"\n  import { FooBar } from \"wasp/server/api\";\n\n  export const fooBar: FooBar<\n    { email: string }, // params\n    { answer: number } // response\n  > = (req, res, _context) => {\n    console.log(req.params.email);\n    res.json({ answer: 42 });\n  };\n  ```\n</ShowForTs>\n\n### Using the API\n\n#### Using the API externally\n\nTo use the API externally, you simply call the endpoint using the method and path you used.\n\nFor example, if your app is running at `https://example.com` then from the above you could issue a `GET` to `https://example/com/foo/callback` (in your browser, Postman, `curl`, another web service, etc.).\n\n#### Using the API from the Client\n\nTo use the API from your client, including with auth support, you can import the Axios wrapper from `wasp/client/api` and invoke a call. For example:\n\n```tsx title=\"src/pages/SomePage.tsx\" auto-js with-hole\n\nasync function fetchCustomRoute() {\n  const res = await api.get(\"/foo/bar\");\n  console.log(res.data);\n}\n\nexport const Foo = () => {\n  useEffect(() => {\n    fetchCustomRoute();\n  }, []);\n\n  return <>{$HOLE$}</>;\n};\n```\n\n##### Making Sure CORS Works\n\nAPIs are designed to be as flexible as possible, hence they don't utilize the default middleware like Operations do. As a result, to use these APIs on the client side, you must ensure that CORS (Cross-Origin Resource Sharing) is enabled.\n\nYou can do this by defining custom middleware for your APIs in the Wasp file.\n\nFor example, an `apiNamespace` is a simple declaration used to apply some `middlewareConfigFn` to all APIs under some specific path:\n\n```wasp title=\"main.wasp\"\napiNamespace fooBar {\n  middlewareConfigFn: import { fooBarNamespaceMiddlewareFn } from \"@src/apis\",\n  path: \"/foo\"\n}\n```\n\nAnd then in the implementation file (returning the default config):\n\n```ts title=\"src/apis.ts\" auto-js\n\nexport const apiMiddleware: MiddlewareConfigFn = (config) => {\n  return config;\n};\n```\n\nWe are returning the default middleware which enables CORS for all APIs under the `/foo` path.\n\nFor more information about middleware configuration, please see: [Middleware Configuration](../advanced/middleware-config)\n\n### Using Entities in APIs\n\nIn many cases, resources used in APIs will be [Entities](../data-model/entities.md).\nTo use an Entity in your API, add it to the `api` declaration in Wasp:\n\n```wasp {3} title=\"main.wasp\"\napi fooBar {\n  fn: import { fooBar } from \"@src/apis\",\n  entities: [Task],\n  httpRoute: (GET, \"/foo/bar\")\n}\n```\n\nWasp will inject the specified Entity into the APIs `context` argument, giving you access to the Entity's Prisma API:\n\n```ts title=\"src/apis.ts\" auto-js\n\nexport const fooBar: FooBar = async (req, res, context) => {\n  res.json({ count: await context.entities.Task.count() });\n};\n```\n\nThe object `context.entities.Task` exposes `prisma.task` from [Prisma's CRUD API](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud).\n\n### API Reference\n\n```wasp title=\"main.wasp\"\napi fooBar {\n  fn: import { fooBar } from \"@src/apis\",\n  httpRoute: (GET, \"/foo/bar\"),\n  entities: [Task],\n  auth: true,\n  middlewareConfigFn: import { apiMiddleware } from \"@src/apis\"\n}\n```\n\nThe `api` declaration has the following fields:\n\n- `fn: ExtImport` Required!\n\n  The import statement of the APIs NodeJs implementation.\n\n- `httpRoute: (HttpMethod, string)` Required!\n\n  The HTTP (method, path) pair, where the method can be one of:\n\n  - `ALL`, `GET`, `POST`, `PUT` or `DELETE`\n  - and path is an Express path `string`.\n\n-",
        "namespace": "xtasker",
        "timestamp": 1754702900518
      },
      {
        "key": "waspfull_al",
        "value": " `entities: [Entity]`\n\n  A list of entities you wish to use inside your API. You can read more about it [here](#using-entities-in-apis).\n\n- `auth: bool`\n\n  If auth is enabled, this will default to `true` and provide a `context.user` object. If you do not wish to attempt to parse the JWT in the Authorization Header, you should set this to `false`.\n\n- `middlewareConfigFn: ExtImport`\n\n  The import statement to an Express middleware config function for this API. See more in [middleware section](../advanced/middleware-config) of the docs.\n\n## Configuring Middleware\n\nWasp comes with a minimal set of useful Express middleware in every application. While this is good for most users, we realize some may wish to add, modify, or remove some of these choices both globally, or on a per-`api`/path basis.\n\n### Default Global Middleware 🌍\n\nWasp's Express server has the following middleware by default:\n\n- [Helmet](https://helmetjs.github.io/): Helmet helps you secure your Express apps by setting various HTTP headers. _It's not a silver bullet, but it's a good start._\n- [CORS](https://github.com/expressjs/cors#readme): CORS is a package for providing a middleware that can be used to enable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) with various options.\n\n  :::note\n  CORS middleware is required for the frontend to communicate with the backend.\n  :::\n- [Morgan](https://github.com/expressjs/morgan#readme): HTTP request logger middleware.\n- [express.json](https://expressjs.com/en/api.html#express.json) (which uses [body-parser](https://github.com/expressjs/body-parser#bodyparserjsonoptions)): parses incoming request bodies in a middleware before your handlers, making the result available under the `req.body` property.\n\n  :::note\n  JSON middleware is required for [Operations](../data-model/operations/overview) to function properly.\n  :::\n- [express.urlencoded](https://expressjs.com/en/api.html#express.urlencoded) (which uses [body-parser](https://expressjs.com/en/resources/middleware/body-parser.html#bodyparserurlencodedoptions)): returns middleware that only parses urlencoded bodies and only looks at requests where the `Content-Type` header matches the type option.\n- [cookieParser](https://github.com/expressjs/cookie-parser#readme): parses Cookie header and populates `req.cookies` with an object keyed by the cookie names.\n\n### Customization\n\nYou have three places where you can customize middleware:\n\n1. [global](#1-customize-global-middleware): here, any changes will apply by default _to all operations (`query` and `action`) and `api`._ This is helpful if you wanted to add support for multiple domains to CORS, for example.\n\n:::caution Modifying global middleware\nPlease treat modifications to global middleware with extreme care as they will affect all operations and APIs. If you are unsure, use one of the other two options.\n:::\n\n2. [per-api](#2-customize-api-specific-middleware): you can override middleware for a specific api route (e.g. `POST /webhook/callback`). This is helpful if you want to disable JSON parsing for some callback, for example.\n3. [per-path](#3-customize-per-path-middleware): this is helpful if you need to customize middleware for all methods under a given path.\n   - It's helpful for things like \"complex CORS requests\" which may need to apply to both `OPTIONS` and `GET`, or to apply some middleware to a _set of `api` routes_.\n\n#### Default Middleware Definitions\n\nBelow is the actual definitions of default middleware which you can override.\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```js\n    const defaultGlobalMiddleware = new Map([\n      ['helmet', helmet()],\n      ['cors', cors({ origin: config.allowedCORSOrigins })],\n      ['logger', logger('dev')],\n      ['express.json', express.json()],\n      ['express.urlencoded', express.urlencoded()],\n      ['cookieParser', cookieParser()]\n    ])\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```ts\n    export type MiddlewareConfig = Map<string, express.RequestHandler>\n\n    // Used in the examples below 👇\n    export type MiddlewareConfigFn = (middlewareConfig: MiddlewareConfig) => MiddlewareConfig\n\n    const defaultGlobalMiddleware: MiddlewareConfig = new Map([\n      ['helmet', helmet()],\n      ['cors', cors({ origin: config.allowedCORSOrigins })],\n      ['logger', logger('dev')],\n      ['express.json', express.json()],\n      ['express.urlencoded', express.urlencoded()],\n      ['cookieParser', cookieParser()]\n    ])\n    ```\n  </TabItem>\n</Tabs>\n\n### 1. Customize Global Middleware\n\nIf you would like to modify the middleware for _all_ operations and APIs, you can do something like:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp {6} title=\"main.wasp\"\n    app todoApp {\n      // ...\n\n      server: {\n        middlewareConfigFn: import { serverMiddlewareFn } from \"@src/serverSetup\"\n      },\n    }\n    ```\n\n    ```ts title=\"src/serverSetup.js\"\n    import cors from 'cors'\n    import { config } from 'wasp/server'\n\n    export const serverMiddlewareFn = (middlewareConfig) => {\n      // Example of adding extra domains to CORS.\n      middlewareConfig.set('cors', cors({ origin: [config.frontendUrl, 'https://example1.com', 'https://example2.com'] }))\n      return middlewareConfig\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp {6} title=\"main.wasp\"\n    app todoApp {\n      // ...\n\n      server: {\n        middlewareConfigFn: import { serverMiddlewareFn } from \"@src/serverSetup\"\n      },\n    }\n    ```\n\n    ```ts title=\"src/serverSetup.ts\"\n    import cors from 'cors'\n    import { config, type MiddlewareConfigFn } from 'wasp/server'\n\n    export const serverMiddlewareFn: MiddlewareConfigFn = (middlewareConfig) => {\n      // Example of adding an extra domains to CORS.\n      middlewareConfig.set('cors', cors({ origin: [config.frontendUrl, 'https://example1.com', 'https://example2.com'] }))\n      return middlewareConfig\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n### 2. Customize `api`-specific Middleware\n\nIf you would like to modify the middleware for a single API, you can do something like:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp {5} title=\"main.wasp\"\n    // ...\n\n    api webhookCallback {\n      fn: import { webhookCallback } from \"@src/apis\",\n      middlewareConfigFn: import { webhookCallbackMiddlewareFn } from \"@src/apis\",\n      httpRoute: (POST, \"/webhook/callback\"),\n      auth: false\n    }\n    ```\n\n    ```ts title=\"src/apis.js\"\n    import express from 'express'\n\n    export const webhookCallback = (req, res, _context) => {\n      res.json({ msg: req.body.length })\n    }\n\n    export const webhookCallbackMiddlewareFn = (middlewareConfig) => {\n      console.log('webhookCallbackMiddlewareFn: Swap express.json for express.raw')\n\n      middlewareConfig.delete('express.json')\n      middlewareConfig.set('express.raw', express.raw({ type: '*/*' }))\n\n      return middlewareConfig\n    }\n\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp {5} title=\"main.wasp\"\n    // ...\n\n    api webhookCallback {\n      fn: import { webhookCallback } from \"@src/apis\",\n      middlewareConfigFn: import { webhookCallbackMiddlewareFn } from \"@src/apis\",\n      httpRoute: (POST, \"/webhook/callback\"),\n      auth: false\n    }\n    ```\n\n    ```ts title=\"src/apis.ts\"\n    import express from 'express'\n    import { type WebhookCallback } from 'wasp/server/api'\n    import { type MiddlewareConfigFn } from 'wasp/server'\n\n    export const webhookCallback: WebhookCallback = (req, res, _context) => {\n      res.json({ msg: req.body.length })\n    }\n\n    export const webhookCallbackMiddlewareFn: MiddlewareConfigFn = (middlewareConfig) => {\n      console.log('webhookCallbackMiddlewareFn: Swap express.json for express.raw')\n\n      middlewareConfig.delete('express.json')\n      middlewareConfig.set('express.raw', express.raw({ type: '*/*' }))\n\n      return middlewareConfig\n    }\n\n    ```\n  </TabItem>\n</Tabs>\n\n:::note\nThis gets installed on a per-method basis. Behind the scenes, this results in code like:\n\n```js\nrouter.post('/webhook/callback', webhookCallbackMiddleware, ...)\n```\n\n:::\n\n### 3. Customize Per-Path Middleware\n\nIf you would like to modify the middleware for all API routes under some common path, you can define a `middlewareConfigFn` on an `apiNamespace`:\n\n<Tabs groupId=\"js-ts\">\n  <TabItem value=\"js\" label=\"JavaScript\">\n    ```wasp {4} title=\"main.wasp\"\n    // ...\n\n    apiNamespace fooBar {\n      middlewareConfigFn: import { fooBarNamespaceMiddlewareFn } from \"@src/apis\",\n      path: \"/foo/bar\"\n    }\n    ```\n\n    ```ts title=\"src/apis.js\"\n    export const fooBarNamespaceMiddlewareFn = (middlewareConfig) => {\n      const customMiddleware = (_req, _res, next) => {\n        console.log('fooBarNamespaceMiddlewareFn: custom middleware')\n        next()\n      }\n\n      middlewareConfig.set('custom.middleware', customMiddleware)\n\n      return middlewareConfig\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"ts\" label=\"TypeScript\">\n    ```wasp {4} title=\"main.wasp\"\n    // ...\n\n    apiNamespace fooBar {\n      middlewareConfigFn: import { fooBarNamespaceMiddlewareFn } from \"@src/apis\",\n      path: \"/foo/bar\"\n    }\n    ```\n\n    ```ts title=\"src/apis.ts\"\n    import express from 'express'\n    import { type MiddlewareConfigFn } from 'wasp/server'\n\n    export const fooBarNamespaceMiddlewareFn: MiddlewareConfigFn = (middlewareConfig) => {\n      const customMiddleware: express.RequestHandler = (_req, _res, next) => {\n        console.log('fooBarNamespaceMiddlewareFn: custom middleware')\n        next()\n      }\n\n      middlewareConfig.set('custom.middleware', customMiddleware)\n\n      return middlewareConfig\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n:::note\nThis gets installed at the router level for the path. Behind the scenes, this results in something like:\n\n```js\nrouter.use('/foo/bar', fooBarNamespaceMiddleware)\n```\n\n:::\n\n## Type-Safe Links\n\nIf you are using Typescript, you can use Wasp's custom `Link` component to create type-safe links to other pages on your site.\n\n### Using the `Link` Component\n\nAfter you defined a route:\n\n```wasp title=\"main.wasp\"\nroute TaskRoute { path: \"/task/:id\", to: TaskPage }\npage TaskPage { ... }\n```\n\nYou can get the benefits of type-safe links by using the `Link` component from `wasp/client/router`:\n\n```jsx title=\"TaskList.tsx\"\n\nexport const TaskList = () => {\n  // ...\n\n  return (\n    <div>\n      {tasks.map((task) => (\n        <Link\n          key={task.id}\n          to=\"/task/:id\"\n          {/* 👆 You must provide a valid path here */}\n          params={{ id: task.id }}>\n          {/* 👆 All the params must be correctly passed in */}\n          {task.description}\n        </Link>\n      ))}\n    </div>\n  )\n}\n```\n\n#### Catch-all Routes\n\nIf a route path ends with a `/*` pattern (also known as [splat](https://reactrouter.com/en/main/route/route#splats)), you can use the `Link` component like this:\n\n```wasp title=\"main.wasp\"\nroute CatchAllRoute { path: \"/pages/*\", to: CatchAllPage }\npage CatchAllPage { ... }\n```\n\n```jsx title=\"TaskList.tsx\"\n<Link to=\"/pages/*\" params={{ '*': 'about' }}>\n  About\n</Link>\n```\n\nThis will result in a link like this: `/pages/about`.\n\n#### Optional Static Segments\n\nIf a route contains optional static segments, you'll need to specify one of the possible paths:\n\n```wasp title=\"main.wasp\"\nroute OptionalRoute { path: \"/task/:id/details?\", to: OptionalPage }\npage OptionalPage { ... }\n```\n\n```jsx title=\"TaskList.tsx\"\n/* You can include ... */\n<Link to=\"/task/:id/details\" params={{ id: 1 }}>\n  Task 1\n</Link>\n\n/* ... or exclude the optional segment */\n<Link to=\"/task/:id\" params={{ id: 1 }}>\n  Task 1\n</Link>\n```\n\n#### Using Search Query & Hash\n\nYou can also pass `search` and `hash` props to the `Link` component:\n\n```tsx title=\"TaskList.tsx\"\n<Link\n  to=\"/task/:id\"\n  params={{ id: task.id }}\n  search={{ sortBy: 'date' }}\n  hash=\"comments\"\n>\n  {task.description}\n</Link>\n```\n\nThis will result in a link like this: `/task/1?sortBy=date#comments`. Check out the [API Reference](#link-component) for more details.\n\n### The `routes` Object\n\nYou can also get all the pages in your app with the `routes` object:\n\n```jsx title=\"TaskList.tsx\"\n\nconst linkToTask = routes.TaskRoute.build({ params: { id: 1 } })\n```\n\nThis will result in a link like this: `/task/1`.\n\n#### Optional Static Segments\n\nIf a route contains optional static segments, you'll need to specify one of the possible paths:\n\n```wasp title=\"main.wasp\"\nroute OptionalRoute { path: \"/task/:id/details?\", to: OptionalPage }\npage OptionalPage { ... }\n```\n\n```tsx title=\"TaskList.tsx\"\nconst linkToOptional = routes.OptionalRoute.build({\n  path: '/task/:id/details', // or '/task/:id'\n  params: { id: 1 },\n})\n```\n\nYou can also pass `search` and `hash` props to the `build` function. Check out the [API Reference](#routes-object) for more details.\n\n### API Reference\n\n#### `Link` Component\n\nThe `Link` component accepts the following props:\n\n- `to` Required!\n\n  - A valid Wasp Route path from your `main.wasp` file.\n\n    In the case of optional static segments, you must provide one of the possible paths which include or exclude the optional segment. For example, if the path is `/task/:id/details?`, you must provide either `/task/:id/details` or `/task/:id`.\n\n- `params: { [name: string]: string | number }` Required! (if the path contains params)\n\n  - An object with keys and values for each param in the path.\n  - For example, if the path is `/task/:id`, then the `params` prop must be `{ id: 1 }`. Wasp supports required and optional params.\n\n- `search: string[][] | Record<string, string> | string | URLSearchParams`\n\n  - Any valid input for `URLSearchParams` constructor.\n  - For example, the object `{ sortBy: 'date' }` becomes `?sortBy=date`.\n\n- `hash: string`\n\n- all other props that the `react-router-dom`'s [Link](https://reactrouter.com/en/6.26.1/components/link) component accepts\n\n#### `routes` Object\n\nThe `routes` object contains a function for each route in your app.\n\n```ts title=\"router.tsx\"\nexport const routes = {\n  // RootRoute has a path like \"/\"\n  RootRoute: {\n    build: (options?: {\n      search?: string[][] | Record<string, string> | string | URLSearchParams\n      hash?: string\n    }) => // ...\n  },\n\n  // DetailRoute has a path like \"/task/:id/:userId?\"\n  DetailRoute: {\n    build: (\n      options: {\n        params: { id: ParamValue; userId?: ParamValue; },\n        search?: string[][] | Record<string, string> | string | URLSearchParams\n        hash?: string\n      }\n    ) => // ...\n  },\n\n  // OptionalRoute has a path like \"/task/:id/details?\"\n  OptionalRoute: {\n    build: (\n      options: {\n        path: '/task/:id/details' | '/task/:id',\n        params: { id: ParamValue },\n        search?: string[][] | Record<string, string> | string | URLSearchParams\n        hash?: string\n      }\n    ) => // ...\n  },\n\n  // CatchAllRoute has a path like \"/pages/*\"\n  CatchAllRoute: {\n    build: (\n      options: {\n        params: { '*': ParamValue },\n        search?: string[][] | Record<string, string> | string | URLSearchParams\n        hash?: string\n      }\n    ) => // ...\n  },\n}\n```\n\nThe `params` object is required if the route contains params. The `search` and `hash` parameters are optional.\n\nYou can use the `routes` object like this:\n\n```tsx\n\nconst linkToRoot = routes.RootRoute.build()\nconst linkToTask = routes.DetailRoute.build({ params: { id: 1 } })\nconst linkToOptional = routes.DetailRoute.build({\n  path: '/task/:id/details',\n  params: { id: 1 },\n})\nconst linkToCatchAll = routes.CatchAllRoute.build({\n  params: { '*': 'about' },\n})\n```\n\n------\n\n# General\n\n## Wasp Language (.wasp)\n\nWasp language (what you write in .wasp files) is a declarative, statically typed, domain-specific language (DSL).\n\n:::tip Wasp TS config \\[Early-preview feature]\nIf you wish, you can alternatively define your [Wasp config in TS](./wasp-ts-config.md) (`main.wasp.ts`) instead of `main.wasp`.\n:::\n\nIt is a quite simple language, closer to JSON, CSS or SQL than to e.g. Javascript or Python, since it is not a general programming language, but more of a configuration language.\n\nIt is pretty intuitive to learn (there isn't much to learn really!) and you can probably do just fine without reading this page and learning from the rest of the docs as you go, but if you want a bit more formal definition and deeper understanding of how it works, then read on!\n\n### Declarations\n\nThe central point of Wasp language are **declarations**, and Wasp code is at the end just a bunch of declarations, each of them describing a part of your web app.\n\n```wasp\napp MyApp {\n  title: \"My app\"\n}\n\nroute RootRoute { path: \"/\", to: DashboardPage }\n\npage DashboardPage {\n  component: import { DashboardPage } from \"@src/Dashboard.jsx\"\n}\n```\n\nIn the example above we described a web app via three declarations: `app MyApp { ... }`, `route RootRoute { ... }` and `page DashboardPage { ... }`.\n\nSyntax for writing a declaration is `<declaration_type> <declaration_name> <declaration_body>`, where:\n\n- `<declaration_type>` is one of the declaration types offered by Wasp (`app`, `route`, ...)\n- `<declaration_name>` is an identifier chosen by you to name this specific declaration\n- `<declaration_body>` is the value/definition of the declaration itself, which has to match the specific declaration body type expected by the chosen declaration type.\n\nSo, for `app` declaration above, we have:\n\n- declaration type `app`\n- declaration name `MyApp` (we could have used any other identifier, like `foobar`, `foo_bar`, or `hi3Ho`)\n- declaration body `{ title: \"My app\" }`, which is a dictionary with field `title` that has string value.\n  Type of this dictionary is in line with the declaration body type of the `app` declaration type.\n  If we provided something else, e.g. changed `title` to `little`, we would get a type error from Wasp compiler since that does not match the expected type of the declaration body for `app`.\n\nEach declaration has a meaning behind it that describes how your web app should behave and function.\n\nAll the other types in Wasp language (primitive types (`string`, `number`), composite types (`dict`, `list`), enum types (`DbSystem`), ...) are used to define the declaration bodies.\n\n### Complete List of Wasp Types\n\nWasp's type system can be divided into two main categories of types: **fundamental types** and **domain types**.\n\nWhile fundamental types are here to be basic building blocks of a language and are very similar to what you would see in other popular languages, domain types are what make Wasp special, as they model the concepts of a web app like `page`, `route` and similar.\n\n- Fundamental types ([source of truth](https://github.com/wasp-lang/wasp/blob/main/waspc/src/Wasp/Analyzer/Type.hs))\n  - Primitive types\n    - **string** (`\"foo\"`, `\"they said: \\\"hi\\\"\"`)\n    - **bool** (`true`, `false`)\n    - **number** (`12`, `14.5`)\n    - **declaration reference** (name of existing declaration: `TaskPage`, `updateTask`)\n    - **ExtImport** (external import) (`import Foo from \"@src/bar.js\"`, `import { Smth } from \"@src/a/b.js\"`)\n      - The path has to start with \"@src\". The rest is relative to the `src` directory.\n      - Import has to be a default import `import Foo` or a single named import `import { Foo }`.\n    - **json** (`{=json { a: 5, b: [\"hi\"] } json=}`)\n  - Composite types\n    - **dict** (dictionary) (`{ a: 5, b: \"foo\" }`)\n    - **list** (`[1, 2, 3]`)\n    - **tuple** (`(1, \"bar\")`, `(2, 4, true)`)\n      - Tuples can be of size 2, 3 and 4.\n- Domain types ([source of truth](https://github.com/wasp-lang/wasp/blob/main/waspc/src/Wasp/Analyzer/StdTypeDefinitions.hs))\n  - Declaration types\n    - **action**\n    - **api**\n    - **apiNamespace**\n    - **app**\n    - **job**\n    - **page**\n    - **query**\n    - **route**\n    - **crud**\n  - Enum types\n    - **DbSystem**\n    - **HttpMethod**\n    - **JobExecutor**\n    - **EmailProvider**\n  - Models from the `schema.prisma` file\n    - You can reference models defined in the `schema.prisma` file in your Wasp file by using the model name e.g. `Task`.\n\nYou can find more details about each of the domain types, both regarding their body types and what they mean, in the corresponding doc pages covering their features.\n\n## CLI Reference\n\nThis guide provides an overview of the Wasp CLI commands, arguments, and options.\n\n### Overview\n\nOnce [installed](../quick-start), you can use the wasp command from your command line.\n\nIf you run the `wasp` command without any arguments, it will show you a list of available commands and their descriptions:\n\n```\nUSAGE\n  wasp <command> [command-args]\n\nCOMMANDS\n  GENERAL\n    new [<name>] [args]   Creates a new Wasp project. Run it without arguments for interactive mode.\n      OPTIONS:\n        -t|--template <template-name>\n           Check out the templates list here: https://github.com/wasp-lang/starters\n\n    new:ai <app-name> <app-description> [<config-json>]\n      Uses AI to create a new Wasp project just based on the app name and the description.\n      You can do the same thing with `wasp new` interactively.\n      Run `wasp new:ai` for more info.\n\n    version               Prints current version of CLI.\n    waspls                Run Wasp Language Server. Add --help to get more info.\n    completion            Prints help on bash completion.\n    uninstall             Removes Wasp from your system.\n  IN PROJECT\n    start                 Runs Wasp app in development mode, watching for file changes.\n    start db              Starts managed development database for you.\n    db <db-cmd> [args]    Executes a database command. Run 'wasp db' for more info.\n    clean                 Deletes all generated code, all cached artifacts, and the node_modules dir.\n                          Wasp equivalent of 'have you tried closing and opening it again?'.\n    build                 Generates full web app code, ready for deployment. Use when deploying or ejecting.\n    deploy                Deploys your Wasp app to cloud hosting providers.\n    telemetry             Prints telemetry status.\n    deps                  Prints the dependencies that Wasp uses in your project.\n    dockerfile            Prints the contents of the Wasp generated Dockerfile.\n    info                  Prints basic information about the current Wasp project.\n    test                  Executes tests in your project.\n    studio                (experimental) GUI for inspecting your Wasp app.\n\nEXAMPLES\n  wasp new MyApp\n  wasp start\n  wasp db migrate-dev\n\nDocs: https://wasp.sh/docs\nDiscord (chat): https://discord.gg/rzdnErX\nNewsletter: https://wasp.sh/#signup\n```\n\n### Commands\n\n#### Creating a New Project\n\n- Use `wasp new` to start the interactive mode for setting up a new Wasp project.\n\nThis will prompt you to input the project name and to select a template. The chosen template will then be used to generate the project directory with the specified name.\n\n```\n$ wasp new\nEnter the project name (e.g. my-project) ▸ MyFirstProject\nChoose a starter template\n[1] basic (default)\n    Simple starter template with a single page.\n[2] todo-ts\n    Simple but well-rounded Wasp app implemented with Typescript & full-stack type safety.\n[3] saas\n    Everything a SaaS needs! Comes with Auth, ChatGPT API, Tailwind, Stripe payments and more. Check out https://opensaas.sh/ for more details.\n[4] embeddings\n    Comes with code for generating vector embeddings and performing vector similarity search.\n[5] ai-generated\n    🤖 Describe an app in a couple of sentences and have Wasp AI generate initial code for you. (experimental)\n▸ 1\n\n🐝 --- Creating your project from the \"basic\" template... -------------------------\n\nCreated new Wasp app in ./MyFirstProject directory!\n\nTo run your new app, do:\n    cd MyFirstProject\n    wasp db start\n```\n\n- To skip the interactive mode and create a new Wasp project with the default template, use `wasp new <project-name>`.\n\n```\n$ wasp new MyFirstProject\n\n🐝 --- Creating your project from the \"basic\" template... -------------------------\n\nCreated new Wasp app in ./MyFirstProject directory!\n\nTo run your new app, do:\ncd MyFirstProject\nwasp db start\n```\n\n#### Project Commands\n- `wasp start` launches the Wasp app in development mode. It automatically opens a browser tab with your application running and watches for any changes to .wasp or files in `src/` to automatically reflect in the browser. It also shows messages from the web app, the server and the database on stdout/stderr.\n- `wasp start db` starts the database for you. This can be very handy since you don't need to spin up your own database or provide its connection URL to the Wasp app.\n- `wasp clean` removes all generated code and other cached artifacts. If using SQlite, it also deletes the SQlite database. Think of this as the Wasp version of the classic \"turn it off and on again\" solution.\n\n```\n\n$ wasp clean\n\n🐝 --- Deleting the .wasp/ directory... -------------------------------------------\n\n✅ --- Deleted the .wasp/ directory. ----------------------------------------------\n\n🐝 --- Deleting the node\\_modules/ directory... ------------------------------------\n\n✅ --- Deleted the node\\_modules/ directory. ---------------------------------------\n\n```\n\n- `wasp build` generates the complete web app code, which is ready for [deployment](../deployment/intro.md). Use this command when you're deploying or ejecting. The generated code is stored in the `.wasp/build` folder.\n\n- `wasp deploy` makes it easy to get your app hosted on the web.\n\nCurrently, Wasp offers support for [Fly.io](https://fly.io) and [Railway](https://railway.com/). If you prefer a different hosting provider, feel free to let us know on Discord or submit a PR by updating [this TypeScript app](https://github.com/wasp-lang/wasp/tree/main/waspc/packages/deploy).\n\nRead more about automatic deployment [here](../deployment/deployment-methods/cli.md).\n\n- `wasp telemetry` displays the status of [telemetry](../telemetry.md).\n\n```\n\n$ wasp telemetry\n\nTelemetry is currently: ENABLED\nTelemetry cache directory: /home/user/.cache/wasp/telemetry/\nLast time telemetry data was sent for this project: 2021-05-27 09:21:16.79537226 UTC\nOur telemetry is anonymized and very limited in its scope: check https://wasp.sh/docs/telemetry for more details.\n\n```\n- `wasp deps` lists the dependencies that Wasp uses in your project.\n- `wasp info` provides basic details about the current Wasp project.\n- `wasp studio` shows you an graphical overview of your application in a graph: pages, queries, actions, data model etc.\n\n#### Database Commands\nWasp provides a suite of commands for managing the database. These commands all begin with `db` and primarily execute Prisma commands behind the scenes.\n\n- `wasp db migrate-dev` synchronizes the development database with the current state of the schema (entities). If there are any changes in the schema, it generates a new migration and applies any pending migrations to the database.\n- The `--name foo` option allows you to specify a name for the migration, while the `--create-only` option lets you create an empty migration without applying it.\n\n- `wasp db studio` opens the GUI for inspecting your database.\n\n:::caution using `prisma` CLI directly\n\nAlthough Wasp uses the `schema.prisma` file to define the database schema, you must not use the `prisma` command directly. Instead, use the `wasp db` commands.\n\nWasp adds some additional functionality on top of Prisma, and using `prisma` commands directly can lead to unexpected behavior e.g. missing auth models, incorrect database setup, etc.\n\n:::\n\n#### Bash Completion\n\nTo set up Bash completion, run the `wasp completion` command and follow the instructions.\n\n#### Miscellaneous Commands\n- `wasp version` displays the current version of the CLI.\n\n```\n\n$ wasp version\n\n0.14.0\n\nIf you wish to install/switch to the latest version of Wasp, do:\ncurl -sSL https://get.wasp.sh/installer.sh | sh -s\n\nIf you want specific x.y.z version of Wasp, do:\ncurl -sSL https://get.wasp.sh/installer.sh | sh -s -- -v x.y.z\n\nCheck https://github.com/wasp-lang/wasp/releases for the list of valid versions, including the latest one.\n\n```\n- `wasp uninstall` removes Wasp from your system.\n\n```\n\n$ wasp uninstall\n\n🐝 --- Uninstalling Wasp ... ------------------------------------------------------\n\nWe will remove the following directories:\n{home}/.local/share/wasp-lang/\n{home}/.cache/wasp/\n\nWe will also remove the following files:\n{home}/.local/bin/wasp\n\nAre you sure you want to continue? \\[y/N]\ny\n\n✅ --- Uninstalled Wasp -----------------------------------------------------------\n\n```\n\n## TypeScript Support\n\n## TypeScript support\n\nTypeScript is a programming language that adds static type analysis to JavaScript.\nIt is a superset of JavaScript, which means all JavaScript code is valid TypeScript code.\nIt also compiles to JavaScript before running.\n\nTypeScript's type system helps catch errors at build time (this reduces runtime errors), and provides type-based auto-completion in IDEs.\n\nEach Wasp feature includes TypeScript documentation.\n\nIf you're starting a new project and want to use TypeScript, you don't need to do anything special.\nJust follow the feature docs you are interested in, and they will tell you everything you need to know.\nWe recommend you start by going through [the tutorial](../tutorial/01-create.md).\n\nTo migrate an existing Wasp project from JavaScript to TypeScript, follow this guide.\n\n### Migrating your project to TypeScript\n\nSince Wasp ships with out-of-the-box TypeScript support, migrating your project is as simple as changing file extensions and using the language.\nThis approach allows you to gradually migrate your project on a file-by-file basis.\n\nWe will first show you how to migrate a single file and then help you generalize the procedure to the rest of your project.\n\n#### Migrating a single file\n\nAssuming your `schema.prisma` file defines the `Task` entity:\n\n```prisma title=\"schema.prisma\"\n// ...\n\nmodel Task {\n  id          Int @id @default(autoincrement())\n  description String\n  isDone      Boolean\n}\n```\n\nAnd your `main.wasp` file defines the `getTaskInfo` query:\n\n```wasp title=\"main.wasp\"\nquery getTaskInfo {\n  fn: import { getTaskInfo } from \"@src/queries\",\n  entities: [Task]\n}\n```\n\nWe will show you how to migrate the following `queries.js` file:\n\n```javascript title=\"src/queries.js\"\n\nfunction getInfoMessage(task) {\n  const isDoneText = task.isDone ? 'is done' : 'is not done'\n  return `Task '${task.description}' is ${isDoneText}.`\n}\n\nexport const getTaskInfo = async ({ id }, context) => {\n  const Task = context.entities.Task\n  const task = await Task.findUnique({ where: { id } })\n  if (!task) {\n    throw new HttpError(404)\n  }\n  return getInfoMessage(task)\n}\n```\n\nTo migrate this file to TypeScript, all you have to do is:\n\n1. Change the filename from `queries.js` to `queries.ts`.\n2. Write some types (and optionally use some of Wasp's TypeScript features).\n\n<Tabs>\n  <TabItem value=\"before\" label=\"Before\">\n    ```javascript title=\"src/queries.js\"\n    import HttpError from '@wasp/core/HttpError.js'\n\n    function getInfoMessage(task) {\n      const isDoneText = task.isDone ? 'is done' : 'is not done'\n      return `Task '${task.description}' is ${isDoneText}.`\n    }\n\n    export const getTaskInfo = async ({ id }, context) => {\n      const Task = context.entities.Task\n      const task = await Task.findUnique({ where: { id } })\n      if (!task) {\n        throw new HttpError(404)\n      }\n      return getInfoMessage(task)\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"after\" label=\"After\">\n    ```typescript title=\"src/queries.ts\"\n    import HttpError from 'wasp/server'\n    // highlight-next-line\n    import { type Task } from '@wasp/entities'\n    // highlight-next-line\n    import { type GetTaskInfo } from '@wasp/server/operations'\n\n    // highlight-next-line\n    function getInfoMessage(task: Pick<Task, 'isDone' | 'description'>): string {\n      const isDoneText = task.isDone ? 'is done' : 'is not done'\n      return `Task '${task.description}' is ${isDoneText}.`\n    }\n\n    // highlight-next-line\n    export const getTaskInfo: GetTaskInfo<Pick<Task, 'id'>, string> = async (\n      { id },\n      context\n    ) => {\n      const Task = context.entities.Task\n\n      const task = await Task.findUnique({ where: { id } })\n      if (!task) {\n        throw new HttpError(404)\n      }\n\n      return getInfoMessage(task)\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nYour code is now processed by TypeScript and uses several of Wasp's TypeScript-specific features:\n\n- `Task` - A type that represents the `Task` entity. Using this type connects your data to the model definitions in the `schema.prisma` file. Read more about this feature [here](../data-model/entities).\n- `GetTaskInfo<...>` - A generic type Wasp automatically generates to give you type\n  support when implementing the Query. Thanks to this type, the compiler knows:\n\n  - The type of the `context` object.\n  - The type of `args`.\n  - The Query's return type.\n\n  And gives you Intellisense and type-checking. Read more about this feature [here](../data-model/operations/queries#implementing-queries).\n\nYou don't need to change anything inside the `.wasp` file.\n\n#### Migrating the rest of the project\n\nYou can migrate your project gradually - on a file-by-file basis.\n\nWhen you want to migrate a file, follow the procedure outlined above:\n\n1. Change the file's extension.\n2. Fix the type errors.\n3. Read the Wasp docs and decide which TypeScript features you want to use.\n\n<TypescriptServerNote />\n\n## Wasp TypeScript config (*.wasp.ts)\n\n:::caution Requires Wasp >= 0.16.3\nThis document assumes your app works with Wasp >= 0.16.3.\\\nIf you haven't migrated your app yet, follow the [migration instructions](../migration-guides/migrate-from-0-15-to-0-16.md) and verify everything works. After that, come back here and try out the new Wasp TS config.\n:::\n\n:::caution Early preview\nThis feature is currently in early preview and we are actively working on it.\n:::\n\n:::caution Running `wasp ts-setup`\nWhenever you run run `wasp clean` or remove `node_modules` on  your own, you must rerun `wasp ts-setup`! We will remove this requirement in future versions. Read more about it below.\n:::\n\nIn Wasp, you normally define/configure the high level of your app (pages, routes, queries, actions, auth, ...) in a `main.wasp` file in the root of your project. In `main.wasp` you write in Wasp's DSL (domain-specific language), which is a simple configuration language similar to JSON but smarter.\n\nWasp recently introduced the **Wasp TS config**, an alternative way to define the high level of your app via `main.wasp.ts`! Although it looks similar to how you would do it in `main.wasp`, the difference is that you write in TypeScript, not in Wasp's DSL.\n\nWasp TS config is an **early preview** feature, meaning it is a little rough and not yet where it could be, but it does work. We think it's pretty cool already, and you can try it out now. If you do, please share your feedback and ideas with us on our [GitHub](https://github.com/wasp-lang/wasp) or <DiscordLink />. This is crucial for us to be able to shape this feature in the best possible way!\n\n### Motivation\n\n- Out-of-the-box support in all editors.\n- Less maintenance on our side.\n- More flexibility for you while writing the config.\n- It will enable us to easily add support for multiple Wasp files in the future.\n- A great foundation for the Full Stack Modules (FSM) that are a part of our future plans.\n\n### How to switch from the Wasp DSL config to the Wasp TS config\n\n1. Go into the Wasp project you want to switch to the Wasp TS config (or create a new Wasp project if you want to try it out like that). Make sure you are on Wasp >= 0.16.3 and your project is working.\n2. Rename `tsconfig.json` file to `tsconfig.src.json`\n3. Create a new `tsconfig.json` file with the following content:\n\n   ```json title=\"tsconfig.json\"\n   {\n     \"files\": [],\n     \"references\": [\n       { \"path\": \"./tsconfig.src.json\" },\n       { \"path\": \"./tsconfig.wasp.json\" }\n     ]\n   }\n   ```\n\n4. Create a new `tsconfig.wasp.json` file with the following content:\n\n   ```json title=\"tsconfig.wasp.json\"\n   {\n     \"compilerOptions\": {\n       \"skipLibCheck\": true,\n       \"target\": \"ES2022\",\n       \"isolatedModules\": true,\n       \"moduleDetection\": \"force\",\n\n       // linting\n       \"strict\": true,\n       \"noUnusedLocals\": true,\n       \"noUnusedParameters\": true,\n\n       \"module\": \"NodeNext\",\n       \"noEmit\": true,\n\n       \"lib\": [\"ES2023\"]\n     },\n     \"include\": [\"main.wasp.ts\"]\n   }\n   ```\n\n5. Add `\"type\": \"module\"` to the top level of your `package.json`, if you don't have it yet:\n\n   ```json title=\"package.json\"\n   {\n     \"type\": \"module\",\n     ...\n   }\n   ```\n\n6. Rename the `main.wasp` file to `main.wasp.old`. You'll want to use it as a reference while writing `main.wasp.ts`.\n\n7. Run `wasp clean` and `rm package-lock.json`. This ensures you start from a clean state.\n\n8. Run `wasp ts-setup`. This command will add the `wasp-config` package to your `package.json`'s `devDependencies`.\n\n   **IMPORTANT:** Every time you run `wasp clean` or delete your `node_modules`, you _must_ follow it up with `wasp ts-setup`. This is a temporary meassure until we improve the feature.\n\n9. Create an empty `main.wasp.ts` file and rewrite your `main.wasp.old` in it but in TypeScript.\n\n   Check out the [reference main.wasp.ts file](#reference-mainwaspts-file) below for details on what the TypeScript API for configuring Wasp looks like.\n   In short, you'll have to:\n\n   1. Import `App` from `wasp-config`\n   2. Create a new `app` object with `new App()`.\n   3. Use the `app` object to define parts of your web app like `auth`, `pages`, `query`, `api`...\n   4. Export the `app` from your file using a default export.\n\n   You can manually do the rewrite using the reference file and TS types as guides (IDE support should work for you in `main.wasp.ts`), or you can (and we recommend it!) give the reference main.wasp.ts file to the LLM of your choice and tell it to rewrite your `main.wasp` while following the format in the reference file: we had great results with this!\n\n10. Run `wasp start` to run your app! If you got everything right, your app should work exactly like it did before. The only difference is that it's now reading the Wasp config from `main.wasp.ts` instead of `main.wasp`.\n    :::tip\n    Don't forget, during `wasp start`, to have the database running or do the db migrations if needed, as you would normally when running your app in development.\n    :::\n\n11. That is it, you are now using Wasp TS config! You can delete `main.wasp.old` file now if you still have it around.\n\n:::caution\nIf you run `wasp clean` or remove `node_modules` on  your own, you will have to rerun `wasp ts-setup`! This is a temporary workaround, we will remove it in future versions.\n:::\n\nGot stuck on any of these steps? Let us know in our <DiscordLink /> and we will help!\n\n### What next?\n\n#### Experiment\n\nPlay with the Wasp TS config, get the feel of it, and see if you can find ways to improve it. Here are some ideas you can experiment with:\n\n- How would you reduce the boilerplate in `main.wasp.ts` file? Helper functions, loops?\n- Can you imagine a better API or better abstractions? If you can, what would that look like? Perhaps you can even implement it on top of our API?\n- Give a try at implementing your own file-based routing if that is what you like: you are now in Turing complete language and have access to the disk!\n- Surprise us!\n\n#### Feedback\n\nWhatever you end up doing, we would love it if you would let us know how it was and show us what you did.\n\nWe do have some immediate ideas of our own about what we want to improve, but we want to hear what you thought of, what you liked or disliked, or what you came up with. Even if you just found it all good, or just a single thing you didn't or did like, that is also valuable feedback and we would love to hear it!\n\nLet us know on our [GitHub](https://github.com/wasp-lang/wasp) or, even better, in our <DiscordLink />.\n\n### Reference main.wasp.ts file\n\n```ts title=\"main.wasp.ts\"\n\nconst app = new App('todoApp', {\n  title: 'ToDo App',\n  wasp: { version: '{latestWaspVersion}' },\n  // head: []\n});\n\napp.webSocket({\n  fn: { import: 'webSocketFn', from: '@src/webSocket' },\n  // autoConnect: false\n});\n\napp.auth({\n  userEntity: 'User',\n  methods: {\n    discord: {\n      configFn: { import: 'config', from: '@src/auth/discord' },\n      userSignupFields: { import: 'userSignupFields', from: '@src/auth/discord' }\n    },\n    google: {\n      configFn: { import: 'config', from: '@src/auth/google' },\n      userSignupFields: { import: 'userSignupFields', from: '@src/auth/google' }\n    },\n    gitHub: {\n      configFn: { import: 'config', from: '@src/auth/github.js' },\n      userSignupFields: { import: 'userSignupFields', from: '@src/auth/github.js' }\n    },\n    // keycloak: {},\n    // email: {\n    //   userSignupFields: { import: 'userSignupFields', from: '@src/auth/email' },\n    //   fromField: {\n    //     name: 'ToDO App',\n    //     email: 'mihovil@ilakovac.com'\n    //   },\n    //   emailVerification: {\n    //     getEmailContentFn: { import: 'getVerificationEmailContent', from: '@src/auth/email' },\n    //     clientRoute: 'EmailVerificationRoute',\n    //   },\n    //   passwordReset: {\n    //     getEmailContentFn: { import: 'getPasswordResetEmailContent', from: '@src/auth/email' },\n    //     clientRoute: 'PasswordResetRoute'\n    //   }\n    // },\n  },\n  onAuthFailedRedirectTo: '/login',\n  onAuthSucceededRedirectTo: '/profile',\n  onBeforeSignup: { import: 'onBeforeSignup', from: '@src/auth/hooks.js' },\n  onAfterSignup: { import: 'onAfterSignup', from: '@src/auth/hooks.js' },\n  onAfterEmailVerified: { import: 'onAfterEmailVerified', from: \"@src/auth/hooks.ts\" },\n  onBeforeOAuthRedirect: { import: 'onBeforeOAuthRedirect', from: '@src/auth/hooks.js' },\n  onBeforeLogin: { import: 'onBeforeLogin', from: '@src/auth/hooks.js' },\n  onAfterLogin: { import: 'onAfterLogin', from: '@src/auth/hooks.js' }\n});\n\napp.server({\n  setupFn: { importDefault: 'setup', from: '@src/serverSetup' },\n  middlewareConfigFn: { import: 'serverMiddlewareFn', from: '@src/serverSetup' },\n});\n\napp.client({\n  rootComponent: { import: 'App', from: '@src/App' },\n  setupFn: { importDefault: 'setup', from: '@src/clientSetup' }\n});\n\napp.db({\n  seeds: [\n    { import: 'devSeedSimple', from: '@src/dbSeeds' },\n  ]\n});\n\napp.emailSender({\n  provider: 'SMTP',\n  defaultFrom: { email: 'test@test.com' }\n});\n\nconst loginPage = app.page('LoginPage', {\n  component: { importDefault: 'Login', from: '@src/pages/auth/Login' }\n});\napp.route('LoginRoute', { path: '/login', to: loginPage });\n\napp.query('getTasks', {\n  fn: { import: 'getTasks', from: '@src/queries' },\n  entities: ['Task']\n});\n\napp.action('createTask', {\n  fn: { import: 'createTask', from: '@src/actions' },\n  entities: ['Task']\n});\n\napp.apiNamespace('bar', {\n  middlewareConfigFn: { import: 'barNamespaceMiddlewareFn', from: '@src/apis' },\n  path: '/bar'\n});\n\napp.api('barBaz', {\n  fn: { import: 'barBaz', from: '@src/apis' },\n  auth: false,\n  entities: ['Task'],\n  httpRoute: {\n    method: 'GET',\n    route: '/bar/baz',\n  },\n});\n\napp.job('mySpecialJob', {\n  executor: 'PgBoss',\n  perform: {\n    fn: { import: 'foo', from: '@src/jobs/bar' },\n    executorOptions: {\n      pgBoss: { retryLimit: 1 }\n    }\n  },\n  entities: ['Task']\n});\n\nexport default app;\n```\n\n------\n\n# Migration guides\n\n## Migration from 0.16.X to 0.17.X\n\n### What's new in 0.17.0?\n\n#### The `login` function parameters changed (username & password only)\n\n:::info\nThis change only affects you if you're using [username and password authentication](../auth/username-and-pass.md) with\n[custom auth UI](../auth/username-and-pass/create-your-own-ui.md). If you're using [email authentication](../auth/email.md),\n[social authentication](../auth/social-auth/overview.md), or our premade [Auth UI](../auth/ui.md) components,\nyou don't need to take any action.\n:::\n\nThe `login` function, as imported from `wasp/client/auth`, has changed\nthe way of calling it:\n\n<Tabs>\n<TabItem value=\"before\" label=\"Before\">\n\n```ts\n\nawait login(usernameValue, passwordValue);\n```\n\n</TabItem>\n<TabItem value=\"after\" label=\"After\">\n\n```ts\n\nawait login({ username: usernameValue, password: passwordValue });\n```\n\n</TabItem>\n</Tabs>\n\nThis is to make it consistent with the `login` and `signup` calls in other\nauthentication methods, which were already using this convention.\n\n#### Wasp no longer generates a default `favicon.ico`\n\nWasp will no longer generate `favicon.ico` if there isn't one in the `public` directory.\nAlso, Wasp will no longer generate a `<link>` meta tag in `index.html`. You'll need to define it yourself explicitly.\n\nNew Wasp projects come with a default `favicon.ico` in the `public` directory and the `<link>` meta tag in the `main.wasp` file.\n\n### How to migrate?\n\nTo migrate your Wasp app from 0.16.X to 0.17.X, follow these steps:\n\n#### 1. Change the parameters to the `login` function (username & password only)\n\n:::info\nThis change only affects you if you're using [username and password authentication](../auth/username-and-pass.md) with\n[custom auth UI](../auth/username-and-pass/create-your-own-ui.md). If you're using [email authentication](../auth/email.md),\n[social authentication](../auth/social-auth/overview.md), or our premade [Auth UI](../auth/ui.md) components,\nyou don't need to take any action.\n:::\n\nIf you were using the `login` function (imported from `wasp/client/auth`),\nchange its parameters from `login(usernameValue, passwordValue)` to\n`login({ username: usernameValue, password: passwordValue })`.\n\n<Tabs>\n<TabItem value=\"before\" label=\"Before\">\n\n```tsx title=\"src/components/MyLoginForm.tsx\"\n\nexport const MyLoginForm = () => {\n  const [usernameValue, setUsernameValue] = useState(\"\");\n  const [passwordValue, setPasswordValue] = useState(\"\");\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    await login(usernameValue, passwordValue);\n    // ...\n  };\n\n  return <form onSubmit={handleSubmit}>{/* ... */}</form>;\n};\n```\n\n</TabItem>\n<TabItem value=\"after\" label=\"After\">\n\n```tsx title=\"src/components/MyLoginForm.tsx\"\n\nexport const MyLoginForm = () => {\n  const [usernameValue, setUsernameValue] = useState(\"\");\n  const [passwordValue, setPasswordValue] = useState(\"\");\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    await login({ username: usernameValue, password: passwordValue });\n    // ...\n  };\n\n  return <form onSubmit={handleSubmit}>{/* ... */}</form>;\n};\n```\n\n</TabItem>\n</Tabs>\n\nIt is possible that you were not using this function in your code.\nIf you're instead using [the `<LoginForm>` component](../auth/ui.md#login-form),\nthis change is already handled for you.\n\n#### 2. Update your `tsconfig.json`\n\nTo ensure your project works correctly with Wasp 0.17.0, you must also update your\n`tsconfig.json` file.\n\nIf you haven't changed anything in your project's `tsconfig.json` file (this is\nthe case for most users), just replace its contents with the new version shown\nbelow.\n\nIf you have made changes to your `tsconfig.json` file, we recommend taking the\nnew version of the file and reapplying them.\n\nHere's the new version of `tsconfig.json`:\n\n```json title=\"tsconfig.json\"\n// =============================== IMPORTANT =================================\n// This file is mainly used for Wasp IDE support.\n//\n// Wasp will compile your code with slightly different (less strict) compilerOptions.\n// You can increase the configuration's strictness (e.g., by adding\n// \"noUncheckedIndexedAccess\": true), but you shouldn't reduce it (e.g., by\n// adding \"strict\": false). Just keep in mind that this will only affect your\n// IDE support, not the actual compilation.\n//\n// Full TypeScript configurability is coming very soon :)\n{\n  \"compilerOptions\": {\n    \"module\": \"esnext\",\n    \"composite\": true,\n    \"target\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"jsx\": \"preserve\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"isolatedModules\": true,\n    \"moduleDetection\": \"force\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"skipLibCheck\": true,\n    \"allowJs\": true,\n    \"outDir\": \".wasp/out/user\"\n  },\n  \"include\": [\"src\"]\n}\n```\n\n#### 3. Tell Wasp about `jest-dom` types\n\nIf you're using (or planning to use) Wasp's [client tests](../project/testing.md) with `jest-dom`,\nupdate your `src/vite-env.d.ts` file:\n\n```ts src/vite-env.d.ts {3-7}\n/// <reference types=\"vite/client\" />\n\n// This is needed to properly support Vitest testing with jest-dom matchers.\n// Types for jest-dom are not recognized automatically and Typescript complains\n// about missing types e.g. when using `toBeInTheDocument` and other matchers.\n// Reference: https://github.com/testing-library/jest-dom/issues/546#issuecomment-1889884843\n\n```\n\n#### 4. Add a `favicon.ico` to the `public` directory\n\nThis step is necessary only if you don't have a `favicon.ico` in your `public` folder.\nIf so, you should add a `favicon.ico` to your `public` folder.\n\nIf you want to keep the default, you can [download it here](https://raw.githubusercontent.com/wasp-lang/wasp/refs/heads/main/waspc/data/Cli/starters/skeleton/public/favicon.ico).\n\nIf you want to generate a `favicon.ico` and all its possible variants, check out [RealFaviconGenerator](https://realfavicongenerator.net/), a handy open-source tool for creating favicons.\n\n#### 5. Add a `<link>` meta tag for `favicon.ico`\n\nThis step is required for all of the project's which use `favicon.ico`.\nAdd the `<link>` meta tag to the `head` property in the `main.wasp`\n\n```wasp title=\"main.wasp\napp MyApp {\n  // ...\n  head: [\n    \"<link rel='icon' href='/favicon.ico' />\",\n  ]\n}\n```\n\n#### 6. Upgrade Express dependencies\n\nIf you had `express` or `@types/express` in your `package.json`, you should change them to use version 5:\n\n<Tabs>\n<TabItem value=\"before\" label=\"Before\">\n\n```json title=\"package.json\"\n{\n  \"dependencies\": {\n    \"express\": \"~4.21.0\"\n  },\n  \"devDependencies\": {\n    \"@types/express\": \"^4.17.13\"\n  }\n}\n```\n\n</TabItem>\n<TabItem value=\"after\" label=\"After\">\n\n```json title=\"package.json\"\n{\n  \"dependencies\": {\n    \"express\": \"~5.1.0\"\n  },\n  \"devDependencies\": {\n    \"@types/express\": \"^5.0.0\"\n  }\n}\n```\n\n</TabItem>\n</Tabs>\n\n#### 7. Upgrade your `api` endpoints to Express 5\n\nWasp now uses [Express v5](https://expressjs.com/2024/10/15/v5-release.html), which impacts\n[API Endpoints](../advanced/apis.md) (defined with `api` in your Wasp file).\n[Operations](../data-model/operations/overview.md) (defined with `query` and `action` in your Wasp file)\nare not affected by this change.\n\nTo upgrade, follow [Express's v5 migration guide](https://expressjs.com/en/guide/migrating-5.html).\n\n:::tip\nIn general, you only need to worry about changes to the `req` and `res` objects in your API endpoints.\nThe breaking changes are mostly edge cases and most code should work without any updates.\n:::\n\n#### 8. Enjoy your updated Wasp app\n\nThat's it!\n\nYou should now be able to run your app with the new Wasp 0.17.0.\n\n## Migration from 0.15.X to 0.16.X\n\n### What's new in 0.16.0?\n\n#### Env variables validation with Zod\n\nWa",
        "namespace": "xtasker",
        "timestamp": 1754702904854
      },
      {
        "key": "waspfull_am",
        "value": "sp now uses Zod to validate environment variables, allowing it to fail faster if something is misconfigured. This means you’ll get more relevant error messages when running your app with incorrect env variables.\n\nYou can also use Zod to validate your own environment variables. Here’s an example:\n\n```ts\n// src/env.ts\n\nexport const serverEnvValidationSchema = defineEnvValidationSchema(\n  z.object({\n    STRIPE_API_KEY: z.string({\n      required_error: 'STRIPE_API_KEY is required.',\n    }),\n  })\n)\n\n// main.wasp\napp myApp {\n  ...\n  server: {\n    envValidationSchema: import { serverEnvValidationSchema } from \"@src/env\",\n  },\n}\n```\n\nRead more about it in the [env variables](../project/env-vars.md#custom-env-var-validations) section of the docs.\n\n### How to migrate?\n\nTo migrate your Wasp app from 0.15.X to 0.16.X, follow these steps:\n\n#### 1. Bump the Wasp version\n\nUpdate the version field in your Wasp file to `^0.16.0`:\n\n```wasp title=\"main.wasp\"\napp MyApp {\n  wasp: {\n    // highlight-next-line\n    version: \"^0.16.0\"\n  },\n}\n```\n\n##### 1.1 Additional step for Wasp TS Config users\n\nIf you're using [Wasp's new TS config](../general/wasp-ts-config.md), you must\nalso rerun the `wasp ts-setup` command in your project. This command updates\nthe path for the `wasp-config` package in your `package.json`.\n\n#### 2. Update the `package.json` file\n\nMake sure to explicitly add `react-dom` and `react-router-dom` to your `package.json` file:\n\n```json\n{\n  \"dependencies\": {\n    // highlight-start\n    \"react-dom\": \"^18.2.0\",\n    \"react-router-dom\": \"^6.26.2\"\n    // highlight-end\n  }\n}\n```\n\n#### 3. Update the `tsconfig.json` file\n\nWasp now internally works with TypeScript project references, so you'll have to\nupdate your `tsconfig.json` (Wasp will validate your `tsconfig.json` and warn\nyou if you forget something). Here are all the properties you must change:\n\n```json\n{\n  \"compilerOptions\": {\n    // ...\n    \"composite\": true,\n    \"skipLibCheck\": true,\n    \"outDir\": \".wasp/out/user\"\n  },\n  \"include\": [\"src\"]\n}\n```\n\n#### 4. Enjoy your updated Wasp app\n\nThat's it!\n\nYou should now be able to run your app with the new Wasp 0.16.0.\n\n## Migration from 0.14.X to 0.15.X\n\n### What's new in 0.15.0?\n\nWasp 0.15.0 brings upgrades to some of Wasp's most important dependencies. Let's see what's new.\n\n#### Prisma 5\n\nWasp is now using the latest Prisma 5, which brings a lot of performance improvements and new features.\n\nFrom the Prisma docs:\n\n> Prisma ORM 5.0.0 introduces a number of changes, including the usage of our new JSON Protocol, which make Prisma Client faster by default.\n\nThis means that your Wasp app will be faster and more reliable with the new Prisma 5 version.\n\n#### React Router 6\n\nWasp also upgraded its React Router version from `5.3.4` to `6.26.2`. This means that we are now using the latest React Router version, which brings us up to speed and opens up new possibilities for Wasp e.g. potentially using loaders and actions in the future.\n\nThere are some breaking changes in React Router 6, so you will need to update your app to use the new hooks and components.\n\n### How to migrate?\n\nTo migrate your Wasp app from 0.14.X to 0.15.X, follow these steps:\n\n#### 1. Bump the Wasp version\n\nUpdate the version field in your Wasp file to `^0.15.0`:\n\n```wasp title=\"main.wasp\"\napp MyApp {\n  wasp: {\n    // highlight-next-line\n    version: \"^0.15.0\"\n  },\n}\n```\n\n#### 2. Update the `package.json` file\n\n1. Update the `prisma` version in your `package.json` file to `5.19.1`, and add `\"type\": \"module\"` to the top level:\n\n   ```json title=\"package.json\"\n   {\n     ...\n      // highlight-next-line\n     \"type\": \"module\",\n     \"devDependencies\": {\n       ....\n       // highlight-next-line\n       \"prisma\": \"5.19.1\"\n     }\n     ...\n   }\n   ```\n\n2. If you have `@types/react-router-dom` in your `package.json`, you can remove it as it is no longer needed.\n\n#### 3. Use the latest React Router APIs\n\nUpdate the usage of the old React Router 5 APIs to the new React Router 6 APIs:\n\n1. If you used the `useHistory()` hook, you should now use the `useNavigate()` hook.\n\n   <Tabs>\n     <TabItem value=\"before\" label=\"Before\">\n       ```tsx title=\"src/SomePage.tsx\"\n       import { useHistory } from 'react-router-dom'\n\n       export function SomePage() {\n         const history = useHistory()\n         const handleClick = () => {\n           // highlight-next-line\n           history.push('/new-route')\n         }\n         return <button onClick={handleClick}>Go to new route</button>\n       }\n       ```\n     </TabItem>\n\n     <TabItem value=\"after\" label=\"After\">\n       ```tsx title=\"src/SomePage.tsx\"\n       import { useNavigate } from 'react-router-dom'\n\n       export function SomePage() {\n         const navigate = useNavigate()\n         const handleClick = () => {\n           // highlight-next-line\n           navigate('/new-route')\n         }\n         return <button onClick={handleClick}>Go to new route</button>\n       }\n       ```\n     </TabItem>\n   </Tabs>\n\n   Check the [React Router 6 docs](https://reactrouter.com/en/main/hooks/use-navigate#optionsreplace) for more information on the `useNavigate()` hook.\n\n2. If you used the `<Redirect />` component, you should now use the `<Navigate />` component.\n\n   The default behaviour changed from `replace` to `push` in v6, so if you want to keep the old behaviour, you should add the `replace` prop.\n\n   <Tabs>\n     <TabItem value=\"before\" label=\"Before\">\n       ```tsx title=\"src/SomePage.tsx\"\n       import { Redirect } from 'react-router-dom'\n\n       export function SomePage() {\n         return (\n           // highlight-next-line\n           <Redirect to=\"/new-route\" />\n         )\n       }\n       ```\n     </TabItem>\n\n     <TabItem value=\"after\" label=\"After\">\n       ```tsx title=\"src/SomePage.tsx\"\n       import { Navigate } from 'react-router-dom'\n\n       export function SomePage() {\n         return (\n           // highlight-next-line\n           <Navigate to=\"/new-route\" replace />\n         )\n       }\n       ```\n     </TabItem>\n   </Tabs>\n\n   Check the [React Router 6 docs](https://reactrouter.com/en/main/components/navigate) for more information on the `<Navigate />` component.\n\n3. If you accessed the route params using `props.match.params`, you should now use the `useParams()` hook.\n\n   <Tabs>\n     <TabItem value=\"before\" label=\"Before\">\n       ```tsx title=\"src/SomePage.tsx\"\n       import { RouteComponentProps } from 'react-router-dom'\n\n       export function SomePage(props: RouteComponentProps) {\n         // highlight-next-line\n         const { id } = props.match.params\n         return (\n           <div>\n             <h1>Item {id}</h1>\n           </div>\n         )\n       }\n       ```\n     </TabItem>\n\n     <TabItem value=\"after\" label=\"After\">\n       ```tsx title=\"src/SomePage.tsx\"\n       import { useParams } from 'react-router-dom'\n\n       export function SomePage() {\n         // highlight-next-line\n         const { id } = useParams()\n         return (\n           <div>\n             <h1>Item {id}</h1>\n           </div>\n         )\n       }\n       ```\n     </TabItem>\n   </Tabs>\n\n   Check the [React Router 6 docs](https://reactrouter.com/en/main/hooks/use-params) for more information on the `useParams()` hook.\n\n4. If you used the `<NavLink />` component and its `isActive` prop to set the active link state, you should now set the `className` prop directly.\n\n   <Tabs>\n     <TabItem value=\"before\" label=\"Before\">\n       ```tsx title=\"src/SomePage.tsx\"\n       import { NavLink } from 'react-router-dom'\n\n       export function SomePage() {\n         return (\n           <NavLink\n             to=\"/new-route\"\n             // highlight-start\n             isActive={(_match, location) => {\n               return location.pathname === '/new-route'\n             }}\n             // highlight-end\n             className={(isActive) =>\n               cn('text-blue-500', {\n                 underline: isActive,\n               })\n             }\n           >\n             Go to new route\n           </NavLink>\n         )\n       }\n       ```\n     </TabItem>\n\n     <TabItem value=\"after\" label=\"After\">\n       ```tsx title=\"src/SomePage.tsx\"\n       import { NavLink, useLocation } from 'react-router-dom'\n\n       export function SomePage() {\n         // highlight-next-line\n         const location = useLocation()\n         return (\n           <NavLink\n             to=\"/new-route\"\n             className={() =>\n               cn('text-blue-500', {\n                 // highlight-next-line\n                 underline: location.pathname === '/new-route',\n               })\n             }\n           >\n             Go to new route\n           </NavLink>\n         )\n       }\n       ```\n     </TabItem>\n   </Tabs>\n\n   Check the [React Router 6 docs](https://reactrouter.com/en/main/components/nav-link#navlink) for more information on the `<NavLink />` component.\n\n#### 4. Update your root component\n\nThe `client.rootComponent` now requires rendering `<Outlet />` instead the `children` prop.\n\n<Tabs>\n  <TabItem value=\"before\" label=\"Before\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      client: {\n        rootComponent: import { App } from \"@src/App.tsx\",\n      }\n    }\n    ```\n\n    ```tsx title=\"src/App.tsx\"\n    export function App({ children }: { children: React.ReactNode }) {\n      return (\n        <div>\n          <header>\n            <h1>My App</h1>\n          </header>\n          // highlight-next-line\n          {children}\n          <footer>\n            <p>My App footer</p>\n          </footer>\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"after\" label=\"After\">\n    ```wasp title=\"main.wasp\"\n    app MyApp {\n      title: \"My app\",\n      // ...\n      client: {\n        rootComponent: import { App } from \"@src/App.tsx\",\n      }\n    }\n    ```\n\n    ```tsx title=\"src/App.tsx\"\n    import { Outlet } from 'react-router-dom'\n\n    export function App() {\n      return (\n        <div>\n          <header>\n            <h1>My App</h1>\n          </header>\n          // highlight-next-line\n          <Outlet />\n          <footer>\n            <p>My App footer</p>\n          </footer>\n        </div>\n      )\n    }\n    ```\n  </TabItem>\n</Tabs>\n\nThat's it!\n\nYou should now be able to run your app with the new Wasp 0.15.0.\n\n## Migration from 0.13.X to 0.14.X\n\n:::note Are you on 0.11.X or earlier?\n\nThis guide only covers the migration from **0.13.X to 0.14.X**. If you are migrating from 0.11.X or earlier, please read the [migration guide from 0.11.X to 0.12.X](./migrate-from-0-11-to-0-12.md) first.\n\n:::\n\n### What's new in 0.14.0?\n\n#### Using Prisma Schema file directly\n\nBefore 0.14.0, users defined their entities in the `.wasp` file, and Wasp generated the `schema.prisma` file based on that. This approach had some limitations, and users couldn't use some advanced Prisma features.\n\nWasp now exposes the `schema.prisma` file directly to the user. You now define your entities in the `schema.prisma` file and Wasp uses that to generate the database schema and Prisma client. You can use all the Prisma features directly in the `schema.prisma` file. Simply put, the `schema.prisma` file is now the source of truth for your database schema.\n\n<Tabs>\n  <TabItem value=\"before\" label=\"Before\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      wasp: {\n        version: \"^0.13.0\"\n      },\n      title: \"MyApp\",\n      db: {\n        system: PostgreSQL\n      },\n    }\n\n    entity User {=psl\n      id       Int @id @default(autoincrement())\n      tasks    Task[]\n    psl=}\n\n    entity Task {=psl\n      id          Int @id @default(autoincrement())\n      description String\n      isDone      Boolean\n      userId      Int\n      user        User @relation(fields: [userId], references: [id])\n    psl=}\n    ```\n  </TabItem>\n\n  <TabItem value=\"after\" label=\"After\">\n    ```wasp title=\"main.wasp\"\n    app myApp {\n      wasp: {\n        version: \"^0.14.0\"\n      },\n      title: \"MyApp\",\n    }\n    ```\n\n    ```prisma title=\"schema.prisma\"\n    datasource db {\n      provider = \"postgresql\"\n      url      = env(\"DATABASE_URL\")\n    }\n\n    generator client {\n      provider = \"prisma-client-js\"\n    }\n\n    model User {\n      id       Int @id @default(autoincrement())\n      tasks    Task[]\n    }\n\n    model Task {\n      id          Int @id @default(autoincrement())\n      description String\n      isDone      Boolean\n      userId      Int\n      user        User @relation(fields: [userId], references: [id])\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n#### Better auth user API\n\nWasp introduced a much simpler API for accessing user auth fields like `username`, `email` or `isEmailVerified` on the `user` object. You don't need to use helper functions every time you want to access the user's `username` or do extra steps to get proper typing.\n\n### How to migrate?\n\nTo migrate your app to Wasp 0.14.x, you must:\n\n1. Bump the version in `main.wasp` and update your `tsconfig.json`.\n2. Migrate your entities into the new `schema.prisma` file.\n3. Update code that accesses user fields.\n\n#### Bump the version and update `tsconfig.json`\n\nLet's start with something simple. Update the version field in your Wasp file to `^0.14.0`:\n\n```wasp title=\"main.wasp\"\napp MyApp {\n  wasp: {\n    // highlight-next-line\n    version: \"^0.14.0\"\n  },\n}\n```\n\nTo ensure your project works correctly with Wasp 0.14.0, you must also update your\n`tsconfig.json` file.\n\nIf you haven't changed anything in your project's `tsconfig.json` file (this is\nthe case for most users), just replace its contents with the new version shown\nbelow.\n\nIf you have made changes to your `tsconfig.json` file, we recommend taking the\nnew version of the file and reapplying them.\n\nHere's the new version of the `tsconfig.json` file:\n\n```json title=\"tsconfig.json\"\n// =============================== IMPORTANT =================================\n//\n// This file is only used for Wasp IDE support. You can change it to configure\n// your IDE checks, but none of these options will affect the TypeScript\n// compiler. Proper TS compiler configuration in Wasp is coming soon :)\n{\n  \"compilerOptions\": {\n    \"module\": \"esnext\",\n    \"target\": \"esnext\",\n    // We're bundling all code in the end so this is the most appropriate option,\n    // it's also important for autocomplete to work properly.\n    \"moduleResolution\": \"bundler\",\n    // JSX support\n    \"jsx\": \"preserve\",\n    \"strict\": true,\n    // Allow default imports.\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"typeRoots\": [\n      // This is needed to properly support Vitest testing with jest-dom matchers.\n      // Types for jest-dom are not recognized automatically and Typescript complains\n      // about missing types e.g. when using `toBeInTheDocument` and other matchers.\n      \"node_modules/@testing-library\",\n      // Specifying type roots overrides the default behavior of looking at the\n      // node_modules/@types folder so we had to list it explicitly.\n      // Source 1: https://www.typescriptlang.org/tsconfig#typeRoots\n      // Source 2: https://github.com/testing-library/jest-dom/issues/546#issuecomment-1889884843\n      \"node_modules/@types\"\n    ],\n    // Since this TS config is used only for IDE support and not for\n    // compilation, the following directory doesn't exist. We need to specify\n    // it to prevent this error:\n    // https://stackoverflow.com/questions/42609768/typescript-error-cannot-write-file-because-it-would-overwrite-input-file\n    \"outDir\": \".wasp/phantom\"\n  }\n}\n```\n\n#### Migrate to the new `schema.prisma` file\n\nTo use the new `schema.prisma` file, you need to move your entities from the `.wasp` file to the `schema.prisma` file.\n\n1\\. **Create a new `schema.prisma` file**\n\nCreate a new file named `schema.prisma` in the root of your project:\n\n```c\n.\n├── main.wasp\n...\n// highlight-next-line\n├── schema.prisma\n├── src\n├── tsconfig.json\n└── vite.config.ts\n```\n\n2\\. **Add the `datasource` block** to the `schema.prisma` file\n\nThis block specifies the database type and connection URL:\n\n<Tabs groupId=\"db\">\n  <TabItem value=\"sqlite\" label=\"Sqlite\">\n    ```prisma title=\"schema.prisma\"\n    datasource db {\n      provider = \"sqlite\"\n      url      = env(\"DATABASE_URL\")\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"postgresql\" label=\"PostgreSQL\">\n    ```prisma title=\"schema.prisma\"\n    datasource db {\n      provider = \"postgresql\"\n      url      = env(\"DATABASE_URL\")\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n- The `provider` should be either `\"postgresql\"` or `\"sqlite\"`.\n\n- The `url` must be set to `env(\"DATABASE_URL\")` so that Wasp can inject the database URL from the environment variables.\n\n3\\. **Add the `generator` block** to the `schema.prisma` file\n\nThis block specifies the Prisma Client generator Wasp uses:\n\n<Tabs groupId=\"db\">\n  <TabItem value=\"sqlite\" label=\"Sqlite\">\n    ```prisma title=\"schema.prisma\"\n    datasource db {\n      provider = \"sqlite\"\n      url      = env(\"DATABASE_URL\")\n    }\n\n    // highlight-start\n    generator client {\n      provider = \"prisma-client-js\"\n    }\n    // highlight-end\n    ```\n  </TabItem>\n\n  <TabItem value=\"postgresql\" label=\"PostgreSQL\">\n    ```prisma title=\"schema.prisma\"\n    datasource db {\n      provider = \"postgresql\"\n      url      = env(\"DATABASE_URL\")\n    }\n\n    // highlight-start\n    generator client {\n      provider = \"prisma-client-js\"\n    }\n    // highlight-end\n    ```\n  </TabItem>\n</Tabs>\n\n- The `provider` should be set to `\"prisma-client-js\"`.\n\n4\\. **Move your entities** to the `schema.prisma` file\n\nMove the entities from the `.wasp` file to the `schema.prisma` file:\n\n<Tabs groupId=\"db\">\n  <TabItem value=\"sqlite\" label=\"Sqlite\">\n    ```prisma title=\"schema.prisma\"\n    datasource db {\n      provider = \"sqlite\"\n      url      = env(\"DATABASE_URL\")\n    }\n\n    generator client {\n      provider = \"prisma-client-js\"\n    }\n\n    // There are some example entities, you should move your entities here\n    // highlight-start\n    model User {\n      id       Int @id @default(autoincrement())\n      tasks    Task[]\n    }\n\n    model Task {\n      id          Int @id @default(autoincrement())\n      description String\n      isDone      Boolean\n      userId      Int\n      user        User @relation(fields: [userId], references: [id])\n    }\n    // highlight-end\n    ```\n  </TabItem>\n\n  <TabItem value=\"postgresql\" label=\"PostgreSQL\">\n    ```prisma title=\"schema.prisma\"\n    datasource db {\n      provider = \"postgresql\"\n      url      = env(\"DATABASE_URL\")\n    }\n\n    generator client {\n      provider = \"prisma-client-js\"\n    }\n\n    // There are some example entities, you should move your entities here\n    // highlight-start\n    model User {\n      id       Int @id @default(autoincrement())\n      tasks    Task[]\n    }\n\n    model Task {\n      id          Int @id @default(autoincrement())\n      description String\n      isDone      Boolean\n      userId      Int\n      user        User @relation(fields: [userId], references: [id])\n    }\n    // highlight-end\n    ```\n  </TabItem>\n</Tabs>\n\nWhen moving the entities over, you'll need to change `entity` to `model` and remove the `=psl` and `psl=` tags.\n\nIf you had the following in the `.wasp` file:\n\n```wasp title=\"main.wasp\"\nentity Task {=psl\n  // Stays the same\npsl=}\n```\n\n... it would look like this in the `schema.prisma` file:\n\n```prisma title=\"schema.prisma\"\nmodel Task {\n  // Stays the same\n}\n```\n\n5\\. **Remove `app.db.system`** field from the Wasp file\n\nWe now configure the DB system in the `schema.prisma` file, so there is no need for that field in the Wasp file.\n\n```wasp title=\"main.wasp\"\napp MyApp {\n  // ...\n  db: {\n    // highlight-next-line\n    system: PostgreSQL,\n  }\n}\n```\n\n6\\. **Migrate Prisma preview features config** to the `schema.prisma` file\n\nIf you didn't use any Prisma preview features, you can skip this step.\n\nIf you had the following in the `.wasp` file:\n\n```wasp title=\"main.wasp\"\napp MyApp {\n  // ...\n  db: {\n    // highlight-start\n    prisma: {\n      clientPreviewFeatures: [\"postgresqlExtensions\"]\n      dbExtensions: [\n        { name: \"hstore\", schema: \"myHstoreSchema\" },\n        { name: \"pg_trgm\" },\n        { name: \"postgis\", version: \"2.1\" },\n      ]\n    }\n    // highlight-end\n  }\n}\n```\n\n... it will become this:\n\n```prisma title=\"schema.prisma\"\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n  // highlight-next-line\n  extensions = [hstore(schema: \"myHstoreSchema\"), pg_trgm, postgis(version: \"2.1\")]\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n  // highlight-next-line\n  previewFeatures = [\"postgresqlExtensions\"]\n}\n```\n\nAll that's left to do is migrate the database.\n\nTo avoid type errors, it's best to take care of database migrations after you've migrated the rest of the code.\nSo, just keep reading, and we will remind you to migrate the database as [the last step of the migration guide](#migrate-the-database).\n\nRead more about the [Prisma Schema File](../data-model/prisma-file.md) and how Wasp uses it to generate the database schema and Prisma client.\n\n#### Migrate how you access user auth fields\n\nWe had to make a couple of breaking changes to reach the new simpler API.\n\nFollow the steps below to migrate:\n\n1. **Replace the `getUsername` helper** with `user.identities.username.id`\n\n   If you didn't use the `getUsername` helper in your code, you can skip this step.\n\n   This helper changed and it no longer works with the `user` you receive as a prop on a page or through the `context`. You'll need to replace it with `user.identities.username.id`.\n\n   <Tabs>\n     <TabItem value=\"before\" label=\"Before\">\n       ```tsx title=\"src/MainPage.tsx\"\n       import { getUsername, AuthUser } from 'wasp/auth'\n\n       const MainPage = ({ user }: { user: AuthUser }) => {\n         const username = getUsername(user)\n         // ...\n       }\n       ```\n\n       ```ts title=\"src/tasks.ts\"\n       import { getUsername } from 'wasp/auth'\n\n       export const createTask: CreateTask<...>  = async (args, context) => {\n           const username = getUsername(context.user)\n           // ...\n       }\n       ```\n     </TabItem>\n\n     <TabItem value=\"after\" label=\"After\">\n       ```tsx title=\"src/MainPage.tsx\"\n       import { AuthUser } from 'wasp/auth'\n\n       const MainPage = ({ user }: { user: AuthUser }) => {\n         const username = user.identities.username?.id\n         // ...\n       }\n       ```\n\n       ```ts title=\"src/tasks.ts\"\n       export const createTask: CreateTask<...>  = async (args, context) => {\n           const username = context.user.identities.username?.id\n           // ...\n       }\n       ```\n     </TabItem>\n   </Tabs>\n\n2. **Replace the `getEmail` helper** with `user.identities.email.id`\n\n   If you didn't use the `getEmail` helper in your code, you can skip this step.\n\n   This helper changed and it no longer works with the `user` you receive as a prop on a page or through the `context`. You'll need to replace it with `user.identities.email.id`.\n\n   <Tabs>\n     <TabItem value=\"before\" label=\"Before\">\n       ```tsx title=\"src/MainPage.tsx\"\n       import { getEmail, AuthUser } from 'wasp/auth'\n\n       const MainPage = ({ user }: { user: AuthUser }) => {\n         const email = getEmail(user)\n         // ...\n       }\n       ```\n\n       ```ts title=\"src/tasks.ts\"\n       import { getEmail } from 'wasp/auth'\n\n       export const createTask: CreateTask<...>  = async (args, context) => {\n           const email = getEmail(context.user)\n           // ...\n       }\n       ```\n     </TabItem>\n\n     <TabItem value=\"after\" label=\"After\">\n       ```tsx title=\"src/MainPage.tsx\"\n       import { AuthUser } from 'wasp/auth'\n\n       const MainPage = ({ user }: { user: AuthUser }) => {\n         const email = user.identities.email?.id\n         // ...\n       }\n       ```\n\n       ```ts title=\"src/tasks.ts\"\n       export const createTask: CreateTask<...>  = async (args, context) => {\n           const email = context.user.identities.email?.id\n           // ...\n       }\n       ```\n     </TabItem>\n   </Tabs>\n\n3. **Replace accessing `providerData`** with `user.identities.<provider>.<value>`\n\n   If you didn't use any data from the `providerData` object, you can skip this step.\n\n   Replace `<provider>` with the provider name (for example `username`, `email`, `google`, `github`, etc.) and `<value>` with the field you want to access (for example `isEmailVerified`).\n\n   <Tabs>\n     <TabItem value=\"before\" label=\"Before\">\n       ```tsx title=\"src/MainPage.tsx\"\n       import { findUserIdentity, AuthUser } from 'wasp/auth'\n\n       function getProviderData(user: AuthUser) {\n         const emailIdentity = findUserIdentity(user, 'email')\n         // We needed this before check for proper type support\n         return emailIdentity && 'isEmailVerified' in emailIdentity.providerData\n           ? emailIdentity.providerData\n           : null\n       }\n\n       const MainPage = ({ user }: { user: AuthUser }) => {\n         const providerData = getProviderData(user)\n         const isEmailVerified = providerData ? providerData.isEmailVerified : null\n         // ...\n       }\n       ```\n     </TabItem>\n\n     <TabItem value=\"after\" label=\"After\">\n       ```tsx title=\"src/MainPage.tsx\"\n       import { AuthUser } from 'wasp/auth'\n\n       const MainPage = ({ user }: { user: AuthUser }) => {\n         // The email object is properly typed, so we can access `isEmailVerified` directly\n         const isEmailVerified = user.identities.email?.isEmailVerified\n         // ...\n       }\n       ```\n     </TabItem>\n   </Tabs>\n\n4. **Use `getFirstProviderUserId` directly** on the user object\n\n   If you didn't use `getFirstProviderUserId` in your code, you can skip this step.\n\n   You should replace `getFirstProviderUserId(user)` with `user.getFirstProviderUserId()`.\n\n   <Tabs>\n     <TabItem value=\"before\" label=\"Before\">\n       ```tsx title=\"src/MainPage.tsx\"\n       import { getFirstProviderUserId, AuthUser } from 'wasp/auth'\n\n       const MainPage = ({ user }: { user: AuthUser }) => {\n         const userId = getFirstProviderUserId(user)\n         // ...\n       }\n       ```\n\n       ```ts title=\"src/tasks.ts\"\n       import { getFirstProviderUserId } from 'wasp/auth'\n\n       export const createTask: CreateTask<...>  = async (args, context) => {\n           const userId = getFirstProviderUserId(context.user)\n           // ...\n       }\n       ```\n     </TabItem>\n\n     <TabItem value=\"after\" label=\"After\">\n       ```tsx title=\"src/MainPage.tsx\"\n       import { AuthUser } from 'wasp/auth'\n\n       const MainPage = ({ user }: { user: AuthUser }) => {\n         const userId = user.getFirstProviderUserId()\n         // ...\n       }\n       ```\n\n       ```ts title=\"src/tasks.ts\"\n       export const createTask: CreateTask<...>  = async (args, context) => {\n           const userId = user.getFirstProviderUserId()\n           // ...\n       }\n       ```\n     </TabItem>\n   </Tabs>\n\n5. **Replace `findUserIdentity`** with checks on `user.identities.<provider>`\n\n   If you didn't use `findUserIdentity` in your code, you can skip this step.\n\n   Instead of using `findUserIdentity` to get the identity object, you can directly check if the identity exists on the `identities` object.\n\n   <Tabs>\n     <TabItem value=\"before\" label=\"Before\">\n       ```tsx title=\"src/MainPage.tsx\"\n       import { findUserIdentity, AuthUser } from 'wasp/auth'\n\n       const MainPage = ({ user }: { user: AuthUser }) => {\n         const usernameIdentity = findUserIdentity(user, 'username')\n         if (usernameIdentity) {\n           // ...\n         }\n       }\n       ```\n\n       ```ts title=\"src/tasks.ts\"\n       import { findUserIdentity } from 'wasp/auth'\n\n       export const createTask: CreateTask<...>  = async (args, context) => {\n           const usernameIdentity = findUserIdentity(context.user, 'username')\n           if (usernameIdentity) {\n               // ...\n           }\n       }\n       ```\n     </TabItem>\n\n     <TabItem value=\"after\" label=\"After\">\n       ```tsx title=\"src/MainPage.tsx\"\n       import { AuthUser } from 'wasp/auth'\n\n       const MainPage = ({ user }: { user: AuthUser }) => {\n         if (user.identities.username) {\n           // ...\n         }\n       }\n       ```\n\n       ```ts title=\"src/tasks.ts\"\n       export const createTask: CreateTask<...>  = async (args, context) => {\n           if (context.user.identities.username) {\n               // ...\n           }\n       }\n       ```\n     </TabItem>\n   </Tabs>\n\n#### Migrate the database\n\nFinally, you can **Run the Wasp CLI** to regenerate the new Prisma client:\n\n```bash\nwasp db migrate-dev\n```\n\nThis command generates the Prisma client based on the `schema.prisma` file.\n\nRead more about the [Prisma Schema File](../data-model/prisma-file.md) and how Wasp uses it to generate the database schema and Prisma client.\n\nThat's it!\n\nYou should now be able to run your app with the new Wasp 0.14.0. We recommend reading through the updated [Accessing User Data](../auth/entities/entities.md) section to get a better understanding of the new API.\n\n## Migration from 0.12.X to 0.13.X\n\n:::note Are you on 0.11.X or earlier?\n\nThis guide only covers the migration from **0.12.X to 0.13.X**. If you are migrating from 0.11.X or earlier, please read the [migration guide from 0.11.X to 0.12.X](./migrate-from-0-11-to-0-12.md) first.\n\nMake sure to read the [migration guide from 0.13.X to 0.14.X](./migrate-from-0-13-to-0-14.md) after you finish this one.\n\n:::\n\n### What's new in 0.13.0?\n\n#### OAuth providers got an overhaul\n\nWasp 0.13.0 switches away from using Passport for our OAuth providers in favor of [Arctic](https://arctic.js.org/) from the [Lucia](https://lucia-auth.com/) ecosystem. This change simplifies the codebase and makes it easier to add new OAuth providers in the future.\n\n#### We added Keycloak as an OAuth provider\n\nWasp now supports using [Keycloak](https://www.keycloak.org/) as an OAuth provider.\n\n### How to migrate?\n\n#### Migrate your OAuth setup\n\nWe had to make some breaking changes to upgrade the OAuth setup to the new Arctic lib.\n\nFollow the steps below to migrate:\n\n1. **Define the `WASP_SERVER_URL` server env variable**\n\n   In 0.13.0 Wasp introduces a new server env variable `WASP_SERVER_URL` that you need to define. This is the URL of your Wasp server and it's used to generate the redirect URL for the OAuth providers.\n\n   ```bash title=\"Server env variables\"\n   WASP_SERVER_URL=https://your-wasp-server-url.com\n   ```\n\n   In development, Wasp sets the `WASP_SERVER_URL` to `http://localhost:3001` by default.\n\n   :::info Migrating a deployed app\n\n   If you are migrating a deployed app, you will need to define the `WASP_SERVER_URL` server env variable in your deployment environment.\n\n   Read more about setting env variables in production [here](../project/env-vars#defining-env-vars-in-production).\n   :::\n\n2. **Update the redirect URLs** for the OAuth providers\n\n   The redirect URL for the OAuth providers has changed. You will need to update the redirect URL for the OAuth providers in the provider's dashboard.\n\n   <Tabs>\n     <TabItem value=\"before\" label=\"Before\">\n       ```\n       {clientUrl}/auth/login/{provider}\n       ```\n     </TabItem>\n\n     <TabItem value=\"after\" label=\"After\">\n       ```\n       {serverUrl}/auth/{provider}/callback\n       ```\n     </TabItem>\n   </Tabs>\n\n   Check the new redirect URLs for [Google](../auth/social-auth/google.md#3-creating-a-google-oauth-app) and [GitHub](../auth/social-auth/github.md#3-creating-a-github-oauth-app) in Wasp's docs.\n\n3. **Update the `configFn`** for the OAuth providers\n\n   If you didn't use the `configFn` option, you can skip this step.\n\n   If you used the `configFn` to configure the `scope` for the OAuth providers, you will need to rename the `scope` property to `scopes`.\n\n   Also, the object returned from `configFn` no longer needs to include the Client ID and the Client Secret. You can remove them from the object that `configFn` returns.\n\n   <Tabs>\n     <TabItem value=\"before\" label=\"Before\">\n       ```ts title=\"google.ts\"\n       export function getConfig() {\n           return {\n               clientID: process.env.GOOGLE_CLIENT_ID,\n               clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n               scope: ['profile', 'email'],\n           }\n       }\n       ```\n     </TabItem>\n\n     <TabItem value=\"after\" label=\"After\">\n       ```ts title=\"google.ts\"\n       export function getConfig() {\n           return {\n               scopes: ['profile', 'email'],\n           }\n       }\n       ```\n     </TabItem>\n   </Tabs>\n\n4. **Update the `userSignupFields` fields** to use the new `profile` format\n\n   If you didn't use the `userSignupFields` option, you can skip this step.\n\n   The data format for the `profile` that you receive from the OAuth providers has changed. You will need to update your code to reflect this change.\n\n   <Tabs>\n     <TabItem value=\"before\" label=\"Before\">\n       ```ts title=\"google.ts\"\n       import { defineUserSignupFields } from 'wasp/server/auth'\n\n       export const userSignupFields = defineUserSignupFields({\n           displayName: (data: any) => data.profile.displayName,\n       })\n       ```\n     </TabItem>\n\n     <TabItem value=\"after\" label=\"After\">\n       ```ts title=\"google.ts\"\n       import { defineUserSignupFields } from 'wasp/server/auth'\n\n       export const userSignupFields = defineUserSignupFields({\n           displayName: (data: any) => data.profile.name,\n       })\n       ```\n     </TabItem>\n   </Tabs>\n\n   Wasp now directly forwards what it receives from the OAuth providers. You can check the data format for [Google](../auth/social-auth/google.md#data-received-from-google) and [GitHub](../auth/social-auth/github.md#data-received-from-github) in Wasp's docs.\n\nThat's it!\n\nYou should now be able to run your app with the new Wasp 0.13.0.\n\n## Migration from 0.11.X to 0.12.X\n\n:::note Migrating to the latest version\n\nTo fully migrate from 0.11.X to the latest version of Wasp, you should first migrate to **0.12.X** and then continue going through the migration guides.\n\nMake sure to read the [migration guide from 0.12.X to 0.13.X](./migrate-from-0-12-to-0-13.md) after you finish this one.\n\n:::\n\n### What's new in Wasp 0.12.0?\n\n#### New project structure\n\nHere's a file tree of a fresh Wasp project created with the previous version of Wasp.\nMore precisely, this is what you'll get if you run `wasp new myProject` using Wasp 0.11.x:\n\n```\n.\n├── .gitignore\n├── main.wasp\n├── src\n│   ├── client\n│   │   ├── Main.css\n│   │   ├── MainPage.jsx\n│   │   ├── react-app-env.d.ts\n│   │   ├── tsconfig.json\n│   │   └── waspLogo.png\n│   ├── server\n│   │   └── tsconfig.json\n│   ├── shared\n│   │   └── tsconfig.json\n│   └── .waspignore\n└── .wasproot\n```\n\nCompare that with the file tree of a fresh Wasp project created with Wasp\n0.12.0. In other words, this is what you will get by running `wasp new myProject`\nfrom this point onwards:\n\n```\n.\n├── .gitignore\n├── main.wasp\n├── package.json\n├── public\n│   └── .gitkeep\n├── src\n│   ├── Main.css\n│   ├── MainPage.jsx\n│   ├── queries.ts\n│   ├── vite-env.d.ts\n│   ├── .waspignore\n│   └── waspLogo.png\n├── tsconfig.json\n├── vite.config.ts\n└── .wasproot\n\n```\n\nThe main differences are:\n\n- The server/client code separation is no longer necessary. You can now organize\n  your code however you want, as long as it's inside the `src` directory.\n- All external imports in your Wasp file must have paths starting with `@src` (e.g., `import foo from '@src/bar.js'`)\n  where `@src` refers to the `src` directory in your project root. The paths can\n  no longer start with `@server` or `@client`.\n- Your project now features a top-level `public` dir. Wasp will publicly serve\n  all the files it finds in this directory. Read more about it\n  [here](../project/static-assets.md).\n\nOur [Overview docs](../tutorial/02-project-structure.md) explain the new\nstructure in detail, while this page provides a [quick guide](#migrating-your-project-to-the-new-structure) for migrating existing\nprojects.\n\n#### New auth\n\nIn Wasp 0.11.X, authentication was based on the `User` model which the developer needed to set up properly and take care of the auth fields like `email` or `password`.\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"^0.11.0\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    externalAuthEntity: SocialLogin,\n    methods: {\n      gitHub: {}\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n\nentity User {=psl\n  id                        Int           @id @default(autoincrement())\n  // highlight-start\n  username                  String        @unique\n  password                  String\n  externalAuthAssociations  SocialLogin[]\n  // highlight-end\npsl=}\n\n// highlight-start\nentity SocialLogin {=psl\n  id          Int       @id @default(autoincrement())\n  provider    String\n  providerId  String\n  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)\n  userId      Int\n  createdAt   DateTime  @default(now())\n  @@unique([provider, providerId, userId])\npsl=}\n// highlight-end\n```\n\nFrom 0.12.X onwards, authentication is based on the auth models which are automatically set up by Wasp. You don't need to take care of the auth fields anymore.\n\nThe `User` model is now just a business logic model and you use it for storing the data that is relevant for your app.\n\n```wasp title=\"main.wasp\"\napp myApp {\n  wasp: {\n    version: \"^0.12.0\"\n  },\n  title: \"My App\",\n  auth: {\n    userEntity: User,\n    methods: {\n      gitHub: {}\n    },\n    onAuthFailedRedirectTo: \"/login\"\n  },\n}\n\nentity User {=psl\n  id Int @id @default(autoincrement())\npsl=}\n```\n\n:::caution Regression Note: Multiple Auth Identities per User\n\nWith our old auth implementation, if you were using both Google and email auth methods, your users could sign up with Google first and then, later on, reset their password and therefore also enable logging in with their email and password. This was the only way in which a single user could have multiple login methods at the same time (Google and email).\n\nThis is not possible anymore. **The new auth system doesn't support multiple login methods per user at the moment**. We do plan to add this soon though, with the introduction of the [account merging feature](https://github.com/wasp-lang/wasp/issues/954).\n\nIf you have any users that have both Google and email login credentials at the same time, you will have to pick only one of those for that user to keep when migrating them.\n\n:::\n\n:::caution Regression Note: `_waspCustomValidations` is deprecated\n\nAuth field customization is no longer possible using the `_waspCustomValidations` on the `User` entity. This is a part of auth refactoring that we are doing to make it easier to customize auth. We will be adding more customization options in the future.\n\n:::\n\nYou can read more about the new auth system in the [Accessing User Data](../auth/entities) section.\n\n### How to Migrate?\n\nThese instructions are for migrating your app from Wasp `0.11.X` to Wasp `0.12.X`, meaning they will work for all minor releases that fit this pattern (e.g., the guide applies to `0.12.0`, `0.12.1`, ...).\n\nThe guide consists of two big steps:\n\n1. Migrating your Wasp project to the new structure.\n2. Migrating to the new auth.\n\nIf you get stuck at any point, don't hesitate to ask for help on [our Discord server](https://discord.gg/rzdnErX).\n\n#### Migrating Your Project to the New Structure\n\nYou can easily migrate your old Wasp project to the new structure by following a\nseries of steps. Assuming you have a project called `foo` inside the\ndirectory `foo`, you should:\n\n0. **Install the `0.12.x` version** of Wasp.\n\n```bash\ncurl -sSL https://get.wasp.sh/installer.sh | sh -s -- -v 0.12.4\n```\n\n1. Make sure to **backup or save your project** before starting the procedure (e.g.,\n   by committing it to source control or creating a copy).\n2. **Position yourself in the terminal** in the directory that is a parent of your wasp project directory (so one level above: if you do `ls`, you should see your wasp project dir listed).\n3. **Run the migration script** (replace `foo` at the end with the name of your Wasp project directory) and follow the instructions:\n\n```\nnpx wasp-migrate foo\n```\n\n<details>\n  <summary>\n    In case the migration script doesn't work well for you, you can do the same steps manually, as described here:\n  </summary>\n\n  <div>\n    1. Rename your project's root directory to something like `foo_old`.\n\n    2. Create a new project by running `wasp new foo`.\n\n    3. Delete all files of `foo/src` except `vite-env.d.ts`.\n\n    4. If `foo_old/src/client/public` exists and contains any files, copy those files into\n       `foo/public`.\n\n    5. Copy the contents of `foo_old/src` into `foo/src`.\n       `foo/src` should now contain `vite-env.d.ts`, `.waspignore`, and three subdirectories (`server`, `client`, and `shared`).\n       Don't change anything about this structure yet.\n\n    6. Delete redundant files and folders from `foo/src`:\n       - `foo/src/.waspignore` - A new version of this file already exists at the top level.\n       - `foo/src/client/vite-env.d.ts` - A new version of this file already exists at the top level.\n       - `foo/src/client/tsconfig.json` - A new version of this file already exists at the top level.\n       - `foo/src/server/tsconfig.json` - A new version of this file already exists at the top level.\n       - `foo/src/shared/tsconfig.json` - A new version of this file already exists at the top level.\n       - `foo/src/client/public` - You've moved all the files from this directory in step 5.\n\n    7. Update all the `@wasp` imports in your JS(X)/TS(X) source files in the `src/` dir.\n\n       For this, we prepared a special script that will rewrite these imports automatically for you.\n\n       Before doing this step, as the script will modify your JS(X)/TS(X) files in place, we advise committing\n       all changes you have so far, so you can then both easily inspect the import rewrites that our\n       script did (with `git diff`) and also revert them if something went wrong.\n\n       To run the import-rewriting script, make sure you are in the root dir of your wasp project, and then run\n\n       ```\n       npx jscodeshift@0.15.1 -t https://raw.githubusercontent.com/wasp-lang/wasp-codemod/main/src/transforms/imports-from-0-11-to-0-12.ts --extensions=js,ts,jsx,tsx src/\n       ```\n\n       Then, check the changes it did, in case some kind of manual intervention is needed (in which case you should see TODO comments generated by the script).\n\n       Alternatively, you can find all the mappings of old imports to the new ones in [this table](https://docs.google.com/spreadsheets/d/1QW-_16KRGTOaKXx9NYUtjk6m2TQ0nUMOA74hBthTH3g/edit#gid=1725669920) and use it to fix some/all of them manually.\n\n    8. Replace the Wasp file in `foo` (i.e., `main.wasp`) with the Wasp file from `foo_old`\n\n    9. Change the Wasp version field in your Wasp file (now residing in `foo`) to `\"^0.12.0\"`.\n\n    10. Correct external imports in your Wasp file (now residing in `foo`).\n        imports. You can do this by running search-and-replace inside the file:\n\n        - Change all occurrences of `@server` to `@src/server`\n        - Change all occurrences of `@client` to `@src/client`\n\n        For example, if you previously had something like:\n\n        ```js\n        page LoginPage {\n          // highlight-next-line\n          // This previously resolved to src/client/LoginPage.js\n          // highlight-next-line\n          component: import Login from \"@client/LoginPage\"\n        }\n\n        // ...\n\n        query getTasks {\n          // highlight-next-line\n          // This previously resolved to src/server/queries.js\n          // highlight-next-line\n          fn: import { getTasks } from \"@server/queries.js\",\n        }\n        ```\n\n        You should change it to:\n\n        ```js\n        page LoginPage {\n          // highlight-next-line\n          // This now resolves to src/client/LoginPage.js\n          // highlight-next-line\n          component: import Login from \"@src/client/LoginPage\"\n        }\n\n        // ...\n\n        query getTasks {\n          // highlight-next-line\n          // This now resolves to src/server/queries.js\n          // highlight-next-line\n          fn: import { getTasks } from \"@src/server/queries.js\",\n        }\n        ```\n\n        Do this for all external imports in your `.wasp` file. After you're done, there shouldn't be any occurrences of strings `\"@server\"` or `\"@client\"`\n\n    11. Take all the dependencies from `app.dependencies` declaration in\n        `foo/main.wasp` and move them to `foo/package.json`. Make sure to remove the `app.dependencies` field from `foo/main.wasp`.\n\n        For example, if `foo_old/main.wasp` had:\n\n        ```css\n        app Foo {\n          // ...\n          dependencies: [ ('redux', '^4.0.5'), ('reacjt-redux', '^7.1.3')];\n        }\n        ```\n\n        Your `package.json` in `foo` should now list these dependencies (Wasp already generated most of the file, you just have to list additional dependencies).\n\n        ```json\n        {\n          \"name\": \"foo\",\n          \"dependencies\": {\n            \"wasp\": \"file:.wasp/out/sdk/wasp\",\n            \"react\": \"^18.2.0\",\n            // highlight-next-line\n            \"redux\": \"^4.0.5\",\n            // highlight-next-line\n            \"reactjs-redux\": \"^7.1.3\"\n          },\n          \"devDependencies\": {\n            \"typescript\": \"^5.1.0\",\n            \"vite\": \"^4.3.9\",\n            \"@types/react\": \"^18.0.37\",\n            \"prisma\": \"4.16.2\"\n          }\n        }\n        ```\n\n    12. Copy all lines you might have added to `foo_old/.gitignore` into\n        `foo/.gitignore`\n\n    13. Copy the rest of the top-level files and folders (all of them except for `.gitignore`, `main.wasp` and `src/`)\n        in `foo_old/` into `foo/` (overwrite the existing files in `foo`).\n\n    14. Run `wasp clean` in `foo`.\n\n    15. Delete the `foo_old` directory.\n  </div>\n</details>\n\nThat's it! You now have a properly structured Wasp 0.12.0 project in the `foo` directory.\nYour app probably doesn't quite work yet due to some other changes in Wasp 0.12.0, but we'll get to that in the next sections.\n\n#### Migrating declaration names\n\nWasp 0.12.0 adds a casing constraints when naming Queries, Actions, Jobs, and Entities in the `main.wasp` file.\n\nThe following casing conventions have now become mandatory:\n\n- Operation (i.e., Query and Action) names must begin with a lowercase letter: `query getTasks {...}`, `action createTask {...}`.\n- Job names must begin with a lowercase letter: `job sendReport {...}`.\n- Entity names must start with an uppercase letter: `entity Task {...}`.\n\n#### Migrating the Tailwind Setup\n\n:::note\nIf you don't use Tailwind in your project, you can skip this section.\n:::\n\nThere is a small change in how the `tailwind.config.cjs` needs to be defined in Wasp 0.12.0.\n\nYou'll need to wrap all your paths in the `content` field with the `resolveProjectPath` function. This makes sure that the paths are resolved correctly when generating your CSS.\n\nHere's how you can do it:\n\n<Tabs>\n  <TabItem value=\"before\" label=\"Before\">\n    ```js title=\"tailwind.config.cjs\"\n    /** @type {import('tailwindcss').Config} */\n    module.exports = {\n      content: [\n        // highlight-next-line\n        './src/**/*.{js,jsx,ts,tsx}',\n      ],\n      theme: {\n        extend: {},\n      },\n      plugins: [],\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"after\" label=\"After\">\n    ```js title=\"tailwind.config.cjs\"\n    // highlight-next-line\n    const { resolveProjectPath } = require('wasp/dev')\n\n    /** @type {import('tailwindcss').Config} */\n    module.exports = {\n      content: [\n        // highlight-next-line\n        resolveProjectPath('./src/**/*.{js,jsx,ts,tsx}'),\n      ],\n      theme: {\n        extend: {},\n      },\n      plugins: [],\n    }\n    ```\n  </TabItem>\n</Tabs>\n\n#### Default Server Dockerfile Changed\n\n:::note\nIf you didn't customize your Dockerfile or had a custom build process for the Wasp server, you can skip this section.\n:::\n\nBetween Wasp 0.11.X and 0.12.X, the Dockerfile that Wasp generates for you for deploying the server has changed. If you defined a custom Dockerfile in your project root dir or in any other way relied on its contents, you'll need to update it to incorporate the changes that Wasp 0.12.X made.\n\nWe suggest that you temporarily move your custom Dockerfile to a different location, then run `wasp start` to generate the new Dockerfile.\nCheck out the `.wasp/out/Dockerfile` to see the new Dockerfile and what changes you need to make. You'll probably need to copy some of the changes from the new Dockerfile to your custom one to make your app work with Wasp 0.12.X.\n\n#### Migrating to the New Auth\n\nAs shown in [the previous section](#new-auth), Wasp significantly changed how authentication works in version 0.12.0.\nThis section leads you through migrating your app from Wasp 0.11.X to Wasp 0.12.X.\n\nMigrating your existing app to the new auth system is a two-step process:\n\n1. Migrate to the new auth system\n2. Clean up the old auth system\n\n:::info Migrating a deployed app\n\nWhile going through these steps, we will focus first on doing the changes locally (including your local development database).\n\nOnce we confirm everything works well locally, we will apply the same changes to the deployed app (including your production database).\n\n**We'll put extra info for migrating a deployed app in a box like this one.**\n:::\n\n##### 1. Migrate to the New Auth System\n\nYou can follow these steps to migrate to the new auth system (assuming you already migrated the project structure to 0.12, as described [above](#migrating-your-project-to-the-new-structure)):\n\n1. **Migrate `getUserFields` and/or `additionalSignupFields` in the `main.wasp` file to the new `userSignupFields` field.**\n\nIf you are not using them, you can skip this step.\n\nIn Wasp 0.11.X, you could define a `getUserFieldsFn` to specify extra fields that would get saved to the `User` when using Google or GitHub to sign up.\n\nYou could also define `additionalSignupFields` to specify extra fields for the Email or Username & Password signup.\n\nIn 0.12.X, we unified these two concepts into the `userSignupFields` field.\n\n<details>\n  <summary>Migration for <EmailPill /> and <UsernameAndPasswordPill /></summary>\n\n  First, move the value of `auth.signup.additionalFields` to `auth.methods.{method}.userSignupFields` in the `main.wasp` file.\n\n  `{method}` depends on the auth method you are using. For example, if you are using the email auth method, you should move the `auth.signup.additionalFields` to `auth.methods.email.userSignupFields`.\n\n  To finish, update the JS/TS implementation to use the `defineUserSignupFields` from `wasp/server/auth` instead of `defineAdditionalSignupFields` from `@wasp/auth/index.js`.\n\n  <Tabs>\n    <TabItem value=\"before\" label=\"Before\">\n      ```wasp title=\"main.wasp\"\n      app crudTesting {\n        // ...\n        auth: {\n          userEntity: User,\n          methods: {",
        "namespace": "xtasker",
        "timestamp": 1754702909322
      },
      {
        "key": "waspfull_an",
        "value": "\n            email: {},\n          },\n          onAuthFailedRedirectTo: \"/login\",\n          // highlight-start\n          signup: {\n            additionalFields: import { fields } from \"@server/auth/signup.js\",\n          },\n          // highlight-end\n        },\n      }\n      ```\n\n      ```ts title=\"src/server/auth/signup.ts\"\n      // highlight-next-line\n      import { defineAdditionalSignupFields } from '@wasp/auth/index.js'\n\n      // highlight-next-line\n      export const fields = defineAdditionalSignupFields({\n        address: async (data) => {\n          const address = data.address\n          if (typeof address !== 'string') {\n            throw new Error('Address is required')\n          }\n          if (address.length < 5) {\n            throw new Error('Address must be at least 5 characters long')\n          }\n          return address\n        },\n      })\n      ```\n    </TabItem>\n\n    <TabItem value=\"after\" label=\"After\">\n      ```wasp title=\"main.wasp\"\n      app crudTesting {\n        // ...\n        auth: {\n          userEntity: User,\n          methods: {\n            email: {\n              // highlight-next-line\n              userSignupFields: import { fields } from \"@src/server/auth/signup.js\",\n            },\n          },\n          onAuthFailedRedirectTo: \"/login\",\n        },\n      }\n      ```\n\n      ```ts title=\"src/server/auth/signup.ts\"\n      // highlight-next-line\n      import { defineUserSignupFields } from 'wasp/server/auth'\n\n      // highlight-next-line\n      export const fields = defineUserSignupFields({\n        address: async (data) => {\n          const address = data.address;\n          if (typeof address !== 'string') {\n            throw new Error('Address is required');\n          }\n          if (address.length < 5) {\n            throw new Error('Address must be at least 5 characters long');\n          }\n          return address;\n        },\n      })\n      ```\n\n      Read more about the `userSignupFields` function [here](/auth/overview.md#1-defining-extra-fields).\n    </TabItem>\n  </Tabs>\n</details>\n\n<details>\n  <summary>Migration for <GithubPill /> and <GooglePill /></summary>\n\n  First, move the value of `auth.methods.{method}.getUserFieldsFn` to `auth.methods.{method}.userSignupFields` in the `main.wasp` file.\n\n  `{method}` depends on the auth method you are using. For example, if you are using Google auth, you should move the `auth.methods.google.getUserFieldsFn` to `auth.methods.google.userSignupFields`.\n\n  To finish, update the JS/TS implementation to use the `defineUserSignupFields` from `wasp/server/auth` and modify the code to return the fields in the format that `defineUserSignupFields` expects.\n\n  <Tabs>\n    <TabItem value=\"before\" label=\"Before\">\n      ```wasp title=\"main.wasp\"\n      app crudTesting {\n        // ...\n        auth: {\n          userEntity: User,\n          methods: {\n            google: {\n              // highlight-next-line\n              getUserFieldsFn: import { getUserFields } from \"@server/auth/google.js\"\n            },\n          },\n          onAuthFailedRedirectTo: \"/login\",\n        },\n      }\n      ```\n\n      ```ts title=\"src/server/auth/google.ts\"\n      // highlight-next-line\n      import type { GetUserFieldsFn } from '@wasp/types'\n\n      // highlight-start\n      export const getUserFields: GetUserFieldsFn = async (_context, args) => {\n        const displayName = args.profile.displayName\n        return { displayName }\n      }\n      // highlight-end\n      ```\n    </TabItem>\n\n    <TabItem value=\"after\" label=\"After\">\n      ```wasp title=\"main.wasp\"\n      app crudTesting {\n        // ...\n        auth: {\n          userEntity: User,\n          methods: {\n            google: {\n              // highlight-next-line\n              userSignupFields: import { fields } from \"@src/server/auth/google.js\",\n            },\n          },\n          onAuthFailedRedirectTo: \"/login\",\n        },\n      }\n      ```\n\n      ```ts title=\"src/server/auth/signup.ts\"\n      // highlight-next-line\n      import { defineUserSignupFields } from 'wasp/server/auth'\n\n      // highlight-start\n      export const fields = defineUserSignupFields({\n        displayName: async (data) => {\n          const profile: any = data.profile;\n          if (!profile?.displayName) { throw new Error('Display name is not available'); }\n          return profile.displayName;\n        },\n      })\n      // highlight-end\n      ```\n\n      If you want to properly type the `profile` object, we recommend you use a validation library like Zod to define the shape of the `profile` object.\n\n      Read more about this and the `defineUserSignupFields` function in the [Auth Overview - Defining Extra Fields](../auth/overview.md#1-defining-extra-fields) section.\n    </TabItem>\n  </Tabs>\n</details>\n\n1. **Remove the `auth.methods.email.allowUnverifiedLogin` field** from your `main.wasp` file.\n\nIn Wasp 0.12.X we removed the `auth.methods.email.allowUnverifiedLogin` field to make our Email auth implementation easier to reason about. If you were using it, you should remove it from your `main.wasp` file.\n\n1. Ensure your **local development database is running**.\n2. **Do the schema migration** (create the new auth tables in the database) by running:\n   ```bash\n   wasp db migrate-dev\n   ```\n\nYou should see the new `Auth`, `AuthIdentity` and `Session` tables in your database. You can use the `wasp db studio` command to open the database in a GUI and verify the tables are there. At the moment, they will be empty.\n\n1. **Do the data migration** (move existing users from the old auth system to the new one by filling the new auth tables in the database with their data):\n\n   1. **Implement your data migration function(s)** in e.g. `src/migrateToNewAuth.ts`.\n\n      Below we prepared [examples of migration functions](#example-data-migration-functions) for each of the auth methods, for you to use as a starting point.\n      They should be fine to use as-is, meaning you can just copy them and they are likely to work out of the box for typical use cases, but you can also modify them for your needs.\n\n      We recommend you create one function per each auth method that you use in your app.\n\n   2. **Define custom API endpoints for each migration function** you implemented.\n\n      With each data migration function below, we provided a relevant `api` declaration that you should add to your `main.wasp` file.\n\n   3. **Run the data migration function(s)** on the local development database by calling the API endpoints you defined in the previous step.\n\n      You can call the endpoint by visiting the URL in your browser, or by using a tool like `curl` or Postman.\n\n      For example, if you defined the API endpoint at `/migrate-username-and-password`, you can call it by visiting `http://localhost:3001/migrate-username-and-password` in your browser.\n\n      This should be it, you can now run `wasp db studio` again and verify that there is now relevant data in the new auth tables (`Auth` and `AuthIdentity`; `Session` should still be empty for now).\n\n2. **Verify that the basic auth functionality works** by running `wasp start` and successfully signing up / logging in with each of the auth methods.\n\n3. **Update your JS/TS code** to work correctly with the new auth.\n\nYou might want to use the new auth helper functions to get the `email` or `username` from a user object. For example, `user.username` might not work anymore for you, since the `username` obtained by the Username & Password auth method isn't stored on the `User` entity anymore (unless you are explicitly storing something into `user.username`, e.g. via `userSignupFields` for a social auth method like Github). Same goes for `email` from Email auth method.\n\nInstead, you can now use `getUsername(user)` to get the username obtained from Username & Password auth method, or `getEmail(user)` to get the email obtained from Email auth method.\n\nRead more about the helpers in the [Accessing User Data](../auth/entities#accessing-the-auth-fields) section.\n\n1. Finally, **check that your app now fully works as it worked before**. If all the above steps were done correctly, everything should be working now.\n\n   :::info Migrating a deployed app\n\n   After successfully performing migration locally so far, and verifying that your app works as expected, it is time to also migrate our deployed app.\n\n   Before migrating your production (deployed) app, we advise you to back up your production database in case something goes wrong. Also, besides testing it in development, it's good to test the migration in a staging environment if you have one.\n\n   We will perform the production migration in 2 steps:\n\n   - Deploying the new code to production (client and server).\n   - Migrating the production database data.\n\n   ---\n\n   Between these two steps, so after successfully deploying the new code to production and before migrating the production database data, your app will not be working completely: new users will be able to sign up, but existing users won't be able to log in, and already logged in users will be logged out. Once you do the second step, migrating the production database data, it will all be back to normal. You will likely want to keep the time between the two steps as short as you can.\n\n   ---\n\n   - **First step: deploy the new code** (client and server), either via `wasp deploy` (i.e. `wasp deploy fly deploy`) or manually.\n\n     Check our [Deployment docs](../deployment/intro.md) for more details.\n\n   - **Second step: run the data migration functions** on the production database.\n\n     You can do this by calling the API endpoints you defined in the previous step, just like you did locally. You can call the endpoint by visiting the URL in your browser, or by using a tool like `curl` or Postman.\n\n     For example, if you defined the API endpoint at `/migrate-username-and-password`, you can call it by visiting `https://your-server-url.com/migrate-username-and-password` in your browser.\n\n   Your deployed app should be working normally now, with the new auth system.\n   :::\n\n##### 2. Cleanup the Old Auth System\n\nYour app should be working correctly and using new auth, but to finish the migration, we need to clean up the old auth system:\n\n1. In `main.wasp` file, **delete auth-related fields from the `User` entity**, since with 0.12 they got moved to the internal Wasp entity `AuthIdentity`.\n\n   - This means any fields that were required by Wasp for authentication, like `email`, `password`, `isEmailVerified`, `emailVerificationSentAt`, `passwordResetSentAt`, `username`, etc.\n   - There are situations in which you might want to keep some of them, e.g. `email` and/or `username`, if they are still relevant for you due to your custom logic (e.g. you are populating them with `userSignupFields` upon social signup in order to have this info easily available on the `User` entity). Note that they won't be used by Wasp Auth anymore, they are here just for your business logic.\n\n2. In `main.wasp` file, **remove the `externalAuthEntity` field from the `app.auth`** and also **remove the whole `SocialLogin` entity** if you used Google or GitHub auth.\n\n3. **Delete the data migration function(s)** you implemented earlier (e.g. in `src/migrateToNewAuth.ts`) and also the corresponding API endpoints from the `main.wasp` file.\n\n4. **Run `wasp db migrate-dev`** again to apply these changes and remove the redundant fields from the database.\n\n:::info Migrating a deployed app\n\nAfter doing the steps above successfully locally and making sure everything is working, it is time to push these changes to the deployed app again.\n\n_Deploy the app again_, either via `wasp deploy` or manually. Check our [Deployment docs](../deployment/intro.md) for more details.\n\nThe database migrations will automatically run on successful deployment of the server and delete the now redundant auth-related `User` columns from the database.\n\nYour app is now fully migrated to the new auth system.\n\n:::\n\n#### Next Steps\n\nIf you made it this far, you've completed all the necessary steps to get your\nWasp app working with Wasp 0.12.x. Nice work!\n\nFinally, since Wasp no longer requires you to separate your client source files\n(previously in `src/client`) from server source files (previously in\n`src/server`), you are now free to reorganize your project however you think is best,\nas long as you keep all the source files in the `src/` directory.\n\nThis section is optional, but if you didn't like the server/client\nseparation, now's the perfect time to change it.\n\nFor example, if your `src` dir looked like this:\n\n```\nsrc\n│\n├── client\n│   ├── Dashboard.tsx\n│   ├── Login.tsx\n│   ├── MainPage.tsx\n│   ├── Register.tsx\n│   ├── Task.css\n│   ├── TaskLisk.tsx\n│   ├── Task.tsx\n│   └── User.tsx\n├── server\n│   ├── taskActions.ts\n│   ├── taskQueries.ts\n│   ├── userActions.ts\n│   └── userQueries.ts\n└── shared\n    └── utils.ts\n```\n\nyou can now change it to a feature-based structure (which we recommend for any project that is not very small):\n\n```\nsrc\n│\n├── task\n│   ├── actions.ts    -- former taskActions.ts\n│   ├── queries.ts    -- former taskQueries.ts\n│   ├── Task.css\n│   ├── TaskLisk.tsx\n│   └── Task.tsx\n├── user\n│   ├── actions.ts    -- former userActions.ts\n│   ├── Dashboard.tsx\n│   ├── Login.tsx\n│   ├── queries.ts    -- former userQueries.ts\n│   ├── Register.tsx\n│   └── User.tsx\n├── MainPage.tsx\n└── utils.ts\n```\n\n### Appendix\n\n#### Example Data Migration Functions\n\nThe migration functions provided below are written with the typical use cases in mind and you can use them as-is. If your setup requires additional logic, you can use them as a good starting point and modify them to your needs.\n\nNote that all of the functions below are written to be idempotent, meaning that running a function multiple times can't hurt. This allows executing a function again in case only a part of the previous execution succeeded and also means that accidentally running it one time too much won't have any negative effects. **We recommend you keep your data migration functions idempotent**.\n\n##### Username & Password\n\nTo successfully migrate the users using the Username & Password auth method, you will need to do two things:\n\n1. Migrate the user data\n\n<details>\n  <summary>Username & Password data migration function</summary>\n\n  ```wasp title=\"main.wasp\"\n  api migrateUsernameAndPassword {\n    httpRoute: (GET, \"/migrate-username-and-password\"),\n    fn: import { migrateUsernameAndPasswordHandler } from \"@src/migrateToNewAuth\",\n    entities: []\n  }\n  ```\n\n  ```ts title=\"src/migrateToNewAuth.ts\"\n  import { prisma } from \"wasp/server\";\n  import { type ProviderName, type UsernameProviderData } from \"wasp/server/auth\";\n  import { MigrateUsernameAndPassword } from \"wasp/server/api\";\n\n  export const migrateUsernameAndPasswordHandler: MigrateUsernameAndPassword =\n    async (_req, res) => {\n      const result = await migrateUsernameAuth();\n\n      res.status(200).json({ message: \"Migrated users to the new auth\", result });\n    };\n\n  async function migrateUsernameAuth(): Promise<{\n    numUsersAlreadyMigrated: number;\n    numUsersNotUsingThisAuthMethod: number;\n    numUsersMigratedSuccessfully: number;\n  }> {\n    const users = await prisma.user.findMany({\n      include: {\n        auth: true,\n      },\n    });\n\n    const result = {\n      numUsersAlreadyMigrated: 0,\n      numUsersNotUsingThisAuthMethod: 0,\n      numUsersMigratedSuccessfully: 0,\n    };\n\n    for (const user of users) {\n      if (user.auth) {\n        result.numUsersAlreadyMigrated++;\n        console.log(\"Skipping user (already migrated) with id:\", user.id);\n        continue;\n      }\n\n      if (!user.username || !user.password) {\n        result.numUsersNotUsingThisAuthMethod++;\n        console.log(\"Skipping user (not using username auth) with id:\", user.id);\n        continue;\n      }\n\n      const providerData: UsernameProviderData = {\n        hashedPassword: user.password,\n      };\n      const providerName: ProviderName = \"username\";\n\n      await prisma.auth.create({\n        data: {\n          identities: {\n            create: {\n              providerName,\n              providerUserId: user.username.toLowerCase(),\n              providerData: JSON.stringify(providerData),\n            },\n          },\n          user: {\n            connect: {\n              id: user.id,\n            },\n          },\n        },\n      });\n      result.numUsersMigratedSuccessfully++;\n    }\n\n    return result;\n  }\n  ```\n</details>\n\n2. Provide a way for users to migrate their password\n\n   There is a **breaking change between the old and the new auth in the way the password is hashed**. This means that users will need to migrate their password after the migration, as the old password will no longer work.\n\n   Since the only way users using username and password as a login method can verify their identity is by providing both their username and password (there is no email or any other info, unless you asked for it and stored it explicitly), we need to provide them a way to **exchange their old password for a new password**. One way to handle this is to inform them about the need to migrate their password (on the login page) and provide a custom page to migrate the password.\n\n<details>\n  <summary>\n    Steps to create a custom page for migrating the password\n  </summary>\n\n  1. You will need to install the `secure-password` and `sodium-native` packages to use the old hashing algorithm:\n\n  ```bash\n  npm install secure-password@4.0.0 sodium-native@3.3.0 --save-exact\n  ```\n\n  Make sure to save the exact versions of the packages.\n\n  2. Then you'll need to create a new page in your app where users can migrate their password. You can use the following code as a starting point:\n\n  <Tabs groupId=\"js-ts\">\n    <TabItem value=\"js\" label=\"JavaScript\">\n      ```wasp title=\"main.wasp\"\n      route MigratePasswordRoute { path: \"/migrate-password\", to: MigratePassword }\n      page MigratePassword {\n        component: import { MigratePasswordPage } from \"@src/pages/MigratePassword\"\n      }\n      ```\n\n      ```jsx title=\"src/pages/MigratePassword.jsx\"\n      import {\n        FormItemGroup,\n        FormLabel,\n        FormInput,\n        FormError,\n      } from \"wasp/client/auth\";\n      import { useForm } from \"react-hook-form\";\n      import { migratePassword } from \"wasp/client/operations\";\n      import { useState } from \"react\";\n\n      export function MigratePasswordPage() {\n        const [successMessage, setSuccessMessage] = useState(null);\n        const [errorMessage, setErrorMessage] = useState(null);\n        const form = useForm();\n\n        const onSubmit = form.handleSubmit(async (data) => {\n          try {\n            const result = await migratePassword(data);\n            setSuccessMessage(result.message);\n          } catch (e) {\n            console.error(e);\n            if (e instanceof Error) {\n              setErrorMessage(e.message);\n            }\n          }\n        });\n\n        return (\n          <div style={{\n            maxWidth: \"400px\",\n            margin: \"auto\",\n          }}>\n            <h1>Migrate your password</h1>\n            <p>\n              If you have an account on the old version of the website, you can\n              migrate your password to the new version.\n            </p>\n            {successMessage && <div>{successMessage}</div>}\n            {errorMessage && <FormError>{errorMessage}</FormError>}\n            <form onSubmit={onSubmit}>\n              <FormItemGroup>\n                <FormLabel>Username</FormLabel>\n                <FormInput\n                  {...form.register(\"username\", {\n                    required: \"Username is required\",\n                  })}\n                />\n                <FormError>{form.formState.errors.username?.message}</FormError>\n              </FormItemGroup>\n              <FormItemGroup>\n                <FormLabel>Password</FormLabel>\n                <FormInput\n                  {...form.register(\"password\", {\n                    required: \"Password is required\",\n                  })}\n                  type=\"password\"\n                />\n                <FormError>{form.formState.errors.password?.message}</FormError>\n              </FormItemGroup>\n              <button type=\"submit\">Migrate password</button>\n            </form>\n          </div>\n        );\n      }\n      ```\n    </TabItem>\n\n    <TabItem value=\"ts\" label=\"TypeScript\">\n      ```wasp title=\"main.wasp\"\n      route MigratePasswordRoute { path: \"/migrate-password\", to: MigratePassword }\n      page MigratePassword {\n        component: import { MigratePasswordPage } from \"@src/pages/MigratePassword\"\n      }\n      ```\n\n      ```tsx title=\"src/pages/MigratePassword.tsx\"\n      import {\n        FormItemGroup,\n        FormLabel,\n        FormInput,\n        FormError,\n      } from \"wasp/client/auth\";\n      import { useForm } from \"react-hook-form\";\n      import { migratePassword } from \"wasp/client/operations\";\n      import { useState } from \"react\";\n\n      export function MigratePasswordPage() {\n        const [successMessage, setSuccessMessage] = useState<string | null>(null);\n        const [errorMessage, setErrorMessage] = useState<string | null>(null);\n        const form = useForm<{\n          username: string;\n          password: string;\n        }>();\n\n        const onSubmit = form.handleSubmit(async (data) => {\n          try {\n            const result = await migratePassword(data);\n            setSuccessMessage(result.message);\n          } catch (e: unknown) {\n            console.error(e);\n            if (e instanceof Error) {\n              setErrorMessage(e.message);\n            }\n          }\n        });\n\n        return (\n          <div style={{\n            maxWidth: \"400px\",\n            margin: \"auto\",\n          }}>\n            <h1>Migrate your password</h1>\n            <p>\n              If you have an account on the old version of the website, you can\n              migrate your password to the new version.\n            </p>\n            {successMessage && <div>{successMessage}</div>}\n            {errorMessage && <FormError>{errorMessage}</FormError>}\n            <form onSubmit={onSubmit}>\n              <FormItemGroup>\n                <FormLabel>Username</FormLabel>\n                <FormInput\n                  {...form.register(\"username\", {\n                    required: \"Username is required\",\n                  })}\n                />\n                <FormError>{form.formState.errors.username?.message}</FormError>\n              </FormItemGroup>\n              <FormItemGroup>\n                <FormLabel>Password</FormLabel>\n                <FormInput\n                  {...form.register(\"password\", {\n                    required: \"Password is required\",\n                  })}\n                  type=\"password\"\n                />\n                <FormError>{form.formState.errors.password?.message}</FormError>\n              </FormItemGroup>\n              <button type=\"submit\">Migrate password</button>\n            </form>\n          </div>\n        );\n      }\n      ```\n    </TabItem>\n  </Tabs>\n\n  3. Finally, you will need to create a new operation in your app to handle the password migration. You can use the following code as a starting point:\n\n  <Tabs groupId=\"js-ts\">\n    <TabItem value=\"js\" label=\"JavaScript\">\n      ```wasp title=\"main.wasp\"\n      action migratePassword {\n        fn: import { migratePassword } from \"@src/auth\",\n        entities: []\n      }\n      ```\n\n      ```js title=\"src/auth.js\"\n      import SecurePassword from \"secure-password\";\n      import { HttpError } from \"wasp/server\";\n      import {\n        createProviderId,\n        deserializeAndSanitizeProviderData,\n        findAuthIdentity,\n        updateAuthIdentityProviderData,\n      } from \"wasp/server/auth\";\n\n      export const migratePassword = async ({ password, username }, _context) => {\n        const providerId = createProviderId(\"username\", username);\n        const authIdentity = await findAuthIdentity(providerId);\n\n        if (!authIdentity) {\n          throw new HttpError(400, \"Something went wrong\");\n        }\n\n        const providerData = deserializeAndSanitizeProviderData(\n          authIdentity.providerData\n        );\n\n        try {\n          const SP = new SecurePassword();\n\n          // This will verify the password using the old algorithm\n          const result = await SP.verify(\n            Buffer.from(password),\n            Buffer.from(providerData.hashedPassword, \"base64\")\n          );\n\n          if (result !== SecurePassword.VALID) {\n            throw new HttpError(400, \"Something went wrong\");\n          }\n\n          // This will hash the password using the new algorithm and update the\n          // provider data in the database.\n          await updateAuthIdentityProviderData(providerId, providerData, {\n            hashedPassword: password,\n          });\n        } catch (e) {\n          throw new HttpError(400, \"Something went wrong\");\n        }\n\n        return {\n          message: \"Password migrated successfully.\",\n        };\n      };\n      ```\n    </TabItem>\n\n    <TabItem value=\"ts\" label=\"TypeScript\">\n      ```wasp title=\"main.wasp\"\n      action migratePassword {\n        fn: import { migratePassword } from \"@src/auth\",\n        entities: []\n      }\n      ```\n\n      ```ts title=\"src/auth.ts\"\n      import SecurePassword from \"secure-password\";\n      import { HttpError } from \"wasp/server\";\n      import {\n        createProviderId,\n        deserializeAndSanitizeProviderData,\n        findAuthIdentity,\n        updateAuthIdentityProviderData,\n      } from \"wasp/server/auth\";\n      import { MigratePassword } from \"wasp/server/operations\";\n\n      type MigratePasswordInput = {\n        username: string;\n        password: string;\n      };\n      type MigratePasswordOutput = {\n        message: string;\n      };\n\n      export const migratePassword: MigratePassword<\n        MigratePasswordInput,\n        MigratePasswordOutput\n      > = async ({ password, username }, _context) => {\n        const providerId = createProviderId(\"username\", username);\n        const authIdentity = await findAuthIdentity(providerId);\n\n        if (!authIdentity) {\n          throw new HttpError(400, \"Something went wrong\");\n        }\n\n        const providerData = deserializeAndSanitizeProviderData<\"username\">(\n          authIdentity.providerData\n        );\n\n        try {\n          const SP = new SecurePassword();\n\n          // This will verify the password using the old algorithm\n          const result = await SP.verify(\n            Buffer.from(password),\n            Buffer.from(providerData.hashedPassword, \"base64\")\n          );\n\n          if (result !== SecurePassword.VALID) {\n            throw new HttpError(400, \"Something went wrong\");\n          }\n\n          // This will hash the password using the new algorithm and update the\n          // provider data in the database.\n          await updateAuthIdentityProviderData<\"username\">(providerId, providerData, {\n            hashedPassword: password,\n          });\n        } catch (e) {\n          throw new HttpError(400, \"Something went wrong\");\n        }\n\n        return {\n          message: \"Password migrated successfully.\",\n        };\n      };\n      ```\n    </TabItem>\n  </Tabs>\n</details>\n\n##### Email\n\nTo successfully migrate the users using the Email auth method, you will need to do two things:\n\n1. Migrate the user data\n\n<details>\n  <summary>Email data migration function</summary>\n\n  ```wasp title=\"main.wasp\"\n  api migrateEmail {\n    httpRoute: (GET, \"/migrate-email\"),\n    fn: import { migrateEmailHandler } from \"@src/migrateToNewAuth\",\n    entities: []\n  }\n  ```\n\n  ```ts title=\"src/migrateToNewAuth.ts\"\n  import { prisma } from \"wasp/server\";\n  import { type ProviderName, type EmailProviderData } from \"wasp/server/auth\";\n  import { MigrateEmail } from \"wasp/server/api\";\n\n  export const migrateEmailHandler: MigrateEmail =\n    async (_req, res) => {\n      const result = await migrateEmailAuth();\n\n      res.status(200).json({ message: \"Migrated users to the new auth\", result });\n    };\n\n  async function migrateEmailAuth(): Promise<{\n    numUsersAlreadyMigrated: number;\n    numUsersNotUsingThisAuthMethod: number;\n    numUsersMigratedSuccessfully: number;\n  }> {\n    const users = await prisma.user.findMany({\n      include: {\n        auth: true,\n      },\n    });\n\n    const result = {\n      numUsersAlreadyMigrated: 0,\n      numUsersNotUsingThisAuthMethod: 0,\n      numUsersMigratedSuccessfully: 0,\n    };\n\n    for (const user of users) {\n      if (user.auth) {\n        result.numUsersAlreadyMigrated++;\n        console.log(\"Skipping user (already migrated) with id:\", user.id);\n        continue;\n      }\n\n      if (!user.email || !user.password) {\n        result.numUsersNotUsingThisAuthMethod++;\n        console.log(\"Skipping user (not using email auth) with id:\", user.id);\n        continue;\n      }\n\n      const providerData: EmailProviderData = {\n        isEmailVerified: user.isEmailVerified,\n        emailVerificationSentAt:\n          user.emailVerificationSentAt?.toISOString() ?? null,\n        passwordResetSentAt: user.passwordResetSentAt?.toISOString() ?? null,\n        hashedPassword: user.password,\n      };\n      const providerName: ProviderName = \"email\";\n\n      await prisma.auth.create({\n        data: {\n          identities: {\n            create: {\n              providerName,\n              providerUserId: user.email,\n              providerData: JSON.stringify(providerData),\n            },\n          },\n          user: {\n            connect: {\n              id: user.id,\n            },\n          },\n        },\n      });\n      result.numUsersMigratedSuccessfully++;\n    }\n\n    return result;\n  }\n  ```\n</details>\n\n2. Ask the users to reset their password\n\nThere is a **breaking change between the old and the new auth in the way the password is hashed**. This means that users will need to reset their password after the migration, as the old password will no longer work.\n\nIt would be best to notify your users about this change and put a notice on your login page to **request a password reset**.\n\n##### Google & GitHub\n\n<details>\n  <summary>Google & GitHub data migration functions</summary>\n\n  ```wasp title=\"main.wasp\"\n  api migrateGoogle {\n    httpRoute: (GET, \"/migrate-google\"),\n    fn: import { migrateGoogleHandler } from \"@src/migrateToNewAuth\",\n    entities: []\n  }\n\n  api migrateGithub {\n    httpRoute: (GET, \"/migrate-github\"),\n    fn: import { migrateGithubHandler } from \"@src/migrateToNewAuth\",\n    entities: []\n  }\n  ```\n\n  ```ts title=\"src/migrateToNewAuth.ts\"\n  import { prisma } from \"wasp/server\";\n  import { MigrateGoogle, MigrateGithub } from \"wasp/server/api\";\n\n  export const migrateGoogleHandler: MigrateGoogle =\n    async (_req, res) => {\n      const result = await createSocialLoginMigration(\"google\");\n\n      res.status(200).json({ message: \"Migrated users to the new auth\", result });\n    };\n\n  export const migrateGithubHandler: MigrateGithub =\n    async (_req, res) => {\n      const result = await createSocialLoginMigration(\"github\");\n\n      res.status(200).json({ message: \"Migrated users to the new auth\", result });\n    };\n\n  async function createSocialLoginMigration(\n    providerName: \"google\" | \"github\"\n  ): Promise<{\n    numUsersAlreadyMigrated: number;\n    numUsersNotUsingThisAuthMethod: number;\n    numUsersMigratedSuccessfully: number;\n  }> {\n    const users = await prisma.user.findMany({\n      include: {\n        auth: true,\n        externalAuthAssociations: true,\n      },\n    });\n\n    const result = {\n      numUsersAlreadyMigrated: 0,\n      numUsersNotUsingThisAuthMethod: 0,\n      numUsersMigratedSuccessfully: 0,\n    };\n\n    for (const user of users) {\n      if (user.auth) {\n        result.numUsersAlreadyMigrated++;\n        console.log(\"Skipping user (already migrated) with id:\", user.id);\n        continue;\n      }\n\n      const provider = user.externalAuthAssociations.find(\n        (provider) => provider.provider === providerName\n      );\n\n      if (!provider) {\n        result.numUsersNotUsingThisAuthMethod++;\n        console.log(`Skipping user (not using ${providerName} auth) with id:`, user.id);\n        continue;\n      }\n\n      await prisma.auth.create({\n        data: {\n          identities: {\n            create: {\n              providerName,\n              providerUserId: provider.providerId,\n              providerData: JSON.stringify({}),\n            },\n          },\n          user: {\n            connect: {\n              id: user.id,\n            },\n          },\n        },\n      });\n      result.numUsersMigratedSuccessfully++;\n    }\n\n    return result;\n  }\n  ```\n</details>\n\n------",
        "namespace": "xtasker",
        "timestamp": 1754702914017
      },
      {
        "key": "waspfull_index",
        "value": "waspfull_aa waspfull_ab waspfull_ac waspfull_ad waspfull_ae waspfull_af waspfull_ag waspfull_ah waspfull_ai waspfull_aj waspfull_ak waspfull_al waspfull_am waspfull_an ",
        "namespace": "xtasker",
        "timestamp": 1754702954641
      }
    ]
  }